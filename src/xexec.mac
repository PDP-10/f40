	SUBTTL EXEC V.25	20-JAN-72
TITLE EXECUTIVE - I/O HANDLER AND COMMAND STRING INTERPRETER
;COPYRIGHT 1968, 1969,1970,1971,72 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

MLON	;ALLOW MULTI LINE LITERALS

;
;*******REG
;MODIFIED 21 JULY 1972.  R.E. GORIN FOR STANFORD A.I. PROJECT
;REG: REVISED 29 NOVEMBER 1973 TO ALLOW TMPCOR AND RUN UUO AT SU-AI
STANSW=1
CCLSW==1
TEMPC==1
PAGSIZ==^D50		;SHORT PAGES AT STANFORD
;
;*****REG



;CCLSW=1 - GIVES NEW COMMAND LANGUAGE FEATURES
IFNDEF CCLSW,<CCLSW=1>		;NORMALLY ASSEMBLE WITH CCL FEATURES
IFE	CCLSW,<TEMPC==0>
INTERNAL CCLSW			;LOADER ERR MESSAGE IF OTHER SUB PROGS DIFFER
IFN CCLSW,<EXTERNAL CCLFLA>
IFNDEF CCLDMP,<CCLDMP=0>	;FOR CCL, 1 MEANS DO DUMP MODE IO
IFNDEF	TEMPC,<TEMPC==1>	;TMPCOR UUO CAN BE USED IF SET TO 1

IFDEF	REENTR,<HISEG>
	ENTRY		F4EXEC

	EXTERNAL	JOBFF,	JOBREL

	INTERNAL	CHAR,	LSTOUT,	LSTTAB,	ERROUT,	BINOUT,	PANIC
	INTERNAL	LSTFLG,	BINFLG,	CSWFLG,	ESWFLG,	MSWFLG,	TTYFLG
	INTERNAL	ERROR	;"23J"

	EXTERNAL	F4
	EXTERNAL	TITLE,	SUBTLE,	CORSIZ
	EXTERNAL	EXIRLI,	LENGTI,	CSTATI
	EXTERNAL	SEQPNT,	ZERCOR,	PDPSET,	ROLMEM,	JOBFFI
	EXTERNAL	CRR,	EOF,	SPACE,	TAB,	N0
	EXTERNAL	PDPSWZ,	PROGNZ,	CARBUF,	EROADR,	CRDCNT,	LINCNT,	PAGCNT
	EXTERNAL	ERRCNZ,	TTLERR,	NUMPRO,	BOTTOM,	FLOORS

	EXTERNAL	NCDML,	PDLOV	;"23J"
	EXTERNAL	XE,	XE1,	XE2,	XE3
	EXTERNAL	AC00,	AC01,	AC02,	AC03
	EXTERNAL	AC04,	AC05,	AC06,	AC07
	EXTERNAL	AC10,	AC11,	AC12,	AC13
	EXTERNAL	AC14,	EXTSAV

IFN	TEMPC,
<
	EXTERNAL	TMPFIL,	TMPFLG
>

	EXTERNAL	CMDBUF,	CMDPNT,	CMDCNT
	EXTERNAL	TTOBUF,	TTOPNT,	TTOCNT
	EXTERNAL	BINBUF,	BINPNT,	BINCNT
	EXTERNAL	LSTBUF,	LSTPNT,	LSTCNT
	EXTERNAL	SRCBUF,	SRCPNT,	SRCCNT


	INTERNAL	MOTFLG,	HDRBIT	;"21A" ;"23Q"
	INTERNAL	ISWBIT	;"23Q"


;DEBUG PACKAGE SWITCHES

;	FORTRAN IV CONTAINS A DEBUG FEATURE WHICH LISTS A TRACE OF THE
;POP EXECUTIONS. IT IS CONTAINED IN ANY VERSION OF THE COMPILER WHICH
;HAD "DEBUG" DEFINED WHEN FILES 1,2,3, AND 4 WERE ASSEMBLED.

;	ALTHOUGH ALL VERSIONS OF THE COMPILER ARE CAPABLE OF PRODUCING
;A TRACE, BEST RESULTS (MNEMONIC POPS AND CONDITIONAL LISTING FEATURES)
;ARE OBTAINED WITH A HALF-WORD VERSION. NO HALF-WORD ASSEMBLY LISTING
;IS NECESSARY, HOWEVER, SINCE THE POPMEM LOCATION COUNTER (%01) ADDRESS
;FOR ANY GIVEN INSTRUCTION IN HALF-WORD IS THE SAME AS THAT FOR FULL-WORD.

;	THE SWITCHES ARE LOCATED AT THE BEGINNING OF THE EXEC SO THAT
;THEY CAN BE SET WITHOUT DDT (LOCATION 140,141,ETC.).

;	THE MAIN SWITCH IS DEBSW, WHICH HAS THE FOLLOWING OPTIONS:

;	DEBSW:	0	IGNORE TRACE
;		-1	UNCONDITIONAL TRACE
;		+1	CONDITIONAL TRACE (DEBSW1,2,3,4)
;		+2	CONDITIONAL TRACE WITH ROLL DUMP

;	WHEN IN CONDITIONAL MODE, THE TRACE LINE IS LISTED WHEN ANY OF
;THE FOLLOWING CONDITIONS ARE SATISIFIED:

;	1.	IF THE LEFT HALF OF DEBSW1 IS NON-ZERO, THE DEBUG PACKAGE
;WILL START LISTING WHEN THE POPMEM LOCATION IN THE LEFT HALF IS
;ENCOUNTERED AND LIST EACH POP UNTIL THE POPMEM LOCATION IN THE RIGHT
;HALF, INCLUSIVE, WILL BE LISTED.

;	2.	EACH POPMEM LOCATION EXECUTION WHICH LIES BETWEEN THE
;VALUE IN THE LEFT HALF OF DEBSW2 (NON-ZERO) AND THE VALUE IN THE RIGHT
;HALF, INCLUSIVE, WILL BE LISTED.

;	3.	THE FOLLOWING POP INSTRUCTIONS WILL BE LISTED IF THE
;CORRESPONDING BIT IN DEBSW3 IS SET:

;	BIT 0:	JMP
;	    1:	JMPT
;	    2:	JMPF
;	    3:	JSB
;	    4:	JSBT
;	    5:	JSBF
;	    6:	JOW
;	    7:	XIT/XML (T,F)

;THUS, THE BASIC FLOW COULD BE TRACED BY SETTING BITS 3,4, AND 5
;(JSB'S).


;	4.	ANY OTHER POPS, INCLUDING THEIR TRUE/FALSE VARIATIONS,
;CAN BE CONDITIONALLY SELECTED BY SETTING THEIR CORRESPONDING BITS IN
;DEBSW4 (4 WORDS). THUS BIT 0 OF WORD 0 REPRESENTS POP #0, BIT 3 OF
;WORD 1 REPRESENTS POP #38, ETC. THE POP NUMBERS CAN BE FOUND IN THE
;HALF-WORD SYMBOL TABLE OR BY HAVING DDT TYPE OUT OPTTBL IN SIXBIT.

;	DEBSW6 ALLOWS THE USER TO LIST ANY SELECTED LOCATION IN UPPER
;MEMORY WITH EACH TRACE LINE LISTED. THUS IF DEBSW6 IS NON-ZERO,
;THE CONTENTS OFF ZZ + (DEBSW6) WILL BE LISTED.

	INTERNAL	DEBSW
	INTERNAL	DEBSW1,DEBSW2,DEBSW3,DEBSW4,DEBSW5,DEBSW6

DEBSW:			;MASTER SWITCH
	0
DEBSW1:			;START LISTING AT (LH), STOP AT (RH)
	0
DEBSW2:			;LIST BETWEEN (LH) AND (RH)
	0
DEBSW3:			;JMP,JSB,ETC.
	0
DEBSW4:			;ALL OTHER POPS
	0		; 0-35D,	0-43 OCTAL
	0		; 36-71,	44-107
	0		; 72-107,	110-153
	0		;108-127,	154-177

DEBSW5:			;ROLL DUMP
	0
DEBSW6:			;LIST (ZZ+(RH))
			; (IF BIT 17 IS SET, LIST IN SIXBIT)




	;BITS FOR GETCHR STATUS AND IO STATUS CALLS:
TTYDEV=	10		;1-DEVICE IS A TTY
OUTBIT=	1	;1-DEVICE CAN DO OUTPUT
INBIT=	2	;2-DEVICE CAN DO INPUT
IODATA= 200000		;1-IO DATA ERROR
IODEV=  100000		;1-IO PARITY ERROR
IOWRLK= 400000		;1 IO WRITE LOCK ERROR
IOBKTL=	40000		;1-IO BLOCK TOO LARGE
IOEOF=	20000		;1-END OF FILE ON IO DEVICE

BINMOD=	14		;BINARY MODE
ALMODE=	1		;ASCII LINE MODE

%00=	0
%01=	1
%02=	2
%03=	3
%04=	4
%05=	5
%06=	6
%07=	7
%10=	10
%11=	11
%12=	12
%13=	13
%14=	14
%15=	15	;"23D"
%16=	16
%17=	17

OPDEF	RESET	[CALLI	 0]
OPDEF	DEVCHR	[CALLI	 4]
OPDEF	CORE	[CALLI	11]
OPDEF	UTPCLR	[CALLI	13]
OPDEF	DATE	[CALLI	14]
OPDEF	MSTIME	[CALLI	23]
OPDEF	PJOB	[CALLI  30]

OPDEF	EXIT	[CALLI  12]
OPDEF	SETNAM	[CALLI  43]

OPDEF	RUN	[CALLI  35]
OPDEF	SETDDT	[CALLI   2]
OPDEF	DDTOUT	[CALLI   3]
OPDEF	TMPCOR	[CALLI	44]
OPDEF	APRENB	[CALLI	16]	;"23J"
	;COMPILER AND EXEC FLAGS

	;FLAGS SET BY EXEC, USED BY COMPILER (LEFT HALF OF AC 16)

		LSTBIT=	001		; 1-SUPRESS LISTING OUTPUT
		BINBIT=	002		; 1-SUPRESS BINARY OUTPUT
		CSWBIT=	004		; 1-SUPRESS CROSS REFERENCE
		ESWBIT=	010		; 1-SUPRESS LISTING OF BINARY
		MSWBIT=	020		; 1-SUPRESS MACRO LISTING
		NSWBIT=	040		; 1-SUPRESS ERRORS ON TTY
		SSWBIT=	100		; 1-TOGGLE MODE OF OUTPUT
		TTYBIT=	200		; 1-LISTING IS ON TTY
		ISWBIT=	400		; 1-D IN COLUMN 1 CHANGED TO SPACE	;"23Q"

		LSTFLG=	LSTBIT_9
		BINFLG=	BINBIT_9
		CSWFLG=	<LSTBIT!CSWBIT>_9
		ESWFLG=	<LSTBIT!ESWBIT>_9
		MSWFLG=	<LSTBIT!MSWBIT>_9
		TTYFLG=	<LSTBIT!TTYBIT>_9
					;LINE DELETED ;"23Q"
		MOTFLG=	TTYFLG!MSWFLG	;M SWITCH OR TTY LISTING FLAG

	;VARIABLE PARAMETERS

IFNDEF	PAGSIZ,
<
		PAGSIZ=	^D53		;NUMBER OF LINES ON A PAGE
>

	;FLAGS SET AND USED ONLY BY THE EXEC
		ARWBIT=	1		;1-LEFT ARROW SEEN
		EXTBIT=	2		;1-EXPLICIT EXTENSION SEEN
		SWTBIT=	4		;1-ENTER SWITCH MODE
		INFOBIT=10		;1-VALID INFORMATION SEEN
		FILBIT=	20		;1-EXPLICIT FILE NAME SEEN
		NORBIT=	100		;1-NORMAL MODE COMMAND
		ENDBIT=	400		;1-END OF ALL INPUT FILES
		SLSHBIT=1000		;1-SWITCH MODE ENTERED WITH A </>
		STNBIT=	2000		;1-MORE THAN ONE STANDARD FILE
		NULBIT=	10000		;1-NON-NULL COMMAND STRING
		EOFBIT=	20000		;1-END OF FILE ENCOUNTERED
		NCDBIT=	40000		;1-NEXT CARD ALREADY IN BUFFER
		HDRBIT=	100000		;1-NEW PAGE WITH HEADER	;"21A"
	;LINE DELETED	;"23D"

		TTO=	0		;DEVICE PARAMETERS
		BIN=	1
		LST=	2
		SRC=	3
		CMD=	4
		CRFEOF=	37		;FLAG FOR CREF PROGRAM BREAK

XX=	0	;INDICATES INSTRUCTION MODIFICATION
	;INITIALIZATION OF FORTRAN IV EXECUTIVE PROGRAM
	;THE EXEC HAS THREE ENTRY POINTS:
	;	1. F4EXEC - THE EXEC SHOULD BE ENTERED HERE ONLY AT
	;	   THE BEGINNING. IT CALLS SIXBIT /RESET/ TO INITIALIZE
	;	   THE IO DEVICES BEFORE FALLING INTO RSTRT1.
	;	2. RSTRT1 - THIS ENTRY POINT IS USED EVERY TIME A NEW
	;	   COMMAND STRING IS DESIRED. THIS WILL HAPPEN AFTER ONE
	;	   NORMAL MODE COMMAND STRING (I.E. WITH LEFT ARROWS,
	;	   COLONS ETC.) OR AFTER THE LAST OF A NUMBER OF STANDARD
	;	   COMMANDS HAVE BEEN PROCESSED. RSTRT1 FIRST CHECKS
	;	   TO SEE HOW MUCH CORE IS AVAILABLE TO THE JOB. A CARD
	;	   BUFFER IS SET UP TO HOLD 5 CARDS OR 19 CARDS, AND
	;	   AN INDEX REGISTER IS SET FOR SINGLE OR DOUBLE IO
	;	   BUFFERS, DEPENDING ON THE AMOUNT OF CORE. AFTER
	;	   INITIALIZING THE TTY FOR IO, THE CONTENTS OF JOBFF
	;	   ARE SAVED SO THAT A LATER ENTRY AT RSTRT2 WILL NOT
	;	   CLOBBER THE REMAINDER OF THE COMMAND STRING
	;	3. RSTRT2 - THIS IS THE ENTRY POINT USED FOR STANDARD
	;	   COMMANDS. AFTER EACH FILE OF A STANDARD COMMAND
	;	   HAS BEEN PROCESSED, THE EXEC RETURNS TO RSTRT2,
	;	   RE-INITIALIZES THE PUSHDOWN LIST, AND SETS UP OTHER
	;	   PARAMETERS OF COMPILATION.

IFN CCLSW,<IFN CCLDMP,<

JOBDDT=	74	;CONTAINS STARTING LOCATION OF DDT IF LOADED
JOBS41=	122	;WHERE JOB LOCATION 41 IS SAVED
JOBCOR=	133	;CONTAINS NUMBER OF WORDS OF CORE IN USE
INTERNAL JOBDDT,JOBS41,JOBCOR
;IF JOB DATA AREA CHANGES, THIS WILL
;CAUSE LOADER ERROR MESSAGES. GOOD!

EXTERNAL JOBSA,JOB41


RUNDMP:	IOWD	XX,INHERE		;DMP MODE COMMAND LIST
	0				;STOP	DMP MODE IO

RUN2:	IN	BIN,RUNDMP		;START DUMP MODE IO GOING
	JRST	RUN3			;NO ERRORS, GO TO AC'S FOR MORE
RUN2A:	MOVEI	%00,RUNERR
	DDTOUT	%00,		;TYPE ERR MESSAGE  (REST OF CORE IS GONE)
	EXIT
RUNERR:	ASCIZ	/LINKAGE ERROR/

INHERE:				;THE DUMP MODE IO STARTS LOADING
				; NEXT PROG HERE

RUNUUO:	MOVEI	%00,16		;SET IO MODE FOR "OPEN" UUO
	SKIPN	%01		;ANY DEVICE SPECIFIED?
	MOVSI	%01,(SIXBIT /SYS/);NO ASSUME SYS
	MOVEI	%02,0		;NO BUFFER HEADERS

	TRNN	%16,EXTBIT	;PERIOD TYPED?
	MOVEM	%14,XE		;NO, THEN FILENAME IS IN %14

	TRNN	%16,EXTBIT	;PERIOD TYPED?
	MOVSI	%14,(SIXBIT /SAV/);NO EXT SPECIFIED ASSUME SAV
	HLLZM	%14,XE1		;SET UP EXTENSION

	OPEN	BIN,%00		;INIT DEVICE FOR DUMP MODE
	JRST	RUNER1		;FAILED
	LOOKUP	BIN,XE
	JRST	[MOVSI	%14,(SIXBIT /DMP/)	;LOOKUP FAILED, TRY AGAIN
		HLLZM	%14,XE1			;ASSUME DMP THIS TIME
		TRNN	%16,EXTBIT		;WAS EXTENSION EXPLICIT?
		LOOKUP	BIN,XE			;WILL THIS LOOKUP FAIL?
		JRST	RUNER1			;YES, YES, TYPE ERR MESSAGE
		JRST	.+1]			;"." IS LOC OF JRST TO LITERAL
	HLRO	%10,XE3			;GET NEG. WORD COUNT OF DUMP FILE
	HRLM	%10,RUNDMP		;SAVE IN DMP MODE COMMAND LIST
	MOVNS	%10			;GET POS. WORD COUNT
	MOVEI	%14,JOBDDT-1(%10)	;FIND LAST ADR OF RUNABLE NEW PROGRAM
	HRRM	%14,RUNBLT+RUNBEG	;SAVE AS "E" FOR THE BLT
	MOVE	%01,XE			;GET NEW FILE NAME FOR SETNAM
	MOVEI	%14,INHERE(%10)		;GET LAST ADR OF DUMP FILE IN CORE
	JSP	%10,DELFIL		;DELETE COMMAND FILE
	CORE	%14,			;GET AMOUNT OF CORE NECESSARY
	JRST	RUNER2			;NEEDED MORE AND COULDN'T GET IT
	SETNAM	%01,			;MAKE SYSDPY WORK RIGHT
	MOVSI	%17,RUNBEG
	BLT	%17,BLTAC		;LOAD AC'S WITH FINAL CODE
	JRST	RUN2			;NEXT CODE IS AT BEGINNING SO IT WON'T
					;BE OVER WRITTEN BY IO

RUNER1:	JSP	%10,ERROR
	SIXBIT	/LINKAGE ERROR FOR 23]/
RUNER2:	JSP	%10,ERROR
	SIXBIT	/NOT ENOUGH CORE FOR LINKAGE]/

RUNBEG:	PHASE	0			;THIS CODE RUNS IN AC'S
RUN3:	SKIPE	RUNAC,INHERE+JOBCOR-JOBDDT	;GET CORE SIZE TO RUN IN
	CAMG	RUNAC,JOBREL		;DO WE HAVE ENOUGH CORE?
	JRST	RUN4			;YES, OR IT DOESN'T MATTER
	CORE	RUNAC,			;NO, GET THE CORE
	JRST	RUN2A			;IT FAILED
RUN4:	MOVE	RUNAC,JOBS41+INHERE-JOBDDT	;GET NEXT PROGRAM'S JOB41
	MOVEM	RUNAC,JOB41		;SET IT UP
	MOVE	RUNAC,INHERE+JOBDDT-JOBDDT	;GET NEXT JOBDDT
	SETDDT	RUNAC,			;AND SET IT UP WITH UUO
RUNBLT:	BLT	BLTAC,XX		;ADR MODIFIED
	RESET
	AOS	1,JOBSA			;GET STARTING ADDRESS
	JRST	0(1)			;START UP NEXT PROGRAM
BLTAC:	XWD	INHERE+1,JOBDDT+1	;MOVE PROGRAM DOWN (JOBDDT ALREADY SET UP)
RUNAC=	.				;TEMP	AC
	DEPHASE				;AND BACK TO NORMAL ASSEMBLY

>>

PATCH:	BLOCK 20
	INTERNAL PATCH

F4EXEC:
IFN CCLSW,
<	TDZA	0,0		;NORMAL ENTRY, CLEAR CCL FLAG
	SETOM	0		;CCL ENTRY, SET FLAG
	MOVEM	0,CCLFLA	;SAVE FLAG (CCL_-1)(NO CCL_0)
>
NULFIL:	RESET			;RESET ALL I/O
IFN	TEMPC,
<	SETZM	TMPFLG
>
	JOBAPR=	125		;"23J"
	MOVEI	%00,PDLOV	;"23J"
	HRRZM	%00,JOBAPR	;"23J"
	MOVEI	%00,620000	;PUSHDOWN OVERFLOW + REPEAT ENABLE	;"23J"
	APRENB	%00,		;SET TRAP TO PDLOV	;"23J"
	MOVE	%17,PDPSET	;INIT PUSH DOWN LIST POINTER
	HLRZ	%06,LENGTI	;GET LENGTH OF CARD BUFFER PLUS EXIT-ROLL
	ADDM	%06,JOBFF	;SAVE THE ROOM
IFN CCLSW,
<	SKIPE	CCLFLA		;CCL BEING USED?
	PUSHJ	%17,DSKNIT	;YES, INIT DSK FOR COMMAND FILE, SKIP RETURN
>
	PUSHJ	%17,TTINIT	;NO, INIT TTY FOR COMMANDS
CMDSET:	INBUF	CMD,1		;SET UP 1 INPUT BUFFER
	HRRZ	%00,JOBFF
	HRLM	%00,JOBFFI	;SAVE THIS POINT TO RE-INIT FOR NEXT CCL COMMAND

NXTCCL:				;THE NEXT CCL COMMAND IS PROCESSED STARTING HERE
	MOVE	%06,ZERCOR	;GET BLT POINTER
	SETZM	-1(%06)		;ZERO "ZERA"
	BLT	%06,CARBUF	;ZERO VARIABLES
	HRRZ	%06,LENGTI	;GET # OF CONTINUATION CARDS
	MOVEM	%06,CRDCNT	;SAVE, (WIPED OUT BY BLT ABOVE)
	MOVE	%17,PDPSET	;INIT PUSH DOWN LIST POINTER
IFDEF	DEBUG,
<	MOVSI	%16,BINBIT!LSTBIT!CSWBIT!ESWBIT!LSTFLG
	;SUPPRESS ALL OUTPUTS (EXCEPT TTY)
>
IFNDEF	DEBUG,
<	MOVSI	%16,BINBIT!LSTBIT!CSWBIT!ESWBIT!LSTFLG!MSWBIT
	;SUPPRESS ALL OUTPUTS (EXCEPT TTY)
>
	PUSHJ	%17,TTONIT	;INIT TTY FOR OUTPUT
IFN CCLSW,
<	SKIPE	CCLFLA
	JRST	RSTRT2		;DON'T TYPE * IF DOING CCL STUFF
>
	MOVEI	%02,"*"		;TYPE AN ASTERISK AT THE USER
	PUSHJ	%17,TTYDMP	;...
	OUTPUT	TTO,		;REALLY OUTPUT IT

RSTRT2:	SETZM	PAGCNT		;CLEAR PAGE COUNTER
	SETZM	EXTSAV		;CLEAR HEADER EXTENSION

IFN CCLSW,		;NO "SRC" DEVICE IMPLIES NO STANDARD COMMANDS
<	MOVSI	%01,(SIXBIT /SRC/)
	DEVCHR	%01,		;GET "SRC" DEVICE CHARACTERISTICS
	TDZE	%01,%01		;DOES "SRC" DEVICE NOT EXIST?
	SKIPE	CCLFLA		;OR USING CCL MODE?
	TRO	%16,NORBIT	;YES, USE NORMAL COMMAND SCANNER
>
;THE FOLLOWING SECTION OF CODE IS ENTERED EITHER AFTER
;SUCCESSIVE CALLS TO GETBIN,GETLST AND GETSRC, OR AFTER
;THE STANDARD SUBROUTINE FINISHES INITIALIZING A FILE. IT
;SAVES THE FLAG ACCUMULATOR (AC %16), THEN SAVES ALL THE EXEC
;ACCUMULATORS. IF THERE IS A BINARY FILE, IT CALLS OUTBIN
;TO DO AN INITIAL OUTPUT AND SET UP ACCUMULATOR C. SIMILARLY,
;IF THERE IS A LISTING FILE, A CALL IS MADE TO HDRSET (A SUB-
;SECTION OF LSTOUT) TO PRINT THE TITLE, DATE AND TIME ON THE
;FIRST PAGE BEFORE THE COMPILER IS CALLED. FINALLY, INFORMATION
;ABOUT THE BEGINNING AND END OF ROLL MEMORY IS SET UP IN ROLMEM
;AND ACCUMULATOR ZERO ACCORDING TO THE FOLLOWING FORMAT:
;	1. AC 0 - RIGHT HALF HAS ABSOLUTE ADDRESS OF HIGHEST
;	   LOCATION OF ROLL MEMORY. LEFT HALF HAS ABSOLUTE
;	   ADDRESS OF FIRST WORD OF ROLL MEMORY.
;	2. ROLMEM - SAME FORMAT AS AC 0, BUT WITH LEFT HALF
;	   AND RIGHT HALF EXCHANGED.


	PUSHJ	%17,GETBIN	;INITIALIZE THE BINARY FILE
	TRNN	%16,ARWBIT	;GO ON TO SOURCE IF _ HAS BEEN SEEN
	PUSHJ	%17,GETLST	;INITIALIZE THE LISTING FILE
	SETZB	%01,XE3		;NO HOLD OVER ON DEVICE OR PROJ,PROG #'S
	PUSHJ	%17,GETSRC	;INITIALIZE THE SOURCE FILE

IFN CCLSW,		;PRINT MESSAGE GIVING NAME OF FILE COMPILING
<	MOVEI	%10,[SIXBIT /FORTRAN:  34]/]
	SKIPE	CCLFLA		;CCL MODE?
	PUSHJ	%17,LSTMS3	;YES, PRINT "FORTRAN:  FILENAME.EXT"
>
REST1:	PUSHJ	%17,ACSAVE		;SAVE EXEC AC'S
	MOVE	%06,ZERCOR
	BLT	%06,EROADR		;ZERO VARIABLES
	LDB	%07,[POINT 9,%16,17]
	DPB	%07,[POINT 9,%16, 8]	;TRANSFER FLAGS TO ACTIVE
	JFCL	1,.+1			;CLEAR PC CHANGE OR FLOATING OVFLO FLAG
	JRST	.+1			;SET PC CHANGE FLAG ON PDP-6
	JFCL	1,.+2			;TEST PC CHANGE FLAG
	TLOA	%06,-1			;-1 PDP-10
	TDZ	%06,%06			; 0 PDP-6
	TLNE	%16,SSWBIT
	TLC	%06,-1			;TOGGLE IF REQUESTED
	HLLEM	%06,PDPSWZ		;STORE MACHINE TYPE
	TRZE	%16,EOFBIT		;READY FOR NEW FILE?
	PUSHJ	%17,CHAR5		;YES, GET IT
	TRZN	%16,NCDBIT		;START OF NEW FILE?
	PUSHJ	%17,NCDML		;YES, GET THE FIRST CARD
	MOVEI	%06,1			;GET BIT TO SET ;"21A"
	TDNN	%16,[XWD LSTFLG,EOFBIT]	;IS THERE A LISTING ? ;"21A"
	IORM	%06,@SEQPNT		;YES, PASS INFO TO LSTOUT ;"21A"
	MOVE	%04,EXIRLI		;SET EXIT ROLL
	HRRZ	%00,JOBFF
	SKIPN	ROLMEM			;FIRST TIME AROUND?
	MOVEM	%00,ROLMEM		;YES, SAVE START OF ROLL MEMORY
	HRLZ	%00,ROLMEM		;SET %00 FOR F4
	HRR	%00,JOBREL
	PUSHJ	%17,F4			;CALL THE COMPILER
	TLNN	%16,LSTFLG
	PUSHJ	%17,LSTCR		;SKIP ONE LINE
	PUSHJ	%17,ACSAVE		;SWAP AC'S
	HRRZ	%11,JOBREL		;GET TOP OF CORE
	ADD	%11,BOTTOM		;
	SUB	%11,FLOORS		;DEDUCT UNUSED SPACE
	LSH	%11,-^D10		;CONVERT TO K
	CAMLE	%11,CORSIZ		;
	MOVEM	%11,CORSIZ		;KEEP ONLY LARGEST SIZE
	SKIPN	%11,ERRCNZ		;ANY ERRORS?
	SKIPE	PROGNZ			;NO, IS THIS COMPILATION FOR REAL?
	AOSA	NUMPRO			;YES, TALLY COMPILATION COUNT
	JRST	REST2			;NO, DON'T LIST ERROR COUNT
	ADDM	%11,TTLERR		;UPDATE TOTAL ERROR COUNT
	HLLOS	LINCNT			;SHORT OUT HEADER ROUTINE
IFN CCLSW,
<	SKIPE	CCLFLA		;IN CCL MODE, DON'T TYPE "0 ERRORS"
	JUMPE	%11,REST4
>
	MOVE	%00,PROGNZ		;GET PROGRAM NAME
	PUSHJ	%17,LSTSIX		;LIST IT
	MOVEI	%10,[SIXBIT /[ERRORS DETECTED: 5]/]
	PUSHJ	%17,LSTMS3		;LIST MESSAGE
REST4:	SKIPL	@SEQPNT			;END OF FILE?
	TROA	%16,NCDBIT		;NO, MUST BE "END" STATEMENT
	JRST	REST2			;YES, FINISH UP
	MOVEI	%02,CRFEOF		;CREF PSEUDO - FORM FEED
	TLNN	%16,CSWFLG		;CREF LISTING ?
	PUSHJ	%17,LSTDMP		;YES, EOF FOR CREF
	JRST	REST1			;MOVE TO NEXT COMPILATION
REST2:	MOVE	%11,TTLERR
	TRNE	%16,ENDBIT!NORBIT	;ANY MORE FILES?
	SOSGE	NUMPRO			;OR NO VALID COMPILATIONS?
	JRST	EXIT			;YES, SKIP FINAL MESSAGE
	JUMPLE	%11,REST5		;IF NO ERRORS, DON'T PRINT "TOTAL MESSAGE"
	TLZ	%16,NSWBIT_9		;NO, BE SURE TO TYPE FINAL MESSAGE
	PUSHJ	%17,ERRCR		;SKIP A LINE
	JUMPE	%11,REST3		;ANY ERRORS?
	MOVEI	%02,"?"-40		;YES, KEEP BATCH HAPPY
	PUSHJ	%17,ERROUT
	PUSHJ 	%17,ERRSP

REST3:	MOVE	%00,[SIXBIT /TOTAL/]
	PUSHJ	%17,LSTSIX		;LIST TOTAL ERRORS
	MOVEI	%10,[SIXBIT /[ERRORS DETECTED: 5]/]
	PUSHJ	%17,LSTMS3
REST5:
IFN CCLSW,
<	EXTERNAL	JOBERR	;STORES TOTAL CCL ERRORS
	HRRZ	%11,TTLERR		;GET TOTAL F4 ERRORS
	ADDM	%11,JOBERR		;UPDATE TOTAL CCL ERRORS
>
	AOS	%11,CORSIZ
	MOVEI	%10,[SIXBIT /_ 5K CORE USED_]/]
IFN CCLSW,<	SKIPN CCLFLA>	;NO CORE MESSAGE IN CCL MODE
	PUSHJ	%17,LSTMS3		;LIST MESSAGE
	JRST	EXIT			;CLOSE OUT
IFN CCLSW,
<
DSKNIT:				;INIT DSK FOR CCL
IFN	TEMPC,
<	MOVE	%00,JOBFF
	ADDI	%00,200		;GET ENOUGH BUFFER SPACE
	CORE	%00,		;GET CORE !
	JRST	F4EXEC		;NO CORE AVAILABLE
	HRRZ	%00,JOBFF	;USE JOBFF AS START OF CCL BUFFER
	HRRM	%00,CMDPNT	;DUMMY UP BUFFER HEADER
	HRRM	%00,TMPFIL+1	;SET UP TMPCOR READ BLOCK
	SOS	TMPFIL+1	;MAKE IT PROPER IOWD FORMAT
	HRRI	%01,(SIXBIT /FOR/)
	HRLM	%01,TMPFIL	;SETUP NAME OF FILE TO BE READ
	MOVNI	%01,200		;AND WORD COUNT
	HRLM	%01,TMPFIL+1	;IN READ BLOCK
	MOVE	%01,[XWD 2,TMPFIL]	;SET UP AC FOR A READ
	TMPCOR	%01,		;READ AND DELETE "FOR" FILE
	JRST	TMPEND		;NO FILE IN CORE TRY DISK
	ADD	%00,%01		;GET END OF FILE
	MOVEM	%00,JOBFF	;UPDATE JOBFF SO FILE ISN'T WIPED OUT
	HRLM	%00,JOBFFI	;SAVE FOR LATER
	IMULI	%01,5		;CALCULATE CHARACTER COUNT
	MOVEM	%01,CMDCNT	;STORE IN BUFFER HEADER
	MOVSI	%01,(POINT 7,,)	;BYTE POINTER
	HLLM	%01,CMDPNT	;BUFFER HEADER NOW SETUP
	SETOM	TMPFLG		;MARK THAT TMPCOR UUO IN PROGRESS
	POP	%17,%02		;POP OFF RETURN
	JRST	NXTCCL		;RETURN TO MAIN STREAM
TMPEND:
>
;******REG
IFE STANSW,<
	MOVEI	%00,3		;INIT 3 DIGIT COUNTER
	PJOB	%02,		;GET JOB NUMBER
DSKNI1:	IDIVI	%02,^D10	;GET LAST DIGIT
	ADDI	%03,"0"-40	;CONVERT TO SIXBIT
	LSHC	%03,-6		;SLIDE CHAR INTO AC4
	SOJG	%00,DSKNI1	;3 CHARS YET?
	HRRI	%04,(SIXBIT /FOR/)	;YES, GET FILENAME ###FOR.TMP
	MOVEM	%04,XE		;SAVE FILE NAME IN LOOKUP DIRECTORY
	MOVSI	%04,(SIXBIT /TMP/)	;SET UP EXTENSION
	MOVEM	%04,XE1		;SAVE EXTENSION IN LOOKUP DIRECTORY
>
IFN STANSW,<
	MOVE	%04,['QQFORT']
	MOVEM	%04,XE
	MOVSI	%04,'RPG'
	MOVEM	%04,XE1
>
;*******REG
	SETZM	XE3		;ZERO PROJ,PROG #'S

	MOVEI	%00,ALMODE	;ASCII LINE DATA MODE
	MOVSI	%01,(SIXBIT /DSK/)
	MOVEI	%02,CMDBUF	;GET BUFFER HEADER ADDRESS
	OPEN	CMD,%00		;INIT DSK OK?
	JRST	DSKNI2		;NO, TYPE MESSAGE
	LOOKUP	CMD,XE		;LOOKUP ###FOR.TMP ON DISK
	JRST	DSKNI2		;FILE NOT FOUND
	JRST	CPOPJ1		;FILE FOUND, SKIP RETURN
DSKNI2:	MOVE	%00,JOBFF
	HRLM	%00,JOBFFI
	JRST	ERRCF1
>
;INITIALIZE A BINARY FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE, AND
;AN OPTIONAL FILE NAME EXTENSION, THE DEVICE IS INITIALIZED IN
;BINARY MODE ON CHANNEL ONE, WITH EITHER ONE OR TWO BUFFERS.

GETBIN:	MOVSI	%13,(Z BIN,)	;SET SWITCH AC
	PUSHJ	%17,GETCHR	;GET A DEVICE NAME AND FILE NAME
	POPJ	%17,0		;NULL FILE EXIT
BIN2:	MOVE	%00,[INIT BIN,BINMOD]	;INIT IN BINARY MODE
IFN CCLSW,
<	SKIPN	%01
	MOVSI	%01,(SIXBIT /DSK/)	;IF NO DEV. SPECIFIED, ASSUME DSK
>
	MOVSI	%02,BINBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE THE BINARY DEVICE
	XWD OUTBIT,1_BINMOD	;DEVCHR BITS THAT MUST BE 1
	OUTBUF	BIN,2		;GIVE IT EITHER 1 OR 2 BUFFERS
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
BIN3:	TRZN	%16,EXTBIT	;WAC THERE AN EXTENSION
	MOVSI	%14,(SIXBIT /REL/)	;SAVE EXTENSION IN LOOKUP BLOCK
	HLLZM	%14,XE1
	ENTER	BIN,XE		;ENTER FILE NAME IN DIRECTORY
	JRST	ERRNR		;DIRECTORY FULL
	TLZ	%16,BINBIT	;INDICATE GOOD BINARY FILE
	POPJ	%17,		;EXIT


;INITIALIZE A LISTING FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE AND
;AN OPTIONAL FILENAME EXTENSION, THE DEVICE IS INITIALIZED IN
;ASCII LINE MODE ON CHANNEL 2, IF THE DEVICE IS A TTY, THE
;TTYLST FLAG IS SET TO 1, AND THE INBUF/OUTBUF INDEX IS INCREMENTED.

GETLST:	MOVSI	%13,(Z LST,)	;SET SWITCH AC
	MOVSI	%01,(SIXBIT /DSK/)	;ASSUME STANDARD DEVICE FOR CREF
	PUSHJ	%17,GETCHR	;GET A DEVICE AND FILE NAME
	TLNN	%16,CSWBIT	;NULL FILE & CREF LISTING ?
	CAIA			;YES, SAME AS GOOD FILE
	POPJ	%17,		;NO, EXIT
	TLNN	%16,CSWBIT	;CREF LISTING ?
	TRNE	%16,EXTBIT	;YES, EXPLICIT EXTENSION SEEN ?
	JRST	LST2		;NO, PROCESS SPECIFICATION
	TRZN	%16,FILBIT	;HAS A FILE NAME BEEN SEEN
	MOVE	%14,[SIXBIT /CREF/]	;STANDARD FILE NAME
	MOVEM	%14,XE		;NO, STORE STANDARD ASSUMPTION
	MOVSI	%14,(SIXBIT /CRF/)
	TRO	%16,EXTBIT	;INDICATE EXTENSION
LST2:	MOVE	%00,[INIT LST,ALMODE]	;INIT IN ASCII LINE MODE
IFN CCLSW,
<	SKIPN	%01
	MOVSI	%01,(SIXBIT /DSK/)	;IF NO DEV. SPECIFIED, ASSUME DSK
>
	MOVSI	%02,LSTBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE LISTING FILE
	XWD OUTBIT,1_ALMODE	;BITS THAT MUST BE 1
	MOVE	%00,%01
	DEVCHR	%00,		;GET DEVICE CHARACTERISTICS
	TLNE	%00,TTYDEV	;IS IT A TTY?
	TLO	%16,TTYBIT	;SET FLAG
	OUTBUF	LST,2		;GIVE IT DYNAMIC NO. OF BUFFERS
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
LST3:	TRNE	%16,ARWBIT	;STANDARD FILE?
	TRZN	%16,EXTBIT	;WAS THERE AN EXTENSION?
	MOVSI	%14,(SIXBIT /LST/)	;NO
	HLLZM	%14,XE1		;SAVE EXTENSION IN LOOKUP BLOCK
	ENTER	LST,XE		;ENTER FILE NAME IN DIR.
	JRST	ERRNR		;DIRECTORY FULL
	TLZ	%16,LSTBIT	;INDICATE A GOOD LISTING FILE
	POPJ	%17,		;EXIT


;INITIALIZE A SOURCE FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE AND
;AN OPTIONAL FILE NAME EXTENSION. THE DEVICE IS INITIALIZED
;IN ASCII LINE MODE ON CHANNEL 3, AND THE FILE NAME ASSOCIATED
;WITH THE SOURCE FILE IS USED AS THE TITLE ON THE LISTING.

GETSRC:	MOVSI	%13,(Z SRC,)	;SET SWITCH AC
	PUSHJ	%17,GETCHR	;GET A DEVICE NAME AND FILE NAME
	JRST	ERRSE		;COMMAND ERROR IF A NULL
SRC2:	MOVE	%00,[INIT SRC,ALMODE]	;INIT IN ASCII LINE MODE
IFN CCLSW,
<	SKIPN	%01
	MOVSI	%01,(SIXBIT /DSK/)	;IF NO DEV. SPECIFIED, ASSUME DSK
>
	MOVEI	%02,SRCBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE THE SOURCE DEVICE
	XWD INBIT,1_ALMODE	;BITS THAT MUST BE 1
	MOVE	%05,JOBFF	;SAVE CURRENT JOBFF SO INPUT BUFFER
	HRRM	%05,JOBFFI	;SPACE MAY BE RECLAIMED
	INBUF	SRC,2	;GIVE IT A DYNAMIC NUMBER OF BUFFERS

				;GET NUMBER OF BUFFERS
	MOVEI	%05,204*2		;COMPUTE MAX SIZE
	ADD	%05,JOBFFI
	TRNN	%16,ENDBIT	;LAST FILE?
	HRRM	%05,JOBFF	;NO, SAVE ROOM FOR LARGER FILE
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
SRC3:	TRZE	%16,EXTBIT	;WAS AN EXPLICIT EXTENSION SEEN?
	JRST	SRC3A		;YES, LOOK FOR IT
	MOVSI	%14,(SIXBIT /F4/)
	HLLZM	%14,XE1		;NO, TRY .F4 FIRST
	LOOKUP	SRC,XE
	TDZA	%14,%14		;NOT FOUND, TRY BLANK
	POPJ	%17,		;FOUND
SRC3A:	HLLZM	%14,XE1		;SAVE EXTENSION IN LOOKUP BLOCK
	HLLZM	%14,EXTSAV	;SAVE EXTENSION FOR HEADER
	LOOKUP	SRC,XE		;LOOKUP FILE NAME
	JRST	ERRCF		;FILE NOT FOUND
	POPJ	%17,		;EXIT
;THE FOLLOWING SMALL ROUTINES PROCESS THE VARIOUS CHARACTERS
;FOUND IN THE COMMAND STRING. THE VARIOUS PECULIARITIES OF THE
;ROUTINES ARE AS FOLLOWS:
;	1. THE LEFT ARROW ROUTINE IDENTIFIES THE COMMAND STRING
;	   AS BEING OF NORMAL MODE. IT ALSO ACTS AS A FILE
;	   SPECIFICATION DELIMITER
;	2. THE PERIOD ROUTINE IDENTIFIES THE FOLLOWING THREE
;	   CHARACTER WORD AS BEING A FILE NAME EXTENSION. THE
;	   CURRENT WORD IN AC %14 IS STORED AS THE FILE NAME,
;	   AND THE ROUTINE PROCEEDS TO GATHER THE EXTENSION.
;	3. THE COLON ROUTINE IDENTIFIES THE COMMAND STRNG AS
;	   A NORMAL MODE COMMAND, AND ALSO DELIMITS A DEVICE
;	   NAME. THE DEVICE NAME IS PUT IN AC %00+1, AND THE ROUTIE
;	   RETURNS TO GETCHR TO GATHER MORE OF THE FILE.
;	4. THE COMMA ROUTINE LOOKS FOR A NULL FILE, OTHERWISE
;	   DISTINGUISHES BETWEEN STANDARD COMMANDS AND NORMAL
;	   COMMANDS.
;	5. THE CARRIAGE RETURN ROUTINE CHECKS TO SEE IF IT IS
;	   JUST A RANDOM CARRIAGE RETURN. IF NOT, IT IS TREATED
;	   THE SAME AS A COMMA


;LEFT ARROW PROCESSOR
LFTARW:	TRO	%16,ARWBIT+NORBIT;SET APPROPRIATE FLAGS
	TRNN	%16,EXTBIT	;IS THIS A FILE NAME EXTENSION?
	MOVEM	%14,XE		;NO, ITS A FILE NAME
	TRZE	%16,INFOBIT	;IS THIS A NULL FILE?
CPOPJ1:	AOS	(%17)		;GOOD EXIT
CPOPJ:	POPJ	%17,		;...
;PERIOD PROCESSOR
PERIOD:	TRO	%16,EXTBIT	;SET FLAG FOR EXPLICIT EXTENSION
	MOVEM	%14,XE		;SAVE THE FILE NAME
	JRST	GETCHR		;RE-ENTER THE GETCHR ROUTINE
;COLON PROCESSOR
COLON:	TRO	%16,NORBIT	;SET FLAG FOR NORMAL MODE COMMAND
	TRZ	%16,FILBIT	;IF  CHAR. FOLLOW, FILE NAME
	MOVE	%01,%14		;SET UP NEW DEVICE NAME
	JRST	GETCHR		;RETURN FOR MORE COMMAND
;COMMA PROCESSOR
COMMA:	TRZN	%16,INFOBIT+FILBIT	;IS THIS A NULL FILE?  FILBIT IS AN EXTRA
	TRNE	%16,ARWBIT	;ONLY LOOK FOR THEM IF NO _
	CAIA			;NOT A NULL FILE
	POPJ	%17,		;NULL FILE, EXIT
	TRNN	%16,NORBIT	;IS IT A NORMAL MODE COMMAND?
	JRST	STNPRO		;NO, DEFINE A STANDARD
COMMA1:	TRNN	%16,EXTBIT	;DO WE HAVE A FILE NAME EXTENSION?
	MOVEM	%14,XE		;NO, IT WAS A FILE NAME
	JRST	CPOPJ1		;GOOD EXIT
;CARRIAGE RETURN PROCESSOR
CARRTN:	TRNN	%16,NULBIT	;IS THIS JUST A RANDOM CR?
	JRST	NULFIL		;YES, RESTART COMPLETELY
	TRON	%16,NORBIT+ENDBIT;IS THIS A NORMAL MODE COMMAND?
	JRST	STNPRO		;NO, GO DEFINE A STANDARD
	TRNN	%16,ARWBIT	;YES, HAS A LEFT ARROW BEEN SEEN?
	JRST	ERRSE		;NO, SYNTAX ERROR
	JRST	COMMA1		;YES, TREAT IT LIKE A COMMA
;THE STANDARD ROUTINE IS ENTERED WHEN THE COMMA ROUTINE DIS-
;COVERS THAT IT IS NOT WORKING WITH A NORMAL MODE COMMAND. 
;THE BEGINNING OF THE EXEC DID A PUSHJ TO GETBIN, WHICH IN
;TURN DID A PUSHJ TO GETCHR, SO THERE ARE TWO RANDOM THINGS
;ON THE PUSHDOWN LIST WHICH ARE TAKEN OFF. THE ROUTINE CHECKS
;TO SEE IF THE WORD IT HAS IN AC %14 IS A FILE NAME OR A FILE
;NAME EXTENSION. IT THEN TRIES TO INITIALIZE EACH STANDARD
;DEVICE. IF THE DEVCHR UUO REPORTS THAT THERE AINT NO SUCH
;ANIMAL, IT ASSUMES THAT THE USER DOES NOT WISH ANY OUTPUT ON
;THAT FILE (BIN OR LST). ON THE FIRST STANDARD FILE, IT ENTERS
;THE INITIALIZATION ROUTINES AT BIN2, LST2, AND SRC2.
;THEREAFTER, THE ROUTINES ARE ENTERED AT BIN3, LST3 AND SRC3
;TO AVOID DOING AN INIT AGAIN.

STNPRO:	MOVE	%17,PDPSET	;RESET PUSH-DOWN LIST
	TRNN	%16,EXTBIT
	MOVEM	%14,XE		;SAVE FILE NAME
	MOVSI	%06,-3		;GET A COUNT FOR 3 DEVICES
SPROC1:	HLLZ	%01,STNLST(%06)	;GET A STANDARD DEVICE
	DEVCHR	%01,		;GET ITS DEVICE CHARACTERISTICS
	JUMPE	%01,SPROC2(%06)	;HANDLE NULL DEVICES DIFFERENTLY
	HLLZ	%01,STNLST(%06)	;GET DEVICE IN PROPER AC THIS TIME
	HLRZ	%05,LIST(%06)	;GET ADDRESS OF PROPER ROUTINE
	TRNE	%16,STNBIT	;IS THIS THE FIRST STANDARD FILE?
	HRRZ	%05,LIST(%06)	;NO, SKIP THE INIT, JUST LOOKUP
	PUSHJ	%17,(%05)	;GO TO IT
SPROC3:	AOBJN	%06,SPROC1	;MORE DEVICES TO INITIALIZE?
	TRO	%16,STNBIT	;SET BIT FOR NEXT STANDARD FILE
	JRST	REST1		;NO, RE-ENTER MAIN ROUTINE

SPROC2:	JRST	ERRSE		;NULL SOURCE DEVICE - ERROR
	JRST	SPROC3		;GO BACK FOR NEXT DEVICE
	JRST	SPROC3		;NO, GO BACK FOR NEXT DEVICE


LIST:	XWD	SRC2, SRC3	;INITIALIZATION ADDRESSES: LH...
	XWD	LST2, LST3	;IS FOR STANDARD FILES WHOSE...
	XWD	BIN2, BIN3	;DEVICES HAVE NOT BEEN INITTED


STNLST:
ERRXCT:	<SIXBIT /SRC/>	+ERR1
	<SIXBIT /LST/>	+ERR2
	<SIXBIT /BIN/>	+ERR3
			+ERR4
			+DNC
			+ERR6	;"23J"
;EXEC COMMAND STRING DISPATCHING
;THIS ROUTINE PICKS UP CHARACTERS FROM THE EXEC TTY BUFFER AND
;DISPATCHES TO THE PROPER ROUTINE DEPENDING ON THE TYPE OF
;CHARACTER. A TABLE OF BYTES AND BYTE POINTERS ALLOWS EACH CHARAC-
;TER IN THE ASCII SET TO BE TREATED INDIVIDUALLY.


GETCHR:	SETZ	%14,		;CLEAR SYMBOL WORD
	MOVE	%06,[POINT 6,%14]
GETCMN:	PUSHJ	%17,GETCMD	;GET NEXT CHARACTER
	CAIN	%05,"["		;PROJECT-PROGRAMMER PAIR?
	JRST	LFTBRA		;YES
	CAIGE	%10,4		;MODIFY CODE IF .GE. 4
	TRNN	%16,SWTBIT	;MODIFY IF SWITCH IS ON
	ADDI	%10,4		;CHANGE DISPATCH BY ADDING 4
	HRRZ	%02,DSPTCH(%10)	;LOAD RIGHT HALF DISPATCH
	CAIL	%10,10		;SKIP IF CORRECT
	HLRZ	%02,DSPTCH-10(%10);OTHERWISE, GET LEFT HALF DSPTCH
	JRST	@%02		;GO TO CORRECT ROUTINE

IFN CCLSW,
<
GETCM3:	MOVNI	%00,5		;YES
	ADDM	%00,CMDCNT	;REDUCE COUNT BY 5 BYTES
	AOS	CMDPNT		;ADVANCE BYTE POINTER INTO NEXT WORD
>
GETCMD:	SOSG	CMDCNT		;DECREMENT CHAR COUNT. ANY LEFT?
	PUSHJ	%17,GETCM1	;NO, GET ANOTHER BUFFER FULL
	ILDB	%05,CMDPNT	;GET A CHARACTER FROM TTY BUFFER
IFN CCLSW,
<	MOVE	%00,@CMDPNT	;GET WORD CONTAINING LAST BYTE
	TRNE	%00,1		;WAS SEQUENCE # BIT ON?
	JRST	GETCM3
>
	CAIN	%05,175		;NO, IS CHARACTER OLD ALT-MODE?
	MOVEI	%05,33		;YES, MAKE IT NEW ALT-MODE
	CAIL	%05,140		;IS CHAR LOWER CASE?
	TRZ	%05,40		;YES, CHANGE TO UPPER CASE
	MOVE	%10,%05		;ANOTHER COPY OF IT IN AC %10
	IDIVI	%10,^D9		;TRANSLATE TO 4-BIT CODE
	LDB	%10,TABLE(%11)	;USE PROPER BYTE POINTER
	CAIN	%10,4		;IS IT A NULL?
	JRST	GETCMD		;YES, TRY AGAIN
	POPJ	%17,		;NO, EXIT

GETCM1:

IFN	CCLSW,<IFN	TEMPC,
<	SKIPE	TMPFLG			;IS A TMPCOR UUO GOING ?
	JRST	GETCM2			;YES,THEN WE ARE DONE !
>>
	IN	CMD,			;GET NEXT BUFFER
	POPJ	%17,		;NO ERRORS OR END-OF-FILE
	STATZ	CMD,IODATA!IODEV!IOBKTL
	JRST	ERRCMD		;DATA ERRORS
GETCM2:	MOVEI	%05,15		;FOR EOF (AND NO CCL MODE) RETURN CARR RET.
IFN CCLSW,
<	SKIPN	CCLFLA>		;SKIP FOR CCL MODE COMMANDS
	JRST	CPOPJ1		;FOR NON-CCL, SKIP RETURN WITH CARR. RET.
IFN CCLSW,
<	JSP	%10,DELFIL	;DELETE COMMAND FILE
	EXIT
>

;COMMAND DISPATCH TABLE AND BYTE POINTERS
DSPTCH:	XWD	GETCMN,	ERRBS	;IGNORED CHAR, BAD CHAR(SWITCH)
	XWD	SWTCH,	SWTCHA	;<(>, LETTER(SWITCH MODE)
	XWD	COLON,	ERRBS	;<:>, NUMBER(SWITCH MODE)
	XWD	PERIOD,	SWTCHE	;<.>,<)>ESCAPE SWITCH MODE
	XWD	LFTARW,	ERRIC	;<_> OR <=>, BAD CHAR (NORMAL MODE)
	XWD	COMMA,	STORE	;<,>,ALPHABETICH CHAR (NORMAL)
	XWD	CARRTN,	STORE	;<CR>,NUMERIC CHAR (NORMAL)
	XWD	SLASH,	ERRIC	;</>, <)> ILLEGAL ESCAPE
IFN CCLSW,
<	XWD	RUNUUO,0
	XWD	INDFIL,0>
IFE CCLSW,
<	XWD	ERRIC,0
	XWD	ERRIC,0>

TABLE:	POINT	4, BITE(%10), 3
	POINT	4, BITE(%10), 7
	POINT	4, BITE(%10), 11
	POINT	4, BITE(%10), 15
	POINT	4, BITE(%10), 19
	POINT	4, BITE(%10), 23
	POINT	4, BITE(%10), 27
	POINT	4, BITE(%10), 31
	POINT	4, BITE(%10), 35

IFN	CCLSW,	;"21B"
<INDFIL:	TRNN	%16,ARWBIT!STNBIT	;STANDARD OR NORMAL MODE,
	TLNN	%16,BINBIT		;OR BINARY SPECIFIED ?
	JRST	ERRIC			;YES, ILLEGAL CHARACTER
	MOVE	%00,[INIT	CMD,ALMODE]
	SKIPN	%01			;INIT CMD FOR @ FILE
	MOVSI	%01,(SIXBIT/DSK/)
	MOVEI	%02,CMDBUF
	PUSHJ	%17,INISET
	XWD	INBIT,1_ALMODE
	TRZE	%16,EXTBIT		;EXTENSION ?
	JRST	INDFI1		;YES, DON'T TRY ASSUMPTIONS
	MOVSI	%14,(SIXBIT/CMD/)
	HLLZM	%14,XE1
	LOOKUP	CMD,XE
	TDZA	%14,%14			;NULL EXTENSION
	JRST	CMDSET
INDFI1:	HLLZM	%14,XE1
	LOOKUP	CMD,XE
	JRST	ERRCF			;CANNOT FIND ERROR
	SETOM	CCLFLA			;INDICATE NON-STANDARD COMMAND STRING
	JRST	CMDSET			;EXTRA ADDRESS ON PDL PREVENTS INFINITE LOOP
>
;BYTE TABLE FOR DISPATCHING
;CLASSIFICATION BYTE CODES


;	BYTE	DISP	CLASSIFICATION


;	00	00	ILLEGAL CHARACTER, SWITCH MODE
;	01	01	ALPHABETIC CHARACTER, SWITCH MODE
;	02	02	NUMERIC CHARACTER, SWTICH MODE
;	03	03	SWITCH MODE ESCAPE, SWITCH MODE


;	00	04	ILLEGAL CHARACTER, NORMAL MODE
;	01	05	ALPHABETIC CHARACTER, NORMAL MODE
;	02	06	NUMERIC CHARACTER, NORMAL MODE
;	03	07	SWITCH MODE ESCAPE, NORMAL MODE


;	04	10	IGNORED CHARACTER
;	05	11	ENTER SWITCH MODE WITH A <(>
;	06	12	DEVICE DELIMITER, <:>
;	07	13	FILE EXTENSION DELIMITER, <.>
;	10	14	OUTPUT SPEC. DELIMITER, <_> OR <=>
;	11	15	FILE DELIMITER, <,>
;	12	16	COMMAND TERMINATOR, <CR>
;	13	17	ENTER SWITCH MODE WITH </>
;	14	20	CCL FILE DELIMITER
;	15	21	INDIRECT FILE DELIMITER <@>


;BYTE TABLE:


BITE:	BYTE	(4) 4,0,0,0,0,0,0,0,0
	BYTE	(4) 4,12,4,4,12,0,0,0,0
	BYTE	(4) 0,0,0,0,0,0,0,0,12
	BYTE	(4) 12,0,0,0,0,4,14,4,0
	BYTE	(4) 0,0,0,0,5,3,0,0,11
	BYTE	(4) 0,7,13,2,2,2,2,2,2
	BYTE	(4) 2,2,2,2,6,0,0,10,0
	BYTE	(4) 14,15,1,1,1,1,1,1,1
	BYTE	(4) 1,1,1,1,1,1,1,1,1
	BYTE	(4) 1,1,1,1,1,1,1,1,1
	BYTE	(4) 1,0,0,0,0,10,0,0,0
REPEAT 0,		;LOWER CASE CHARS ARE CHANGED TO UPPER CASE
<	BYTE	(4) 0,0,0,0,0,0,0,0,0
	BYTE	(4) 0,0,0,0,0,0,0,0,0
	BYTE	(4) 0,0,0,0,0,0,0,0,12
	BYTE	(4) 0,4
>
;THE FOLLOWING TWO ROUTINES HANDLE ALPHANUMERIC CHARACTERS
;FOUND IN THE COMMAND STRING. IN NORMAL MODE, THE CHARACTER
;IS DEPOSITED TO FORM A SIXBIT SYMBOL. IN SWITCH MODE, THE
;PROPER INSTRUCTION IS EXECUTED WITH THE AID OF A DISPATCH
;TABLE. THEN, IF SWITCH MODE WAS ENTERED WITH A SLASH, THE
;EXEC EXITS FROM SWITCH MODE.


STORE:	TRO	%16,INFOBIT+NULBIT+FILBIT;TURN ON BITS FOR CR ROUTINE
	SUBI	%05,40		;CONVERT SIXBIT TO ASCII
	TLNE	%06,770000	;DON'T STORE IF NO ROOM FOR CHAR
	IDPB	%05,%06		;PLOP THE CHARACTER INTO AC %14
	JRST	GETCMN		;RETURN

SWTCHA:	MOVEI	%11,-"A"(%05)
	MOVE	%10,[POINT 4,BYTAB]
	IBP	%10
	SOJGE	%11,.-1
	LDB	%11,%10
	JUMPE	%11,ERRBS	;ILLEGAL SWITCH IF ZERO
	CAILE	%11,SWTABA-SWTAB	;SWITCH TO BE SET AFTER _ ?
	JRST	SWTSET		;YES, SET SWITCH
	TRNE	%16,ARWBIT	;HAS _ BEEN SEEN?
	JRST	ERRLA		;YES, ERROR
	CAILE	%11,SWTABB-SWTAB	;SWITCH TO BE SET AFTER FIRST STANDARD FILE ?
	JRST	SWTSET		;YES, SET SWITCH
	TRNE	%16,STNBIT	;HAS FIRST STANDARD FILE BEEN SEEN ?
	JRST	ERRSF		;YES ERROR
SWTSET:	XCT	SWTAB-1(%11)
	JRST	ERRBS
	TRZE	%16,SLSHBIT	;CALLED BY A SLASH?
	TRZ	%16,SWTBIT	;YES, EXIT FROM SWITCH MODE
	JRST	GETCMN		;NO, RETURN FOR MORE CHARACTERS


;THE FOLLOWING THREE ROUTINES HANDLE THE CONTROL CHARACTERS
;IN THE COMMAND STRING WHICH CAUSE THE EXEC TO ENTER INTO AND
;EXIT FROM SWITCH MODE. THERE ARE TWO TYPES OF SWITCH MODE,
;DEPENDING ON WHETHER IT IS ENTERED WITH A </> OR A <(>.


SLASH:	TRO	%16,SLSHBIT	;TURN ON THE SPECIAL SWITCH MODE
SWTCH:	TROA	%16,SWTBIT	;TURN ON NORMAL SWITCH MODE
SWTCHE:	TRZ	%16,SWTBIT	;TURN OFF THE NORMAL SWITCH MODE
	JRST	GETCMN		;RETURN FOR MORE CHARACTERS

CSWSET:				;TEST & TOGGLE CREF LISTING SWITCH
	TLNE	%16,LSTBIT	;IS THERE A LISTING FILE ?
	TRNN	%16,ARWBIT+STNBIT	;HAS LISTING SPEC, FIELD BEEN PASSED ?
	TLCA	%16,CSWBIT	;NO, TOGGLE THE SWITCH
	JRST	ERRCSW		;YES, ERROR
	JRST	CPOPJ1		;EXIT WITH SWITCH TOGGLED

;DISPATCH TABLE FOR SWITCHES


	DEFINE	SETSW	(LETTER, INSTRUCTION) <
	INSTRUCTION
	Y=<"LETTER"-"A">-^D9*<X=<"LETTER"-"A">/^D9>
	SETCOD	\X,Y>

	DEFINE	SETCOD	(X,Y)
	<BYTAB'X=BYTAB'X!<.-SWTAB>B<4*Y+3>>

BYTAB0=	0
BYTAB1=	0
BYTAB2=	0

SWTAB:
	SETSW	Z,<TDOE  %13, [UTPCLR  ]>
SWTABB:
	SETSW	S,<TLCA  %16, SSWBIT>
SWTABA:
	SETSW	A,<TDOE  %13, [MTAPE 16]>
	SETSW	B,<TDOE  %13, [MTAPE 17]>
	SETSW	T,<TDOE  %13, [MTAPE 10]>
	SETSW	W,<TDOE  %13, [MTAPE  1]>

	SETSW	C,<PUSHJ %17,CSWSET>

	SETSW	I,<TLCA  %16,ISWBIT>	;"23Q"

	SETSW	E,<TLCA  %16,ESWBIT>

	SETSW	M,<TLCA  %16,MSWBIT>

	SETSW	N,<TLCA  %16,NSWBIT>


BYTAB:	+BYTAB0
	+BYTAB1
	+BYTAB2

IF2,	<PURGE	X,	Y,	BYTAB0,	BYTAB1,	BYTAB2	>
LFTBRA:	SETZM	XE3		;CLEAR NUMBER
LFTBR1:	HRLZS	XE3		;COMMA, MOVE TO LEFT HALF
LFTBR2:	PUSHJ	%17,GETCMD	;GET NEXT CHAR
	CAIN	%05,"]"		;TERMINAL?
	JRST	GETCMN		;YES, EXIT
	CAIN	%05,","		;SEPARATOR?
	JRST	LFTBR1		;YES
;*****REG
IFE STANSW,<
	CAIL	%05,"0"		;TEST FOR OCTAL NUMBER
	CAILE	%05,"7"
	JRST	ERRIC		;IMPROPER CHARACTER
	HRRZ	%10,XE3		;OK, GET PREVIOUS VALUE
	IMULI	%10,8
	ADDI	%10,-"0"(%05)	;ACCUMULATE NEW NUMBER
>
IFN STANSW,<
	HRRZ	%10,XE3
	LSH	%10,6
	ADDI	%10,-" "(%05)
>
;*******REG
	HRRM	%10,XE3
	JRST	LFTBR2

IFN CCLSW,
<IFE CCLDMP,	;ASSEMBLE ONLY FOR CCL -AND- NO DUMP MODE IO
<
RUNUUO:				;PASS PROG SPEC TO RUN UUO
	SKIPN	%01
	MOVSI	%01,(SIXBIT /SYS/)	;IF NO DEV. SPECIFIED, ASSUME SYS

	TRNN	%16,EXTBIT		;PERIOD TYPED?
	MOVEM	%14,XE			;NO, THEN FILE NAME IS IN %14

	TRNN	%16,EXTBIT		;PERIOD TYPED?
	MOVEI	%14,0			;NO, ASSUME 0 EXTENSION
	HLLZM	%14,XE1			;SAVE IN DIRECTORY

	JSP	%10,DELFIL		;DELETE COMMAND FILE

	MOVE	%00,[XWD 1,%01]		;START INCREMENT,,6 WORD RUN BLOCK ADR
				;%01/	DEVICE
	MOVE	%02,XE		;GET FILENAME
	MOVE	%03,XE1		;GET EXTENSION
	SETZB	%04,%06
	MOVE	%05,XE3		;GET PROJ,PROG
	RUN	%00,		;START NEXT PROGRAM
	JSP	%10,ERROR	;RUN FAILED
	SIXBIT /LINKAGE ERROR FOR 23]/
>
DELFIL:	CLOSE 	CMD,0	;CLOSE COMMAND FILE
	SETZB	%04,%05
	SETZB	%06,%07
IFN	TEMPC,
<	SKIPE	TMPFLG		;IS A TMPCOR UUO BEING USED ?
	JRST	(%10)		;YES,DON'T TRY TO RENAME FILE !
>
	RENAME	CMD,%04		;FLUSH COMMAND FILE
	JFCL			;IT FAILED, SO WHO CARES
	JRST	(%10)
>
;SUBROUTINE FOR OUTPUT ON THE LISTING FILE
;SUBROUTINES LSTOUT AND LSTMES ARE STRAIGHT-LINE CODING
;PROGRAMS THAT DECREMENT THE COUNT OF THE LISTING DEVICE BUFFER
;AND OUTPUT A BUFFER WHEN REQUIRED. A CHECK IS MADE FOR THE
;OCCURRENCE OF DATA ERRORS AND DEVICE ERRORS.
;THE TWO ROUTINES ARE CALLED IN THE FOLLOWING MANNER;
;CALLS TO LSTOUT
;	JSP	%11,LSTOUT
;	CHARACTER RIGHT JUSTIFIED IN ACCUMULATOR %02


;CALLS TO LSTMES
;	MOVEI	%10,ADDRESS OF MESSAGE
;	PUSHJ	%17,LSTMES
;THE ROUTINE LSTOUT SEARCHES FOR CARRIAGE RETURNS, AND CALLS
;HEADER TO OUTPUT A CARRIAGE RETURN - LINE FEED AND A FORM FEED
;IF NECESSARY. NO CHECK IS MADE FOR LINE FEEDS OR FORM FEEDS IN
;LSTOUT, SINCE CHAR FILTERS THEM OUT OF THE INPUT FILES.


LSTOUT:	TRZE	%16,HDRBIT	;NEW PAGE REQUESTED	;"21A"
	PUSHJ	%17,HDRSET	;YES, PAGE AND OUTPUT HEADER	;"21A"
	ADDI	%02,40		;CONVERT TO ASCII
	CAIN	%02,"["
LSTTAB:	MOVEI	%02,11		;SET TAB
	CAIE	%02,"_"		;CARRIAGE RETURN ?	;"21A"
				;LINE DELETED ;"21A"
				;LINE DELETED ;"21A"
	JRST	LSTDMP		;NO, DUMP THE CHARACTER
				;LINE DELETED ;"21A"
				;LINE DELETED ;"21A"
				;LINE DELETED ;"21A"
LSTCR:	MOVEI	%02,15		;CARRIAGE RETURN
	PUSHJ	%17,LSTDMP
	MOVEI	%02,12		;LINE FEED
	PUSHJ	%17,LSTDMP
	TLNE	%16,TTYBIT	;LISTING TO TTY?
	PUSHJ	%17,LIST1	;YES, DUMP THE LINE
	JRST	HEADER		;TEST LINE COUNT

LSTDMP:	SOSG	LSTCNT		;DECREMENT ITEM COUNT
	PUSHJ	%17,LIST1	;EMPTY ENTIRE BUFFER
	IDPB	%02,LSTPNT	;STORE THE CHARACTER
	POPJ	%17,		;EXIT


LIST1:	OUTPUT	LST,		;EMPTY A BUFFER
LSTTST:	STATO	LST,IODATA!IODEV!IOWRLK	;CHECK FOR ERRORS
	POPJ	%17,		;NO, EXIT
	JSP	%10,ERROR
	SIXBIT /LISTING OUTPUT ERROR]/
;ROUTINES FOR OUTPUT ON THE ERROR FILE
;THE FOLLOWING CONVENTIONS ARE OBSERVED FOR OUTPUT ON THE ERROR
;FILE:	1. IF THERE IS A LISTING DEVICE, THE ERROR IS ALWAYS
;	   OUTPUT ON THE LISTING DEVICE
;	2. IF THERE IS NO LISTING DEVICE, THE ERROR WILL BE
;	   TYPED ON THE CONSOLE TTY, AND THE ROUTINE EXITS
;	3. AFTER THE CHARACTER HAS BEEN OUTPUT ON THE LISTING
;	   FILE, THE CHARACTER WILL ALSO BE OUTPUT ON THE TTY
;	   UNLESS ONE OF THE FOLLOWING CONDITIONS EXISTS:
;	   A. THE USER HAS REQUESTED THAT ERRORS BE SUPPRESSED
;	   B. THE LISTING FILE IS ITSELF A TTY.
;	4. IF CERTAINS CONDITIONS OCCUR,THE MESSAGE  "SOURCE
;		ERROR(S) IN FILEXXX " WILL BE TYPED OUT BEFORE
;		THE ERROR CHARACTER IS OUTPUT. THESE CONDITIONS 
;		ARE:
;		A. THE COMPILATION IS IN STANDARD MODE (I.E. ,
;		 ONE OF MANY COMPILATIONS FROM THE SAME 
;		COMMAND STRING).
;	B. THE INPUT IS NOT ON THE TTY
;	. THE USER HAS NOT REQUESTED SUPPRESSION 
;	       OF ERRORS WITH AN N SWITCH
;	D. THE MESSAGE HAS NOT BEEN TYPED BEFORE
;ROUTINES ERROUT AND ERRMES ARE CALLED IN A MANNER SIMILAR TO
;LSTOUT AND LSTMES


ERRSP:	TDZA	%02,%02
ERRCR:	MOVEI	%02,CRR
ERROUT:	HRLM	%02,0(%17)	;SAVE VIRGIN CHARACTER
	TLNN	%16,LSTBIT_9	;IS THERE A LISTING?
	PUSHJ	%17,LSTOUT	;YES, OUTPUT THE CHAR.
	TLNE	%16,<NSWBIT!TTYBIT>_9	;CHAR TO TTY ALSO?
	POPJ	%17,		;NO, JUST EXIT
	HLRZ	%02,0(%17)	;YES, RESTORE CHARACTER
	JRST	TTYOUT		;TYPE AND EXIT
;ROUTINE HEADER DEPOSITS THE LINE FEED IN THE LISTING FILE
;BUFFER AND THEN CHECKS TO SEE IF A FORM FEED IS NECESSARY.
;IF SO, THE ACCUMULATORS ARE SAVED, THE PAGE COUNTER IS
;INCREMENTED, A FORM FEED IS ISSUED, AND A HEADER IS PRINTED.
;THE HEADER CONSISTS OF THE PROGRAM TITLE, FOUND IN THE
;TTLBUF BUFFER,  THE DATE, TIME, AND PAGE NUMBER


HEADER:	SOSLE	LINCNT		;TIME FOR A FORM FEED?
	POPJ	%17,		;NO, EXIT
HDRSET:	PUSHJ	%17,ACSAVE	;YES, SAVE THE ACCUMULATORS
HDRSE1:	PUSH	%17,%16		;SAVE CURRENT FLAGS
	TLO	%16,NSWBIT_9	;DON'T OUTPUT TO TTY
	MOVEI	%02,14		;GET A FORM FEED
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	MOVEI	%10,PAGSIZ+3	;RESET LINE COUNTER REGISTER
	MOVEM	%10,LINCNT	;...
	MOVE	%00,XE		;PICK UP A SIXBIT TITLE
	PUSHJ	%17,LSTSIX	;TYPE IT OUT
	SKIPN	%03,XE		;IS THERE A FILE NAME?
	JRST	HDRSE2		;NO,TAB
	HLLZ	%00,EXTSAV	;ISOLATE EXTENSION IN AC0
	JUMPE	%00,HDRSE2	;IF NO EXTENSION ,TAB
	HRRI	%00,"."-40	;INSERT PERIOD
	ROT	%00,-6		;MAKE PERIOD FIRST CH.
	PUSHJ	%17,LSTSIX	;LIST IT
HDRSE2:	PUSHJ	%17,LSTTAB
	MOVN	%10,PDPSWZ
	MOVE	%00,TITLE(%10)
	PUSHJ	%17,LSTSIX
	PUSHJ	%17,LSTTAB
	MOVE	%00,SUBTLE	;PRINT VERSION NO.
	PUSHJ	%17,LSTSIX
	HRRZ	%11,137		;%11_COMPILER PATCH LEVEL ;"23-AU"
	JUMPE	%11,HDRSE3	;NO OUTPUT IF 0 ;"23-AU"
	MOVSI	%00,(SIXBIT /(/) ;LIST "(" ;"23-AU"
	PUSHJ	%17,LSTSIX	;"23-AU"
	PUSHJ	%17,ERR6	;PATCH LEVEL ;"23-AU"
	MOVSI	%00,(SIXBIT /)/) ;")2 ;"23-AU"
	PUSHJ	%17,LSTSIX	;"23-AU"
HDRSE3:	LDB	%11,[POINT 3,137,2] ;%11_# OF PATCHER ;"23-AU"
	JUMPE	%11,HDRSE4	;NO OUTPUT IF 0 ;"23-AU"
	MOVSI	%00,(SIXBIT /-/) ;LIST "-" ;"23-AU"
	PUSHJ	%17,LSTSIX	;"23-AU"
	PUSHJ	%17,ERR6	;WHO ;"23-AU"
HDRSE4:	PUSHJ	%17,LSTTAB

;THE FOLLOWING SECTION PRINTS THE DATE, WHICH IS FOUND IN
;REGISTER XDATE IN THE FORM
;	((Y-1964)*12 + (M-1))*31 + (D-1)
	DATE	%10,		;GET THE DATE IN %10
	IDIVI	%10,^D31	;DIVIDE BY 31 DECIMIAL
	PUSHJ	%17,DNCP1	;OUTPUT DAY
	IDIVI	%10,^D12	;DIVIDE BY 12 DECIMAL
	MOVE	%00,MONTH(%11)
	PUSHJ	%17,LSTSIX	;OUTPUT THE MONTH, (M-1) IS IN %12
	MOVEI	%11,^D64(%10)	;GET THE YEAR
	PUSHJ	%17,DNC		;TYPE IT
	PUSHJ	%17,LSTTAB	;OUTPUT TAB
;THE FOLLOWING SECTION OF CODE PRINTS THE TIME, WHICH IS
;PICKED UP FROM THE MONITOR AS THE NUMBER OF MILLISECONDS
;SINCE MIDNIGHT. THE FORMAT OF THE TIME PRINTOUT IS HH:MM
	MSTIME	%11,		;GET THE CURRENT TIME
	IDIVI	%11,^D60*^D1000	;NUMBER OF MIN. SINCE MIDNITE
	IDIVI	%11,^D60	;NUMBER OF HOURS
	PUSH	%17,%12		;SAVE MINUTES
	PUSHJ	%17,DNC		;OUTPUT THE HOURS
	MOVEI	%02,":"		;OUTPUT A COLON AFTER THE HOURS
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	POP	%17,%11		;PUT MINUTES IN OUTPUT AC
	MOVEI	%02,"0"		;GET AN ASCII ZERO
	CAIG	%11,^D9		;IS IT A ONE-DIGIT NUMBER?
	PUSHJ	%17,LSTDMP	;YES, OUTPUT A ZERO
	PUSHJ	%17,DNC		;OUTPUT THE MINUTES


;THE FINAL SECTION OF CODING PICKS UP THE WORD "PAGE " AND
;STORES IT IN THE PROPER PLACE IN THE TITLE BUFFER.
	MOVEI	%10,[SIXBIT /[PAGE 5__]/]
	AOS	%11,PAGCNT	;INCREMENT PAGE COUNT, PICK IT UP
	PUSHJ	%17,LSTMS3	;LIST IT
	POP	%17,%16		;RESTORE FLAGS
	JRST	ACSAVE		;RESTORE F4 REGS AND EXIT
DNCP1:	ADDI	%11,1
DNC:	IDIVI	%11,^D10	;RECURSIVE SUBROUTINE
	HRLM	%12,0(%17)	;SAVE REMAINDER ON PUSHDOWN LIST
	SKIPE	%11		;ALL DONE?
	PUSHJ	%17,DNC		;NO, CALL DNC AGAIN
	HLRZ	%02,0(%17)	;RETRIEVE NUMBER FROM PD LIST
	ADDI	%02,N0		;MAKE IT SIXBIT
	JRST	ERROUT		;GET NEXT NUMBER OR EXIT

LSTSIX:	MOVSI	%06,(POINT 6,%00,)
LSTSI1:	ILDB	%02,%06
	JUMPE	%02,CPOPJ
	PUSHJ	%17,ERROUT
	TLNE	%06,770000
	JRST	LSTSI1
	POPJ	%17,

MONTH:	SIXBIT	/-JAN-/
	SIXBIT	/-FEB-/
	SIXBIT	/-MAR-/
	SIXBIT	/-APR-/
	SIXBIT	/-MAY-/
	SIXBIT	/-JUN-/
	SIXBIT	/-JUL-/
	SIXBIT	/-AUG-/
	SIXBIT	/-SEP-/
	SIXBIT	/-OCT-/
	SIXBIT	/-NOV-/
	SIXBIT	/-DEC-/
;BASIC TELTYPE OUTPUT ROUTINES
;THESE ROUTINES EXIST FOR THE USE OF THE EXEC ONLY, BUT THEIR
;CALLING SEQUENCES ARE THE SAME AS THOSE FOR LSTOUT, LSTMES,
;CONOUT, CONMES, ERROUT, AND ERRMES


TTYOUT:	ADDI	%02,40		;CONVERT TO ASCII
	CAIN	%02,"["
	MOVEI	%02,11		;TAB
	CAIE	%02,"_"
	JRST	TTYDMP		;NOT CARRIAGE RETURN
CRLF:	MOVEI	%02,15
	PUSHJ	%17,TTYDMP
	MOVEI	%02,12
TTYDMP:	SOSG	TTOCNT		;IS THE BUFFER EMPTY?
	OUTPUT	TTO,		;YES, GO EMPTY IT
	IDPB	%02,TTOPNT	;STORE THE CHARACTER
	CAIN	%02,12		;WAS IT A LINE FEED?
	OUTPUT	TTO,		;YES, OUTPUT THE LINE
	POPJ	%17,		;EXIT

TTINIT:	MOVSI	%00,(INIT CMD,)	;INITIALIZE TTY FOR INPUT, CH. 4
	MOVSI	%01,(SIXBIT /TTY/)
	MOVEI	%02,CMDBUF	;GET BUFFER HEADER ADDRESS
	AOJA	%00,INIS2	;INIT ASCII LINE MODE


TTONIT:	HLRZ	%00,JOBFFI
	HRRM	%00,JOBFF	;RESET JOBFF
	MOVSI	%00,(INIT TTO,)	;INITIALIZE TTY FOR OUTPUT, CH. 0
	MOVSI	%01,(SIXBIT /TTY/)
	MOVSI	%02,TTOBUF	;GET OUTPUT BUFFER HEADER ADDRESS
	AOJA	%00,INIS2	;INIT ASCII LINE MODE

;SUBROUTINE TO INITIALIZE A DEVICE
;	PUSHJ %17,INISET
;	 XWD BITS1,BITS2	;BITS THAT MUST BE 1 OR AN ERROR
;	RETURN

INISET:	MOVE	%03,%01		;GET DEVICE NAME
	DEVCHR	%03,
	SETCMM	%03		;COMPLEMENT BITS
	TDNE	%03,@(%17)	;WERE ALL THE BITS 1?
	JRST	ERRNIT		;NO
	AOS	(%17)		;YES, SKIP RETURN
INIS2:	MOVE	%03,[JRST ERRNA];ERROR EXIT FOR INIT
	MOVSI	%04,(POPJ %17,)
	JRST	%00
;ROUTINE TO INPUT CHARACTERS FROM THE SOURCE DEVICE
;ROUTINE CHAR INPUTS CHARACTERS ON CHANNEL 3 UNTIL AN END OF
;FILE CONDITION IS MET. IT THEN CHECKS A FLAG TO SEE IF ANY 
;MORE INPUT FILES NEED TO BE INITIALIZED. IF SO, IT RELEASES
;THE OLD INPUT FILE AND INITIALIZES A NEW ONE, AND CONTINUES 
;TO DO INPUT ON THIS FILE.
;WHEN THE LAST END OF FILE IS REACHED, THE EXEC PLACES AN
;S2 CHARACTER AND A CARRIAGE RETURN IN THE BUFFER
CHARB:	MOVEM	%14,@SEQPNT	;STORE SEQNUM W/ BIT 35 0 ;"21A"
	AOS	SRCPNT		;INCREMENT POINTER PAST WORD
	MOVNI	%14,5		;GET -5
	ADDM	%14,SRCCNT	;SUBTRACT 5 FROM WORD COUNT
	SOSLE	SRCCNT		;WAS THE SEQ NO LAST WD IN BUFFER ?
	JRST	CHAR+2		;NO, CONTINUE
	PUSHJ	%17,CHAR4	;YES, GET A NEW BUFFER
	IBP	SRCPNT		;SKIP SPACE/TAB FROM SEQ NO
CHAR:	SOSG	SRCCNT		;DECREMENT ITEM COUNT
	PUSHJ	%17,CHAR4	;GET ANOTHER BUFFER IF NECESSARY
	IBP	SRCPNT		;INCREMENT THE BYTE POINTER
	MOVE	%14,@SRCPNT	;PICK UP AN ENTIRE WORD FROM BUFFER
	TRZE	%14,1		;IS THE SEQUENCE NUMBER BIT ON?
	JRST	CHARB		;YES, SKIP AROUND IT
	LDB	%14,SRCPNT	;NO, PICK UP A GOOD CHARACTER
	JUMPE	%14,CHAR	;FILTER OUT NULLS
	CAILE	%14,"_"		;UPPER CASE ?	;"21C"
	TRZ	%14,40		;YES, CHANGE TO LOWER CASE	;"21C"
	CAIL	%14," "		;IF LESS THAN SPACE
	CAILE	%14,"Z"		;OR GREATER THAN Z
	JRST	CHAR3		;DO SOME MORE EDITING
CHAR1:	HRRZ	%14,CSTATI(%14)	;OK, CONVERT TO SIXBIT
	POPJ	%17,		;EXIT

CHAR3:	CAIN	%14,32		;CONTROL Z?
	JRST	CHAR		;YES, FORGET IT
	CAIL	%14,11		;IF LESS THAN TAB
	CAILE	%14,15		;OR GREATER THAN CARRIAGE RETURN
	SKIPA	%14,CHTAB+2	;FORCE ERROR
	XCT	CHTAB-11(%14)	;EXECUTE TABLE
	JRST	CHAR1		;SET TO SIXBIT AND EXIT

CHTAB:	MOVEI	%14,"["		;TAB
	MOVEI	%14,"_"		;LINE FEED
	MOVEI	%14,"^"		;ERROR
	JRST	CHARFF		;FORM FEED	;"21A"
	JRST	CHAR		;CARRIAGE RETURN

CHARFF:	MOVEI	%14,1		;GET FORM FEED BIT	;"21A"
	ORM	%14,@SEQPNT	;SAVE IN SEQUENCE NUMBER BIT 35	;"21A"
	JRST	CHAR		;AND RETURN, IGNORING THE FORM FEED	;"21A"
CHAR4:	TRZE	%16,EOFBIT	;EOF IN PROGRESS?
	JRST	CHAR5		;YES
	INPUT	SRC,		;CALL MONITIOR FOR A BUFFER
	STATZ	SRC, IODATA+IODEV+IOBKTL
	JRST	ERRID		;INPUT TRANSMISSION ERROR
	STATO	SRC, IOEOF	;WAS AN END OF FILE REACHED?
	POPJ	%17,		;GET NEXT CHAR
	TRNN	%16,ENDBIT!STNBIT	;SHOULD WE IGNORE?
	TROA	%16,EOFBIT	;YES
	HLLZM	%17,@SEQPNT		;NO, SET FLAG
	POP	%17,%14		;PRUNE PDP
	MOVEI	%14,CRR		;RETURN CR
	POPJ	%17,		;RETURN IT

CHAR5:	PUSHJ	%17,ACSAVE
	CLOSE	SRC,		;NO, CLOSE THIS DEVICE
	HRRZ	%05, JOBFFI	;RESTORE OLD BUFFER SPACE
	MOVEM	%05, JOBFF	;...
	PUSHJ	%17, GETSRC	;GET NEXT SOURCE DEVICE
	LDB	%00,[POINT 9,%16,17]	;TRANSFER FLAGS TO ACTIVE
	DPB	%00,[POINT 9,%16, 8]
	TLNN	%16,LSTFLG
	JRST	HDRSE1

;ROUTINES TO SAVE AND RESTORE THE COMPILER ACCUMULATORS
ACSAVE:				;SWAP AC'S
	EXCH	%00,AC00
	EXCH	%01,AC01
	EXCH	%02,AC02
	EXCH	%03,AC03
	EXCH	%04,AC04
	EXCH	%05,AC05
	EXCH	%06,AC06
	EXCH	%07,AC07
	EXCH	%10,AC10
	EXCH	%11,AC11
	EXCH	%12,AC12
	EXCH	%13,AC13
	EXCH	%14,AC14
	POPJ	%17,
;ROUTINE TO OUTPUT RELOCATABLE BINARY


BINOUT:	SOSG	BINCNT
	PUSHJ	%17,BINDMP
	IDPB	%00,BINPNT
	POPJ	%17,

BINDMP:	OUTPUT	BIN,
BINTST:	STATO	BIN,IODATA!IODEV!IOWRLK
	POPJ	%17,
	JSP	%10,ERROR
	SIXBIT /BINARY OUTPUT ERROR]/


;CALLS TO THE EXEC FOR MORE CORE


;PANIC HAS THE FOLLOWING CALLING SEQUENCE
;	PUSHJ	%17,PANIC	
;	RETURN 1		;NO MORE CORE
;	RETURN 2		;MORE CORE
;THE EXEC CALL THE TIME-SHARING MONITOR FOR MORE
; CORE BY LOADING AC %10 ,WHICH IS USED AS A SCRATCH AC, WITH 
; THE HIGHEST DESIRED RELATIVE ADDRESS,I.E.;%13(JOBREL)+2000,AND
; THEN EXECUTING A CALL %10,CORE. IF UNCUCCESSFUL, THE ROUTINE
; EXITS TO RETURN 1 ABOVE.
;IF SUCCESSFUL, THE MONITOR WILL UPDATE JOBREL IN THE JOB
;DATA AREA. THE EXEC THEN UPDATES THE LEFT HALT OF ROLMEM
;SO THAT THE COMPILER CAN MOVE ITS TABLES HIGHER IN CORE.


PANIC:	HRRZ	%10,JOBREL	;GET PRESENT ROLMEM
	ADDI	%10,2000	;ADD 1K OF CORE TO IT
	CORE	%10,		;ASK FOR MORE CORE
	JRST	ERRNC		;NO MORE CORE AVAILABLE
	POPJ	%17,
ERRCMD:	JSP	%10,ERROR
	SIXBIT /DEVICE INPUT ERROR FOR COMMAND STRING]/
IFN	CCLSW,
<
ERRCF1:	SETZM	CCLFLA		;LOOKUP FOR DSK:###FOR.TMP FAILED
>				;EVENTUALLY GO TO F4EXEC
ERRCF:	JSP	%10,ERROR
	SIXBIT /CANNOT FIND 234]/

ERRID:	JSP	%10,ERROR
	SIXBIT /INPUT DATA ERROR 234]/

ERRBS:	JSP	%10,ERROR
	SIXBIT /1 IS A BAD SWITCH]/

ERRIC:	JSP	%10,ERROR
	SIXBIT /1 IS AN ILLEGAL CHARACTER]/

ERRNA:	JSP	%10,ERROR
	SIXBIT /2 IS NOT AVAILABLE]/

ERRNR:	JSP	%10,ERROR
	SIXBIT #NO FILE NAMED OR NO ROOM FOR 234]#

ERRSE:	JSP	%10,ERROR
	SIXBIT /SYNTAX ERROR IN COMMAND STRING]/

ERRNC:	JSP	%10,ERROR
	SIXBIT /INSUFFICIENT CORE_COMPILATION TERMINATED]/

ERRLA:	JSP	%10,ERROR
	SIXBIT /1 SWITCH ILLEGAL AFTER LEFT ARROW]/

ERRSF:	JSP	%10,ERROR
	SIXBIT /1 SWITCH ILLEGAL AFTER FIRST STANDARD FILE]/

ERRCSW:	JSP	%10,ERROR
	SIXBIT /1 SWITCH , NO LISTING FILE]/

ERRNIT:	JSP	%10,ERROR
	SIXBIT /IMPROPER IO FOR DEVICE 2]/
ERROR:	MOVE	%16,[XWD <LSTBIT!BINBIT>_9,ENDBIT]
	MOVEM	%01,XE2		;SAVE DEVICE NAME
	PUSHJ	%17,TTONIT	;INIT TTY FOR MESSAGE
	PUSHJ	%17,LSTMSG
	JRST	EXIT

LSTMSG:	MOVSI	%00,(SIXBIT /_?/)
	PUSHJ	%17,LSTSIX	;TYPE CR,"?"
	PUSHJ	%17,ERRSP	;TYPE SPACE
LSTMS3:	HRLI	%10,(POINT 6,,)	;SET BYTE POINTER AND SKIP
	CAIA
LSTMS4:	PUSHJ	%17,ERROUT	;TYPE CHARACTER
LSTMS5:	ILDB	%02,%10		;GET CHARACTER
	CAIN	%02,"]"-40	;TEST FOR END
	JRST	ERRCR		;END, TYPE CR
	CAIL	%02,"1"-40	;TEST FOR SWITCH
	CAILE	%02,"6"-40	;"23J"
	JRST	LSTMS4		;NO, TYPE THE CHARACTER
	HRRZ	%02,ERRXCT-<"1"-40>(%02)
	PUSHJ	%17,0(%02)	;GO TO PROPER ROUTINE
	JRST	LSTMS5		;GET NEXT CHARACTER

ERR1:	MOVE	%02,%05		;GET IMPROPER CHARACTER
	JRST	TTYDMP		;DUMP IT

ERR2:	MOVE	%00,XE2		;GET DEVICE NAME
	PUSHJ	%17,LSTSIX	;TYPE IT
	MOVEI	%02,":"
	JRST	TTYDMP		;TYPE ":"

ERR3:	MOVE	%00,XE		;GET FILE NAME
	JRST	LSTSIX		;TYPE IT

ERR4:	HLLZ	%00,XE1		;GET EXTENSION
	JUMPE	%00,CPOPJ	;EXIT IF NULL
	MOVEI	%02,"."
	PUSHJ	%17,TTYDMP	;TYPE "."
	JRST	LSTSIX

ERR6:	IDIVI	%11,^D8		;SEPERATE OCTAL DIGITS	;"23J"
	HRLM	%12,0(%17)	;SAVE THEM ON PDL	;"23J"
	SKIPE	%11		;MORE DIGITS ?	;"23J"
	PUSHJ	%17,ERR6	;YES, EXTRACT THEM	;"23J"
	HLRZ	%02,0(%17)	;GET OCTAL DIGIT FROM PDL	;"23J"
	MOVEI	%02,N0(%02)	;CONVERT TO SIXBIT	;"23J"
	JRST	ERROUT		;AND PRINT THEM	;"23J"
EXIT:	CLOSE	SRC,		;CLOSE THE SOURCE DEVICE
	CLOSE	LST,		;CLOSE THE LISTING FILE
	CLOSE	BIN,		;CLOSE THE BINARY FILE
	TLNN	%16,LSTBIT_9	;WAS THERE A LISTING FILE?
	PUSHJ	%17,LSTTST	;YES, TEST FOR FINAL ERROR
	TLNN	%16,BINBIT_9	;IS THERE A BINARY FILE?
	PUSHJ	%17,BINTST	;YES, TEST FOR FINAL ERROR
	TRNN	%16,ENDBIT!NORBIT;MORE COMMAND STRING TO PROCESS?
	JRST	RSTRT2		;YES, GET SOME MORE STANDARD FILES
	CLOSE	TTO,		;BE SURE MESSAGES ARE COMPLETE
IFN CCLSW,
<	SKIPN	CCLFLA		;SKIP FOR CCL STUFF
>
	JRST	F4EXEC		;GET A NEW COMMAND STRING
IFN CCLSW,
<	RELEAS	LST,0
	RELEAS	BIN,0
	RELEAS	SRC,0
	RELEAS	TTO,0
	HLRZ	%00,JOBFFI	;RESTORE DATA AREA 
	MOVEM	%00,JOBFF	;TO JOBFF
EXIT6:	PUSHJ	%17,GETCMD	;GET NEXT COMMAND CHARACTER
	CAIL	%05,12		;BETWEEN LINE-FEED AND
	CAILE	%05,15		;CARRIAGE RETURN- INCLUSIVE?
	CAIA			;NO
	JRST	EXIT6		;YES, THROW AWAY
	MOVSI	%05,070000	;GET BYTE POSITION INCREMENT
	ADDM	%05,CMDPNT	;BACK UP BYTE POINTER 1 BYTE
	AOS	CMDCNT		;INCREMENT THE BYTE COUNT AGAIN
	JRST	NXTCCL		;GO DO NEXT COMMAMD
>
	END	F4EXEC			;....F4EXEC



