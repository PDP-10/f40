




F40.DOC -- CHANGES FROM VERSION 24 TO 25

JANUARY, 1972





COPYRIGHT 1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS;











1.0 SUMMARY


     The principle reason for this release is to fix certain

bugs in version 24 of the FORTRAN compiler which caused that

version to be unuseable and  unreliable.   The  bug  patches

were made principally to the DO loop code generators and the

subprogram linkage code generators.


     This version supercedes all previous versions  and  has

deficiencies  as  outlined  in section 3.  This version will

run with all versions of the monitor after 4S72.


F40.DOC -- changes from version 24 to 25            PAGE   2



2.0 External changes


     There are no external changes between version 24 and 25

except  the  aforementioned patches.  these will, of course,

cause correct code to be generated where before the code was

wrong for do loops and subprogram linkages.


     Appended this file is the DOC file for  Version  24  of

the FORTRAN compiler.  The deficiencies outlined for version

24 also apply to version 25.


F40.DOC -- changes from version 24 to 25            PAGE   3



3.0 Known problems in Version 25



SPR# TYPE

2511            Complex implied DO                             (6)



3049            Same as 2511                                   (5)



3371            Same as 3049                                   (4)



3639            Mixed mode expression involving COMPLEX        (5)



3782            Input/Output list doesn't update subscript     (2)



3956            Result of FLOAT ignored



4206            Same as 3639                                   (4)



4229            .NOT.  of an expression doesn't work           (2)



4293            Same as 4206                                   (3)



4452            Same as 3371                                   (3)



4449            IDIV doesn't save AC+1



4532            Same as 4293                                   (2)


F40.DOC -- changes from version 24 to 25            PAGE   4



4540            Same as 4532                                   (1)



4630            Same as 4229                                   (1)



4648            Mixed mode expression uses wrong type



4725            Same as 4452                                   (2)



4980            Common  subexpressions  in   relational   expression

generates bad code



4822            Same as 3782                                   (1)



4989            INTEGER  or  REAL  bases  to  double   word   powers

generates bad code



5075            same as 4725                                   (1)


F40.DOC -- changes from version 24 to 25            PAGE   5



OTHER DEFICIENCIES



The compiler does not preserve indirect command files



No error is detected when nested do loops use the same index

variable



The compiler does not detect illegal transfer into the range

of a do loop



The compiler does not allow the end= or err= exits in a READ

or WRITE statement to reference the same statement.



The  compiler  does  not  always  collapse  octal   constant

arithmetic correctly.



The compiler does not generate  code  to  materialize  a  DO

index variable on exit from a loop caused by end= or err= in

an I/O statement.


F40.DOC -- changes from version 24 to 25            PAGE   6



	
	
	
	
	
	
	
	FORTRAN COMPILER VERSION 24

		2-JUL-71
	









	THE  INFORMATION IN  THIS DOCUMENT IS SUBJECT TO
	CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
	AS A COMMITMENT BY DIGITAL EQUIPEMENT CORPORATION.


	COPYRIGHT 1971 DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.
							PAGE 2
CCO
23.1)	PATCH 23A MAKES THE USE OF A FUNCTION NAME WHICH WAS PREVIOUSLY
	DECLARED A SCALAR IN A COMMON STATEMENT A FATAL ERROR RATHER
	THAN CAUSE AN "ILL MEM REF" FROM THE COMPILER. WHEN THE ERROR 
	OCCURS THE DIAGNOSTIC "I-16 A CONFLICT EXISTS WITH A COMMON DEC-
	LARATION" WILL BE OUTPUT. SUPERFLOUS JUMPS TO LOCATION FAIL
	WHICH WERE NOTICED WHILE MAKING THIS PATCH WERE REMOVED. THIS
	PROBLEM WAS REPORTED BY SOFTWARE PERFORMANCE REPORT NO. 10-2991.

23.2)	PATCH 23B REMOVES THE ASSEMBLY ERRORS FROM THE SMALL COMPILER.
	LOAD /M FX0.23+FX1.23+FX2.23+FX3.23+FX4.23

23.3)	PATCH 23C REMOVES THE COMPILER CODE FOR THE OLD REGISTER SAVE
	AND RESTORE ROUTINES WHICH WERE INVOKED DURING GENERATION OF
	SUBPROGRAM PROLOG AND EPILOG CODE.

23.4)	PATCH 23D FIXES THE PROBLEM OF AN EXTRA LISTING PAGE BEING
	GENERATED ON MACRO EXPANSION LISTINGS OF PROGRAMS WHOSE FIRST
	STATEMENT HAS A STATEMENT LABEL. THIS PROBLEM WAS  REPORTED BY
	SOFTWARE PERFORMANCE REPORT NUMBER 10-3009 .

23.5)	PATCH 23E CAUSES THE COMPILER TO IGNORE INPUT LINES CONSISTING
	OF 80 BLANKS FOLLOWED BY CARRIAGE RETURN, LINE FEED (A BLANK
	CARD). THIS PROBLEM WAS REPORTED BY SOFTWARE PERFORMANCE REPORT
	NUMBER 10-3012.

23.6)	PATCH 23F FIXES THE PROBLEM WITH OCTAL CONSTANTS CAUSED BY A
	CHANGE TO THE MACRO-10 ASSEMBLER.

23.7)	PATCH 23G ALLOWS SOME TRIVIAL COMPATIBILITIES WITH IBM AND OTHER
	FORTRANS:
	CALL SUB (*10) = CALL SUB (&10)
	READ (1#2) = READ (1'2)
	ALSO THE FOLLOWING EQUIVALENT TYPES MAY BE USED IN IMPLICIT,
	FUNCTION, AND TYPE SPECIFICATION STATEMENTS:
	SUBSCRIPT INTEGER = INTEGER*2
	INTEGER = INTEGER*4
	REAL = REAL*4
	LOGICAL = LOGICAL*1 = LOGICAL*4
	DOUBLE PRECISION = REAL*8
	COMPLEX = COMPLEX*8

23.8)	PATCH 23H CAUSES THE COMPILER TO TREAT A TAB CHARACTER IN COLUMNS
	2 THRU 6 OF A COMMENT STATEMENT PROPERLY. THIS PROBLEM WAS REPORTED
	BY SOFTWARE PERFORMANCE REPORT NUMBER 10-1510.

23.9)	PATCH 23I CAUSES THE COMPILER TO LOOK FOR A FIELD WIDTH FOLLOWING
	AN "L" FORMAT FIELD SPECIFICATION. THIS PATCH WAS SUGGESTED BY
	SOFTWARE TROUBLE REPORT NUMBER 10-2695.

							PAGE 3
CCO
23.10)	PATCH 23J CAUSES THE COMPILER TO PRODUCE A FATAL ERROR RATHER
	THAN THE MONITOR ERROR "PDL OV". THE ERROR MESSAGE PRODUCED IS
	"M-8 SYSTEM ERROR - NO MORE SPACE FOR RECURSIVE STORAGE". IF THE
	WORK STACK ( THE PUSHDOWN LIST POINTED TO BY ACCUMULATOR 17 ) HAS
	OVERFLOWED OR AN ILLEGAL MEMORY REFERENCE HAS OCCURED THERE IS
	NO WAY TO CONTINUE COMPILATION SO AN APPROPRIATE MESSAGE IS
	PRODUCED, THE CURRENT OUTPUT FILES ARE CLOSED AND THE COMPILER
	CONTINUES WITH THE NEXT SOURCE FILE IN THE COMMAND STRING. THE
	ERROR MESSAGE PRODUCED WHEN THE WORK STACK OVERFLOWS IS:
	"WORK STACK OVERFLOW AT N
	COMPILATION TERMINATED" WHILE THE ERROR MESSAGE PRODUCED WHEN
	AN ILLEGAL MEMORY REFERENCE OCCURS IS:
	"ILLEGAL MEMORY REFERENCE AT N
	COMPILATION TERMINATED". THE "N" IN THESE ERROR MESSAGES IS THE
	OCTAL LOCATION AT WHICH THE ERROR OCCURED. THIS PROBLEM WAS REPORTED
	BY SOFTWARE TROUBLE REPORT NUMBER 10-1946.

23.11)	PATCH 23K MAKES ERRORS DUE TO MISMATCHING OF VARIABLES AND
	DATA IN A DATA STATEMENT MORE HELPFUL. THE ERROR MESSAGE
	"M-11 MORE DATA NEEDED - LITERAL TOO SHORT OR TYPE CONVERSION
	EXPECTED" IS PRODUCED WHEN THE DATA CONSTANTS HAVE BEEN COMPLETELY
	SCANED AND THE NUMBER OF WORDS SPECIFIED BY THE DATA LIST
	IS GREATER THAN THE NUMBER OF WORDS DEFINED BY THE DATA CONSTANTS.
	THE ERROR MESSAGE "M-9 TOO MUCH DATA - WRONG ARRAY SIZE OR LITERAL
	TOO LONG" IS PRODUCED WHEN THE OPPOSITE RELATIONSHIP IS TRUE.

23.12)	PATCH 23L ALLOWS THE COMPILER TO DETECT NON-NUMERIC CHARACTERS
	IN THE STATEMENT LABEL FIELD. WHEN THIS ERROR IS DETECTED THE
	MESSAGE "S-8 ILLEGAL CHARACTER IN LABEL" IS PRODUCED. THE ERROR
	MESSAGES "LABEL" AND "ERRORS" WHICH ARE NO LONGER USED WERE DELETED.
	THIS PROBLEM WAS REPORTED BY SOFTWARE TROUBLE REPORT NUMBER 10-2978.

23.13)	PATCH 23M COMBINES AND EXPANDS THE TWO ERROR MESSAGES "S-10
	ILLEGAL CHARACTER - LINE DELIMITER EXPECTED" AND "S-16 ILLEGAL
	CHARACTER DETECTED - DELIMITER EXPECTED". THE NEW ERROR MESSAGES
	ARE: "S-9 MISSING COMMA OR SLASH IN SPECIFICATION STATEMENT" ,
	"S-10 ILLEGAL ARITHMETIC "IF" - THREE STATEMENT LABELS ONLY",
	"S-16 MULTIPLE RETURN ILLEGAL WITHOUT STATEMENT LABEL ARG",
	"S-20 ILLEGAL DEFINITION OF AN ARITHMETIC STATEMENT FUNCTION",
	"S-21 MISSING COMMA IN INPUT/OUTPUT LIST", AND "S-22 STATEMENT
	CONTINUES PAST RECOGNIZED END POINT". A SIMPLIFICATION OF THE
	CODE NECESSARY TO ALLOW SPECIFICATION STATEMENTS TO APPEAR
	ANYWHERE IN THE FORTRAN PROGRAM WAS NOTICED WHILE MAKING THE
	ABOVE CHANGES AND INSERTED.

23.14)	PATCH 23N EXPANDS THE ERROR MESSAGE "S-1 SYNTAX" BY CHANGING
	THE S-1 ERROR MESSAGE AS WELL AS THE S-2 AND S-12 ERROR MESSAGES
	WHICH WERE NOT USED BY VERSION 23. THE NEW ERROR MESSAGES ARE :
	"S-1 ILLEGAL NAME OR DELIMITER OR KEY CHARACTER","S-2 STATEMENT
	KEYWORD NOT RECOGNIZED","S-12 IMPLICIT TYPE RANGE OVERLAPS PREVIOUS
	SPECIFICATION", AND "S-23 ILLEGAL COMPLEX CONSTANT". THE ERROR
	MESSAGE "O-4 EXECUTABLE STATEMENTS ILLEGAL IN BLOCK DATA" ALSO
	WAS INTRODUCED.
							PAGE 4
CCO
23.15)	PATCH 23O ALLOWS THE USER TO ASSEMBLE THE COMPILER WITH ERROR
	MESSAGES CONSISTING OF THE ALPHABETIC AND NUMERIC QUALIFIER
	ONLY; I.E. "M-3 CONSTANT OVERFLOW" BECOMES "M-3". SINCE THE
	AVERAGE ERROR MESSAGE IS 8 WORDS LONG THIS WILL SAVE OVER 400
	WORDS OF CORE. DEFINING THE PARAMETER "ERRCO" WILL CAUSE THIS TO
	HAPPEN.

23.16)	PATCH 23P ALLOWS A PROGRAMMER TO END A MAIN PROGRAM WITH THE
	STATEMENTS:

	STOP
	END

	OR

	RETURN
	END

	AND A SUBPROGRAM WITH THE STATEMENTS:

	RETURN
	END

	WITHOUT GENERATING DUPLICATE CODE.

23.17)	PATCH 22P HAS BEEN CHANGED TO ALLOW FOR DOUBLE PRECISION AND 
	COMPLEX ARRAY NAME OR SUBPROGRAM NAME ARGUMENTS WHEN RESTORING
	DEFINED ARGUMENTS.

23.18)	PATCH 23Q CAUSES THE LETTER D TO BE A COMMENT CHARACTER UNLESS
	AN I (FOR INCLUDE) SWITCH APPEARS IN THE COMMAND STRING. WHEN THE
	I SWITCH APPEARS IN THE COMMAND STRING ( COMPILE /LIST FILE(I))
	ALL LINES WITH A D IN COLUMN 1 WILL BE COMPILED AND LISTED AS IF
	THE D HAD BEEN A SPACE. THIS MEANS THAT THE VALUE OF VARIABLES
	MAY BE PRINTED, CALLS TO DUMP OR PDUMP INSERTED, IF STATEMENTS
	USED TO CHECK RANGES, ETC. SIMPLY BY WRITING THE STATEMENTS WITH
	A D IN COLUMN 1. THIS SHOULD PROVE USEFUL FOR DEBUGGING PURPOSES.
	DUE TO LACK OF ADDITIONAL SPACE THE /I SWITCH HAS REPLACED THE
	/D SWITCH. TRUNCATED ERROR MESSAGES MAY STILL BE PRODUCED HOWEVER
	(SEE CCO 23.15).

23.19)	PATCH 23R CAUSES THE COMPILER TO MAKE AN EXTRA CHECK ON A 
	SUBSCRIPT WHICH HAS BEEN PREVIOUSLY LOADED INTO AN ACCUMULATOR
	TO CHECK WHETHER THE SUBSCRIPT IS STILL THERE.

23.20)	PATCH 23S ENABLES THE COMPILER TO GENERATE THE FINAL AND
	INCREMENT PARAMETERS OF A DO LOOP PRIOR TO ENTERING THE DO.
	THIS SHOULD SPEED UP CERTAIN TYPES OF DO LOOPS AND ELIMINATE
	THE OCCURANCE OF AN "M-17 SYSTEM ERROR - ROLL OUT OF RANGE"
	AT THE END STATEMENT OF A DO WHICH USES A FUNCTION CALL AS THE
	FINAL AND /OR INCREMENT OF THE DO.
							PAGE 5
CCO
23.21)	PATCH 23T FIXES THE PROBLEM OF DOUBLE PRECISION TO INTEGER
	CONVERSION NOT GIVING ALL AVAILABLE ACCURACY.

23.22)	PATCH 23U FIXES THE PROBLEM OF UNARY MINUS BEING IGNORED OR
	GIVEN THE WRONG PRECEDENCE.

23.23)	PATCH 23V FIXES THE PROBLEM OF MIXED MODE EXPRESSIONS NOT
	COMPILING AS PER TABLE 2-1, FORTRAN IV PROGRAMMERS REFERENCE
	MANUAL.

23.24)	PATCH 23W REMOVES THE ERROR WHICH OCCURED WHEN THE INDEX OF AN
	ARRAY BEING DEFINED BY DATA STATEMENT HAS BEEN PREVIOUSLY
	DEFINED IN A DATA OR ASSIGNMENT STATEMENT.

23.25)	PATCH 23X FIXES THE PROBLEM OF A DATA STATEMENT WITH A NEGATIVE
	CONSTANT CAUSING A SUBSEQUENT POSITIVE OCTAL CONSTANT TO BE
	GENERATED AS IF NEGATIVE.

23.26)	PATCH 23Y FIXES THE PROBLEM OF A DOUBLE WORD ASSIGNMENT OF AN
	OCTAL CONSTANT OR LOGICAL EXPRESSION NOT ZEROING THE LOW
	ORDER WORD.

23.27)	PATCH 23Z FIXES THE PROBLEM OF THE SECOND APPEARANCE OF A
	HOLLERITH CONSTANT WHICH DIFFERS FROM THE FIRST APPEARANCE
	AFTER THE 5TH CHARACTER CAUSING GARBAGE TO BE GENERATED.

23.28)	PATCH 23AA FIXES THE PROBLEM OF THE LOW PART OF THE VALUE OF A
	DOUBLE PRECISION FUNCTION BEING LOST WHEN ASSIGNED TO AN ARRAY
	ELEMENT WITH A FUNCTION IN THE SUBSCRIPT.

23.29)	PATCH 23AB CHANGES IMPLICIT CALLS TO SNGL TO THE MUCH FASTER 
	IN LINE CODE: FADR HIAC,LOAC .


23.30)	PATCH 23AC SPEEDS UP THE ROLL SEARCH ALGORITHM AND ALLOCATES
	MORE THAN THE MINIMUM AMOUNT OF SPACE FOR EACH ROLL WHEN
	REQUIRED.

23.31)	PATCH 23AD CAUSES THE PROPER ERROR MESSAGE TO BE LISTED WHEN
	A DATA STATEMENT PRODUCES AN M-11 OR M-9 ERROR.

23.32)	PATCH 23AE ALLOWS STATEMENTS ASSIGNING THE VALUE ZERO TO A
	DOUBLE PRECISION VARIABLE TO GENERATE 2 SETZM'S INSTEAD OF
	4 INSTRUCTIONS WHEN THE VALUE ZERO IS EXPRESSED AS AN INTEGER
	,REAL, OR DOUBLE PRECISION CONSTANT.

23.33)	PATCH 23AF CAUSES CODE TO BE GENERATED FOR ASSIGNED GO TO'S
	WITH LABEL LISTS TO CHECK WHETHER THE ASSOCIATED LABEL IS ONE
	OF THOSE IN THE LIST AND IF NOT TO FALL THRU TO THE NEXT EXECUTABLE
	STATEMENT.
							PAGE 6
CCO
23.34)	PATCH 23AG CAUSES THE COMPILER TO CHECK THE TYPE OF ARGUMENTS
	TO LIBRARY FUNCTIONS AND INSURE THAT THE MINIMUM NUMBER OF
	ARGUMENTS ARE PRESENT.

23.35)	PATCH 23AH ALLOWS THE COMPILER TO ACCEPT ARITHMETIC IF
	STATEMENTS WITH TWO LABELS. CONTROL PASSES TO THE STATEMENT
	IDENTIFIED BY THE FIRST LABEL IF THE EXPRESSION IS NEGATIVE
	(.TRUE.) OR TO THE SECOND LABEL IF THE EXPRESSION IS
	POSITIVE (.FALSE.). A SWITCH IF STATEMENT SUCH AS

	IF(A)1,2

	IS EQUIVALENT TO THE ARITHMETIC IF STATEMENT

	IF(A)1,2,2

23.36)	PATCH 23AI INSURES THAT THE TYPE OF A LIBRARY FUNCTION OVERRIDES
	ANY IMPLICIT TYPE SET BY THE CALLING PROGRAM.

23.37)	PATCH 23AJ INSURES THAT SPECIAL CASE ASSIGNMENTS SUCH AS

	R=R+D
	R=R-D
	R=R*D

	(WHERE D IS DOUBLE PRECISION AND MAY BE AN EXPRESSION AND R IS
	REAL) WILL GENERATE THE PROPER TYPE CONVERSION.

23.38)	PATCH 23-AK PREVENTS THE COMPILER FROM USING ACCUMULATORS OTHER
	THAN 0, 2, 4, OR 6 FOR THE HIGH ORDER OR REAL PART OF A DOUBLE
	WORD QUANTITY. THUS CALLS TO NONEXISTANT ENTRY POINTS OF THE
	DOUBLE PRECISION OR COMPLEX ARITHMETIC ROUTINES WILL NOT BE
	GENERATED.

23.39)	PATCH 23-AL WILL CAUSE A DUMMY ARGUMENT USED AS THE ADDRESS OF
	THE ASCII RECORD IN AN ENCODE STATEMENT TO BE RESTORED WHEN
	LEAVING THE SUBPROGRAM.

23.40)	PATCH 23-AM INSURES THAT THE COMPILER WILL GENERATE AN EXPONENT
	OF THE PROPER TYPE REQUIRED BY THE EXPONENTIATING SUBPROGRAM
	USED.

23.41)	PATCH 23-AN FIXES PROBLEMS CAUSED BY THE COMPILER'S OPTIMIZATION
	OF EXPRESSIONS INVOLVING EXPONENTIATION. THE PROBLEM OCCURS
	WHEN THE BASE IS A NEGATIVE EXPRESSION AND THE POWER IS AN ODD
	INTEGER. THE COMPILER HAD BEEN GENERATING AN EXTRA MOVNS
	INSTRUCTION WHICH THIS PATCH ELIMINATES. SEE SPR 10-2633.
							PAGE 7
CCO
23.42)	PATCH 23-AO CAUSES THE COMPILER TO MAKE A SPECIAL CHECK FOR
	A STATEMENT FUNCTION RECURSIVLY CALLING ITSELF. THIS CONDITION
	WILL PRODUCE THE ERROR "M-20 ILLEGAL RECURSIVE CALL".

23.43)	PATCH 23-AP REMOVES FROM THE COMPILER THE ABILITY TO GENERATE
	A LOGICAL RATHER THAN AN ARITHMETIC SHIFT WHEN MULTIPLYING
	OR DIVIDING BY AN OCTAL POWER OF 2.

23.44)	PATCH 23-AQ INSURES THAT THE COMPILER WILL RECOGNIZE AS COMPLEX
	A VALUE CONVERTED TO COMPLEX AND STORED IN TEMP.

23.45)	PATCH 23-AR CAUSES THE MESSAGE "M-19 ILLEGAL USE OF STATEMENT
	LABEL" TO BE PRODUCED WHENEVER THE LABEL OF A STATEMENT IS
	USED WITHIN THE STATEMENT. "1  GO TO 1" FOR EXAMPLE.

23.46)	PATCH 23-AS INSURES THAT REGISTERS 0 & 1 ARE AVAILABLE WHEN
	"D**2" OR "C**2" IS GENERATED AS "D*D" OR "C*C" WHERE D IS
	DOUBLE PRECISION AND C IS COMPLEX.

23.47)	PATCH 23-AT INSURES THAT THE DO INDEX REGISTER (AC15) IF USED AS
	A SUBSCRIPT WILL BE LOADED INTO ANOTHER REGISTER BEFORE BEING
	USED AS A SUBSCRIPT.

23.48)	PATCH 23-AU IMPLEMENTS THE NEW VERSION NUMBER FORMAT WHICH
	DEFINES LOCATION 137 AS:

	JOBVER=	137
	JOBVER:	BYTE (3) WHO=DEC=0 (9) VERSION (6) UPDATE (18) EDIT

	AND PRINTS IN THE LISTING HEADER AS:

	VERSION'UPDATE(EDIT)-WHO

	WHERE "WHO" AND "EDIT" PRINT ONLY IF NON-ZERO.
							PAGE 8
KNOWN PROBLEMS

1)	STATEMENTS OF THE FORM

	READ 10,N,A(N),B(N),N,A(N),N,B(N)

	GENERATE CODE WHICH USES THE FIRST VALUE OF N FOR ALL
	SUBSCRIPTS.

	THE EQUIVALENT STATEMENT

	EQUIVALENCE (N,N1,N2)
	READ 10,N1,A(N1),B(N1),N2,A(N2),N,B(N)

	WILL WORK PROPERLY.

2)	IN STATEMENTS SUCH AS

	DIMENSION IDX(5,7,11),QX(5,7,13)
	TYPE 1,(IDX(3,I,K),K=1,3),QX(2,I,1),(IDX(3,I,K),K=1,3)
       &,(IDX(3,I,K),K=1,3)

	THE COMPILER DESTROYS ACCUMULATORS CONTAINING INTERMEDIATE
	SUBSCRIPTS. THEN LATER USES THEM AS IF THEY WERE INTACT DURING
	COMPILATION OF LENGTHY I/O STATEMENTS IN WHICH A SUBSCRIPT
	CALCULATION FROM A PREVIOUS IMPLIED DO SHOULD BE USEABLE IN
	THE FOLLOWING IMPLIED DO.

	THE ABOVE EXAMPLE WOULD WORK PROPERLY IF CHANGED AS FOLLOWS:

	DIMENSION IDX(5,7,11),QX(5,7,13)
	EQUIVALENCE (I,I1)
	TYPE 1,(IDX(3,I,K),K=1,3),QX(2,I,1),(IDX(3,I,K),K=1,3)
       &,(IDX(3,I1,K),K=1,3)

3)	IN STATEMENTS OF THE FORM

	J=.NOT.(J*2)

	THE COMPILER MAKES NO ATTEMPT TO GENERATE CODE TO COMPLEMENT
	THE EXPRESSION. IF THE EXPRESSION WERE INSTEAD A VARIABLE
	THE CORRECT CODE WOULD BE GENERATED.

	THUS THE ABOVE EXAMPLE WOULD WORK PROPERLY IF RECONSTRUCTED AS:

	J=J*2
	J=.NOT.J
							PAGE 9

4)	AN IMPLICIT FUNCTION CALL WITHIN AN EXPRESSION DOESN'T INFORM
	THE COMPILER OF THE LOCATION OF ITS RESULT (ACCUMULATOR 0).
	FOR EXAMPLE:

	DOLF=IABS(M)/100+.0005

	THIS STATEMENT WILL COMPILE PROPERLY IF THE IMPLICIT FUNCTION
	IS MADE EXPLICIT:

	DOLF=FLOAT(IABS(M)/100)+.0005

5)	MIXED MODE EXPRESSIONS INVOLVING REAL AND DOUBLE WORD (DOUBLE
	PRECISION OR COMPLEX) ARRAYS DO NOT RECOMPUTE COMMON SUBSCRIPT
	EXPRESSIONS IF THE ACCUMULATOR CONTAINING THE SUBSCRIPT
	EXPRESSION IS USED AS THE LOW ORDER WORD OF THE CONVERTED REAL
	VALUE.

	STATEMENTS OF THE FORM

	REAL*8 X(4,4),Y(4,4)
	REAL D(4,4)
	X(I,J)=X(I,J)+D(I,K)*D(J,L)*Y(K,L)

	COMPILE PROPERLY IF THE SUBSCRIPT OPTIMIZATION IS REMOVED

	EQUIVALENCE (L,L1)
	X(I,J)=X(I,J)+D(I,K)*D(J,L)*Y(K,L1)

6)	A REAL VALUE STORED IN TEMP AS COMPLEX IS LATER IN THE
	EXPRESSION COMBINED WITH THE RESULT OF A COMPLEX FUNCTION OR
	OTHER COMPLEX VALUE AS IF BOTH WERE REAL. FOR EXAMPLE:

	COMPLEX CA1,CMPLX
	DIMENSION UR(10),UI(10),U(19)
	CA1=CMPLX(UR(M),UI(M))*POT(H*M)*U(M)

	THIS PROBLEM CAN BE AVOIDED BY BREAKING THE STATEMENT APART:

	CA1=POT(H*M)*U(M)
	CA1=CMPLX(UR(M),UI(M))*CA1

7)	A DOUBLE PRECISION DIVISOR MAY BE MOVED FROM THE ACCUMULATORS
	IT IS EXPECTED TO BE IN DURING THE CALCULATION OF THE DIVIDEND'S
	SUBSCRIPT IF THE SUBSCRIPT IS SUFFICIENTLY COMPLEX.

	REAL*8 DD(25),D(5,5,5)
	DD(2)=(1./D(L**M,2,L**(M/L)))-(1.0D0/D(L**M**L,2,N/L))

	THE PROBLEM IS BROUGHT ABOUT BY THE EXPONENTIATION IN THE
	SUBSCRIPTS. REMOVING THE EXPONENTIATION WILL REMOVE THE PROBLEM.

	L1=L**M
	L2=L**(M/L)
	L3=L**M**L
	DD(2)=(1./D(L1,2,L2))-(1.0D0/D(L3,2,N/L))
							PAGE 10

8)	INDIRECT COMMAND FILES WITHOUT EXTENSIONS CANNOT BE FOUND BY
	THE COMPILER.

	AN INDIRECT COMMAND FILE MAY BE PROCESSED VIA THE COMPIL CUSP
	WITH THE SAME AFFECT. FOR EXAMPLE

	COMPILE @LIST

9)	A REAL EXPRESSION CONTAINING A FUNCTION CALL MAY BE GENERATED
	AS IF IT WAS COMPLEX IF THE ARGUMENT OF THE FUNCTION IS A
	COMPLEX EXPRESSION.

	COMPLEX WL,WS
	XL=F/(ZL*Z)*CMOD2(BL*WL*(GL*BS*WS + DG))

	REMOVING THE COMPLEX CALCULATION WILL GET AROUND THE PROBLEM.

	TEMP=CMOD2(BL*WL*(GL*BS*WS + DG))
	XL=F/(ZL*Z)*TEMP

10)	A REAL VALUE STORED IN TEMP AS COMPLEX IS LATER IN THE EXPRESSION
	COMBINED WITH THE RESULT OF A COMPLEX FUNCTION AS IF BOTH WERE
	REAL.

	COMPLEX C
	C=CMPLX(UR(M,UI(M))*POT(H*M)*U(M)

	EXPLICIT TYPE CONVERSION WILL GET AROUND THE PROBLEM.

	C=CMPLX(UR(M),UI(M))*CMPLX(POT(H*M)*U(M),0.)

11)	USE OF ARRAYS WHOSE SIZE , WHILE MACHINE ADDRESSABLE, WILL NOT
	FIT ON THE MACHINE BEING USED WILL GENERATE "?MORE CORE NEEDED"
	AND "?OVERLAP" ERRORS WHEN LOADED. SINCE SUBSCRIPT BOUNDS
	ARE NOT CHECKED IT IS POSSIBLE TO PRODUCE THESE SAME ERRORS
	WITH AN OVERLY LARGE SUBSCRIPT IN AN EQUIVALENCE STATEMENT
	FOR EXAMPLE.

12)	THE RESULT OF AN ARITHMETIC OPERATION ON A VARIABLE WHICH HAS
	BECOME UNDEFINED DUE TO ITS USE IN AN ASSIGN STATEMENT IS 
	UNDEFINED AND MAY LATER PRODUCE AN "ILL MEM REF" IF THE VARIABLE
	IS USED IN AN ASSIGNED GO TO WITHOUT THE LABEL LIST. THE VARIABLE
	MAY BE DEFINED BY ITS APPEARANCE TO THE LEFT OF AN EQUALS SIGN
	IN AN ASSIGNMENT STATEMENT, IN THE LIST OF AN INPUT STATEMENT, ETC.
							PAGE 11

; THE FOLLOWING COMPILER ASSEMBLY PARAMETERS MAY BE DEFINED:

IFNDEF	CCLSW,<CCLSW=1> ;ASSEMBLE INTERFACE TO "COMPIL" CUSP.

IFE	CCLSW,<TEMPC=0> ;NO INTERFACE IMPLIES NO COMMANDS IN CORE.

IFNDEF	CCLDMP,<CCLDMP=0> ;FLUSH PROCESSING OF CONCISE COMMANDS VIA
	;DUMP MODE I/O.

IFNDEF	TEMPC,<TEMPC=1> ;ACCEPT COMMANDS FROM "COMPIL" IN CORE.

IFNDEF	PAGSIZ,<PAGSIZ=cD53> ;NUMBER OF LINES PER LISTING PAGE.

IFDEF	REENTR,ASSEMBLE A REENTRANT COMPILER.

IFDEF	FILE0,ASSEMBLE FOR A SMALL COMPILER.

IFDEF	$CCONS,FLUSH COLLAPSE CONSTANTS.

IFDEF	$FAD,FLUSH FLOATING POINT INSTRUCTIONS.

IFDEF	$FAD,<$CCONS=1> ;$FAD IMPLIES $CCONS.

IFDEF	$IMPL,FLUSH IMPLICIT STATEMENT.

IFDEF	$DATA,FLUSH DATA STATEMENT.

IFDEF	$CODE,FLUSH LISTING OF BINARY(/E).

IFDEF	$NAME,FLUSH NAMELIST.

IFDEF	$CREF,FLUSH CREF LISTING.

IFDEF	ERRCO,FLUSH TEXT OF ERROR MESSAGES.

IFDEF	HALFWD,PACK THE POPS IN FILE FX2 TWO PER WORD.

IFDEF	DEBUG,ASSEMBLE THE DEBUG PACKAGE. SEE PROGRAMMING DEPARTMENT
	;MEMORANDUM NO. 100-310-021-00, PDP-10 FORTRAN IV INTERNAL
	;MEMORANDUM #3 FOR USE.

IFNDEF	NCC0,<NCC0=cD4> ;NUMBER OF CONTINUATION CARDS FOR THE SMALL
	;COMPILER.

IFNDEF	NCC1,<NCC1=cD19> ;NUMBER OF CONTINUATION CARDS FOR THE
	;DISTRIBUTED COMPILER.

IFNDEF	EXLEN0,<EXLEN0=60> ;SIZE OF SMALL COMPILERS EXIT ROLL.

IFNDEF	EXLEN1,<EXLEN1=201> ;SIZE OF DISTRIBUTED COMPILERS EXIT ROLL.
	;SEE ERROR M-18 IN TABLE 11-3, SOFTWARE NOTEBOOK #2, PROGRAMMING
	;IN FORTRAN SECTION.

							PAGE 12

IFNDEF	WORLEN,<WORLEN=150> ;SIZE OF COMPILERS WORK ROLL. SEE ERROR M-8
	;IN THE TABLE MENTIONED ABOVE.

IFNDEF	PDPLEN,<PDPLEN=20> ;SIZE OF COMPILERS WORK STACK. SEE WORK STACK
	;OVERFLOW ERROR IN TABLE 11-2, SOFTWARE NOTEBOOK #2, PROGRAMMING
	;IN FORTRAN SECTION.

ONLY THE FOLLOWING COMBINATIONS ARE KNOWN TO WORK HOWEVER.

MAKE REENTR
IREENTR=0
$EX$$
;CCLSW=1, TEMPC=1, AND CCLDMP=0 ARE DEFINED IN EXEC.23A
LOAD /MACRO,REENTR+<FX4.23A,EXEC.23A,FX1.23A+FX2.23A+FX3.23A>
SSAVE DSK:F40

MAKE DEBUG
IHALFWD=0
DEBUG=0
ERRCO=0
$EX$$
;CCLSW=1, TEMPC=1, AND CCLDMP=0 ARE DEFINED IN EXEC.23A
LOAD /MACRO,DEBUG+<EXEC.23A,FX1.23A+FX2.23A+FX3.23A+FX4.23A>
SAVE DSK:F40DBG

;FILE0=0, $CCONS=0, $FAD=0, $IMPL=0, $DATA=0, $CODE=0, $NAME=0, $CREF=0,
;ERRCO=0, AND HALFWD=0 ARE DEFINED IN FX0.23A
LOAD /MACRO,FX0.23A+FX1.23A+FX2.23A+FX3.23A+FX4.23A
SAVE DSK:F40S
