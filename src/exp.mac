TITLE EXP1	.27V	7-NOV-1970
SUBTTL EXP	B/KK/DMN/TWE
;FROM	V.021 18-NOV-69

;SINGLE PRECISION INTEGER TO INTEGER EXP FUNCTION.

;EXP CALCULATES I**J, WHERE
;	J=Q(0) + Q(1)*2 + Q(2)*4 + ..., WHERE Q(I)=0 OR 1.

;THE CALLING SEQUENCE FOR THE ROUTINES IS:
;	PUSHJ	17,EXP1.N	WHERE N=0,2,4, OR 6.
;THE BASE IS IN AC N AND THE EXPONENT IS IN AC N+1.
;THE ANSWER IS RETURNED IN AC N.

	EXTERN	TYPER.
	ENTRY	EXP1.0,EXP1.2,EXP1.4,EXP1.6

A=0
B=1
C=2
D=3
E=4
F=5
G=6
H=7
P=17



	SIXBIT/EXP1.6/
EXP1.6:	MOVE	A,G		;SET UP BASE.
	MOVE	B,H		;SET UP EXPONENT.
	PUSHJ	P,EXP1.0	;GO TO MAIN ROUTINE.
	MOVEM	A,G		;STORE ANSWER.
	POPJ	P,		;RETURN.

	SIXBIT/EXP1.4/
EXP1.4:	MOVE	A,E		;SET UP BASE.
	MOVE	B,F		;SET UP EXPONENT.
	PUSHJ	P,EXP1.0	;GO TO MAIN ROUTINE.
	MOVEM	A,E		;STORE ANSWER.
	POPJ	P,		;RETURN.

	SIXBIT/EXP1.2/
EXP1.2:	MOVE	A,C		;SET UP BASE.
	MOVE	B,D		;SET UP EXPONENT.
	PUSHJ	P,EXP1.0	;GO TO MAIN ROUTINE.
	MOVEM	A,C		;STORE ANSWER.
	POPJ	P,		;RETURN.

	SIXBIT/EXP1.0/
EXP1.0:	JUMPE	B,[MOVEI A,1		;BASE**0 RETURNS 1
		POPJ P,]
	JUMPN	A,BASNT0	;GO AHEAD IF BASE NE 0.
	JUMPGE	B,IEXP4		;RETURN IF BASE=0, EXP >= 0.
	MOVEI	0,3		;O'E, SET UP
	PUSHJ	17,TYPER.	;ERROR MESSAGE AND
	HRLOI	0,377777	;ANS.= INFINITY
	POPJ	17,		;AND RETURN.

BASNT0:	JUMPL	B,[TRNN B,1	;TEST FOR EXP<0.  IS EXP ODD?
		MOVMS A		;EXP IS EVEN. GET ABS(BASE)
		CAIE A,1	;IS BASE +-1?
		CAMN A,[-1]
		POPJ P,		;YES, RETURN +-1
		MOVEI A,0	;NO, RETURN 0
		POPJ P,]
	PUSH	P,C		;SAVE A WORKING AC.
	MOVEI	C,1		;INITIALIZE ANSWER TO 0.
	MOVEM	C,SAVEC		;INITIALIZE FLAG WORD TO > 0.
	JUMPG	A,IEXP2		;GO TO CALC. IF ANSWER WILL BE > 0.
	TRNN	B,1		;IS EXP ODD OR EVEN?
	JRST	IEXP2		;EXP IS EVEN, ANS WILL BE > 0.
	SETCMM	SAVEC		;EXP IS ODD, BASE < 0, ANS WILL BE <0. 
	JRST	IEXP2		;GO TO CALC.

IEXP1:	IMUL	A,A		;
	JFCL	1,OVER		;TRANSFER TO OVER IF OVERFLOW.
	LSH	B,-1		;DIVIDE B BY 2.
IEXP2:	TRZE	B,1		;CHECK LAST BIT OF B.
	IMUL	C,A		;
	JFCL	1,OVER		;TRANSFER TO OVER IF OVERFLOW.
	JUMPG	B,IEXP1		;GO TO RETURN IF B HAS BECOME 0.
IEXP3:	MOVE	A,C		;PUT ANSWER IN AC A.
IEXP3A:	POP	P,C		;RESTORE AC C.
IEXP4:	POPJ	P,		;RETURN.

OVER:	HRLOI	A,377777	;SET ANSWER TO + INFINITY.
	SKIPL	SAVEC		;SKIP IF ANS IS TO BE < 0.
	JRST	IEXP3A		;GO TO RETURN.
	MOVNS	A,A		;SET UP -
	SUBI	A,1		;INFINITY
	JRST	IEXP3A		;GO TO RETURN.

SAVEC:	0

	LIT
	PRGEND

TITLE	EXP3
;FROM	V.021	22-SEP-69

;SINGLE PRECISION FORTRAN IV EXP.3 FUNCTIONS
;THESE ROUTINES CALCULATE A FLOATING POINT NUMBER RAISED TO A
;FLOATING POINT POWER. THE CALCULATION IS
;	A**B= EXP(B*LOG(A))

;IF THE EXPONENT IS AN INTEGER < 2**35 IN MAGNITUDE, THE
;RESULT WILL BE COMPUTED USING "EXP2.0" AND THE ANSWER 
;WILL HAVE THE CORRECT SIGN. (REMEMBER THAT THE "INTEGER"
;HAS ONLY 27 SIGNIFCANT BITS.)
;SINCE NEGATIVE NUMBERS RAISED TO NON-INTEGER POWERS YIELD
;COMPLEX ANSWERS, THE MAIN ALGORITHM CALCULATES
;	EXP(B*LOG(ABSF(A)))

;THE CALLING SEQUENCE FOR THE ROUTINES IS AS FOLLOWS:
;	PUSHJ	P, EXP3.'N'
;WHERE N IS EITHER 0,2,4, OR 6. THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE
;IS CALLED. THE RESULT IS RETURNED IN ACCUMULATOR N.

EXTERNAL	ALOG,EXP,EXP2.0,TYPER.
ENTRY		EXP3.0,EXP3.2,EXP3.4,EXP3.6

;ACCUMULATOR DEFINITIONS
	A=	0
	B=	1
	C=	2
	D=	3
	E=	4
	F=	5
	G=	6
	H=	7
	Q=	16
	P=	17


	SIXBIT/EXP3.6/
EXP3.6:	MOVE	A, G		;SET UP ACCUMULATOR A
	MOVE	B, H		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP3.0	;GO TO MAIN ROUTINE.
	MOVE	G,A		;ANSWER IN CORRECT AC.
	POPJ	P,		;EXIT

	SIXBIT/EXP3.4/
EXP3.4:	MOVE	A, E		;SET UP ACCUMULATOR A
	MOVE	B, F		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP3.0	;GO TO MAIN ROUTINE.
	MOVE	E,A		;ANSWER IN CORRECT AC.
	POPJ	P,		;EXIT

	SIXBIT/EXP3.2/
EXP3.2:	MOVE	A, C		;SET UP ACCUMULATOR A
	MOVE	B, D		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP3.0	;GO TO MAIN ROUTINE.
	MOVE	C,A		;ANSWER IN CORRECT AC.
	POPJ	P,		;EXIT

	SIXBIT/EXP3.0/
EXP3.0:	JUMPE	B,[MOVSI A,(1.0)	;BASE**0, RETURNS 1
		POPJ P,]
	JUMPN	A,EXP30A	;GO AHEAD IF BASE NE 0.
	JUMPGE	B,EXP3A		;EXIT IF BASE = 0, EXP >= 0,
	MOVEI	A,3		;O'E, RETURN AN
	PUSHJ	17,TYPER.	;ERROR MESSAGE AND
	HRLOI	A,377777	;ANS.=+INFINITY
	POPJ	17,		;AND EXIT.

EXP30A:	PUSH	P,C		;SAVE AC C
	PUSH	P,D		;SAVE AC D
	MOVM	D,B		;SET EXP. POSITIVE.
	MOVEI	C,0		;CLEAR AC C TO ZERO
	LSHC	C,11		;SHIFT 9 PLACES LEFT
	SUBI	C,200		;TO OBTAIN SHIFTING FACTOR
	PUSH	P,E		;SAVE AC E.
	JUMPLE	C,EXP3GO	;IS C > 0
	HRR	E,C		;SET UP E AS AN INDEX REG.
	MOVEI	C,0		;CLEAR OUT AC C
	LSH	D,-1		;RIGHT ADJUST EXP TO BIT 1.
	ASHC	C,(E)		;SHIFT LFT BY CONTENTS OF E
	JFCL	EXP3GO		;IF OVERFLOW, GO TO EXP3GO.
	JUMPN	D,EXP3GO	;IS EXPONENT AN INTEGER ?
	JUMPGE	B,.+2		;YES, WAS  IT NEG. ?
	MOVNS	C		;YES, NEGATE IT
	MOVE	B,C		;MOVE INTEGER INTO B
	PUSHJ	P,EXP2.0	;OBTAIN RESULT USING EXP2.0
	JRST	EXPPOP		;RETURN TO RESTORE ACS C&D&E.
EXP3GO:	MOVMM	A,TEMP		;GET ABS(BASE) IN NE 0 OR 1.
	MOVE	C,B		;SAVE AC B.
	JSA	Q,ALOG		;CALCULATE LOG OF A
	EXP	TEMP		;ADDRESS FOR LOG ROUTINE.
	FMPRM	A, C		;CALCULATE B*LOG(A)
	JSA	Q, EXP		;CALCULATE EXP(B*LOG(A))
	EXP	C		;ADDRESS OF B*LOG(A)
EXPPOP:	POP	P,E		;RESTORE AC E.
	POP	P,D		;RESTORE AC D.
	POP	P,C		;RESTORE AC C.
EXP3A:	POPJ	P,		;EXIT

TEMP:	0

	LIT
	PRGEND
TITLE EXP2
;FROM	V.021	22-SEP-69

;SINGLE PRECISION EXP.2 FUNCTIONS
;THESE ROUTINES CALCULATE A FLOATING POINT NUMBER TO A FIXED
;POINT POWER. THE CALCULATION IS A**B, WHERE B IS OF THE FORM

;	B=Q(0) + Q(1)*2 + Q(2)*4 + ...WHERE Q(I)=0 OR 1

;THERE ARE NO RESTRICTIONS ON THE BASE OR EXPONENT

;THE CALLING SEQUENCES FOR THE ROUTINES ARE AS FOLLOWS:
;	PUSHJ	P, EXP2.'N'
;WHERE N IS EITHER 0,2,4, OR 6. THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE IS
;CALLED. THE ANSWER IS RETURNED IN ACCUMULATOR N.

	ENTRY	EXP2.0,EXP2.2,EXP2.4,EXP2.6

	EXTERN	OVPCWD,ALOG,EXP,FLOAT,TYPER.

;ACCUMULATOR DEFINITIONS
	A=	0
	B=	1
	C=	2
	D=	3
	E=	4
	F=	5
	G=	6
	H=	7
	P=	17


	SIXBIT/EXP2.6/
EXP2.6:	MOVE	A, G		;SET UP ACCUMULATOR A
	MOVE	B, H		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP2.0	;GO TO MAIN ROUTINE.
	MOVEM	A, G		;MOVE ANSWER TO CORRECT AC.
	POPJ	P,		;RETURN

	SIXBIT/EXP2.4/
EXP2.4:	MOVE	A, E		;SET UP ACCUMULATOR A
	MOVE	B, F		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP2.0	;GO TO MAIN ROUTINE.
	MOVEM	A, E		;MOVE ANSWER TO CORRECT AC.
	POPJ	P,		;RETURN

	SIXBIT/EXP2.2/
EXP2.2:	MOVE	A, C		;SET UP ACCUMULATOR A
	MOVE	B, D		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP2.0	;GO TO MAIN ROUTINE.
	MOVEM	A, C		;MOVE ANSWER TO CORRECT AC.
	POPJ	P,		;RETURN

	SIXBIT/EXP2.0/
EXP2.0:	JUMPE	B,[MOVSI A,(1.0)		;BASE**0, RETURNS 1
		POPJ P,]
	JUMPN	A,EXP2A		;GO AHEAD IF BASE NE 0.
	JUMPGE	B,FEXP4		;EXIT IF BASE =0, EXP >= 0,
	MOVEI	0,3		;O'E, SET UP
	PUSHJ	17,TYPER.	;AN ERROR MESSAGE AND
	HRLOI	0,377777	;AN ANSWER OF INFINITY.
	POPJ	17,		;RETURN.

EXP2A:	MOVEM	C,SAVEC  	;SAVE A WORKING ACCUMULATOR.
	MOVSI	C, 201400	;GET 1.0 IN ACCUMULATOR C.
	MOVEM	A,SAVEA		;STORE BASE IN SAVEA.
	MOVEM	B,SAVEB		;STORE EXP. IN SAVEB.
	JUMPGE	B, FEXP2	;IS EXPONENT POSITIVE?
	MOVMS	B		;NO, MAKE IT POSITIVE
	JFCL	MININF		;IF EXP WAS 400000,,0 GO TO MININF.
	PUSHJ	P, FEXP2	;CALL MAIN PART OF PROGRAM.
INV:	MOVSI	B, 201400	;GET 1.0 IN B.
	FDVM	B, A		;FORM 1/(A**B) FOR NEG. EXPONENT.
	POPJ	P,		;RETURN.

FEXP1:	FMP	A, A		;FORM A**N, FLOATING POINT.
	JFCL	OVER		;IF OVER/UNDERFLOW, GO TO OVER.
	LSH	B, -1		;SHIFT EXPONENT FOR NEXT BIT.
FEXP2:	TRZE	B, 1		;IS THE BIT ON?
	FMP	C, A		;YES, MULTIPLY ANSWER BY A**N.
	JFCL	OVER		;IF OVER/UNDERFLOW, GO TO OVER.
	JUMPN	B, FEXP1	;UPDATE A**N UNLESS ALL THROUGH.
FEXP3:	MOVE	A, C		;PICK UP RESULT FROM C.
FEXP3A:	MOVE	C,SAVEC		;RESTORE A WORKING ACCUMULATOR.
FEXP4:	POPJ	P,		;RETURN.

OVER:	MOVE	C,OVPCWD	;PICK UP FLAGS.
	SKIPG	SAVEB		;JUMP TO INVERT IF
	JRST	INVERT		;EXP. WAS NEGATIVE.
	MOVEI	A,3		;A CONTAINS 3 UNLESS
	TLNE	C,(1B11)	;UNDERFLOW, IN WHICH CASE,
OUT:	ADDI	A,1		;A CONTAINS 4.
	PUSHJ	P,TYPER.	;TYPE ERROR MESSAGE.
	HRLOI	A,377777	;ANS. IS SET TO + INFINITY.
	TLNE	C,(1B11)	;SKIP IF OVERFLOW FLAG SET.
	SETZ	A,		;O'E, SET ANSWER TO 0.
OUT2:	SKIPL	SAVEA		;ANS. IS >= 0, IF
	JRST	FEXP3A		;A WAS >= 0.
	MOVE	B,SAVEB		;PICK UP THE EXP.
	TRNE	B,1		;ANS. IS < 0, IF A < 0 AND
	MOVNS	A		;THE EXP. WAS ODD.
	JRST	FEXP3A		;GO TO RETURN.

INVERT:	SUB	P,[XWD 1,1]	;ADJUST PDP.
	TLCN	C,(1B11)	;IF TRUE UNDERFLOW, GO
	JRST	ALOGRT		;TO ALOGRT.
	MOVEI	B,0		;SET UP ARG. FOR TYPER.
	JRST	OUT		;GO AND TYPE ERROR MESSAGE.

ALOGRT:	MOVM	C,SAVEA		;PICK UP ABS(BASE).
	JSA	16,ALOG		;CALC. LOG(ABS(A)).
	EXP	C		;ARG. IS IN AC C.
	MOVEM	A,C		;RESULTS TO C.
	JSA	16,FLOAT	;MAKE EXP. A FLOATING
	EXP	SAVEB		;POINT NUMBER.
	FMPRM	A,C		;CALC. B*ALOG(ABS(A)).
	JSA	16,EXP		;FIND EXP. OF THIS.
	EXP	C		;ARG IS IN AC C.
	JRST	OUT2		;GO AND TYPE ERROR MESSAGE.

MININF:	HRLOI	B,377777	;SET EXP = +INFINITY.
	PUSHJ	P,FEXP2		;GO TO MAIN ROUTINE.
	FMPR	A,SAVEA		;ANS. = ANS. TIMES A.
	JFCL	OVER		;GO TO OVER IF OVERFLOW.
	JRST	INV		;OTHERWISE, GO TO INV.


SAVEA:	0			;TEMP FOR A.
SAVEB:	0			;TEMP FOR B.
SAVEC:	0			;TEMP FOR C.

	LIT
	PRGEND
	TITLE	EXP  V.027
	SUBTTL	15-JUL-70	ED YOURDON/KK/DMN
;FROM	V.021	8-AUG-69

;FLOATING POINT SINGLE PRECISION EXPONENTIAL FUNCTION
;IF X<=-89.415..., THE PROGRAM RETURNS ZERO AS THE ANSWER
;IF X>=88.029..., THE PROGRAM RETURNS 377777777777 AS THE ANSWER
;THE RANGE OF THE ARGUMENT IS REDUCED AS FOLLOWS:
;EXP(X) = 2**(X*LOG(E)BASE2) = 2**(M+F)
;WHERE M IS AN INTEGER AND F IS A FRACTION
;2**M IS CALCULATED BY ALGEBRAICALLY ADDING M TO THE EXPONENT
;OF THE RESULT OF 2**F. 2**F IS CALCULATED AS

;2**F = 2(0.5+F(A+B*F^2 - F-C(F^2 + D)**-1)**-1

;THE ROUTINE HAS THE FOLLOWING CALLING SEQUENCE:
;	JSA	Q, EXP
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	A=	0
	B=	1
	C=	2
	D=	3
	Q=	16

	EXTERN TYPER.
	ENTRY	EXP



	SIXBIT/EXP/
EXP:	0			;ENTRY TO EXPONENTIAL ROUTINE
	MOVE	B, @(Q)		;PICK UP THE ARGUMENT IN B
	CAMGE	B,E77		;IS EXP. < -89.41...?
	JRST	OUT2		;YES, GO TO EXIT.
	CAMG	B,E7		;IS EXP. > +88.029...?
	JRST	EXP1		;GO TO STANDARD ALGORITHM.
	MOVEI	A,3		;SET UP ARG FOR ERROR MESSAGE.
	PUSHJ	17,TYPER.	;TYPE OUT ERROR MESSAGE.
	HRLOI	A, 377777	;GET LARGEST FLOATING NUMBER
	JRA	Q, 1(Q)		;EXIT

OUT2:	MOVEI	A,4		;SET UP ARG FOR ERROR MESSAGE.
	PUSHJ	17,TYPER.	;TYPE OUT ERROR MESSAGE.
	MOVEI	A,0		;ANSWER IS 0.
	JRA	Q,1(Q)		;EXIT


EXP1:	MOVEM	C, ES1		;SAVE ACCUMULATOR C
	MOVEM	D, ES3		;SAVE ACCUMULATOR D
	SETZM	ES2		;INITIALIZE ES2
	MULI	B, 400		;SEPARATE FRACTION AND EXPONENT
	TSC	B, B		;GET A POSITIVE EXPONENT
	MUL	C, E5		;FIXED POINT MULTIPLY BY LOG2(E)
	ASHC	C, -242(B)	;SEPARATE FRACTION AND INTEGER
	AOSG	C		;ALGORITHM CALLS FOR MULT. BY 2
	AOS	C		;ADJUST IF FRACTION WAS NEGATIVE
	HRRM	C, EX1		;SAVE FOR FUTURE SCALING
	JUMPG	D,ASHH		;GO AHEAD IF ARG > 0.
	TRNN	D,377		;ARE ALL THESE BITS 0?
	JRST	ASHH		;YES, GO AHEAD.
	ADDI	D,200		;NO, FIX UP.
ASHH:	ASH	D, -10		;MAKE ROOM FOR EXPONENT
	TLC	D, 200000	;PUT 200 IN EXPONENT BITS
	FADB	D, ES2		;NORMALIZE, RESULTS TO D AND ES2
	FMP	D, D		;FORM X^2
	MOVE	A, E2		;GET FIRST CONSTANT
	FMP	A, D		;E2*X^2 IN A
	FAD	D, E4		;ADD E4 TO RESULTS IN D
	MOVE	B, E3		;PICK UP E3
	FDV	B, D		;CALCULATE E3/(F^2 + E4)
	FSB	A, B		;E2*F^2-E3(F^2 + E4)**-1
	MOVE	C, ES2		;GET F AGAIN
	FSB	A, C		;SUBTRACT FROM PARTIAL SUM
	FAD	A, E1		;ADD IN E1
	FDVM	C, A		;DIVIDE BY F
	FAD	A, E6		;ADD 0.5
EX1:	FSC	A, 0		;SCALE THE RESULTS
	MOVE	C, ES1		;RESTORE ACCUMULATOR C
	MOVE	D, ES3		;RESTORE ACCUMULATOR D
	JRA	Q, 1(Q)		;EXIT

E1:	204476430062		;9.95459578
E2:	174433723400		;0.03465735903
E3:	212464770715		;617.97226953
E4:	207535527022		;87.417497202
E5:	270524354513		;LOG(E), BASE 2
E6:	0.5
E7:	207540074636		;88.029...
E77:	570232254037		;-89.415986
ES1:	0
ES2:	0
ES3:	0

	LIT
	END

