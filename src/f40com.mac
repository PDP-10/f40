	SUBTTL	FX1 V.25	20-JAN-72
	;UPDATE IF COMPILER IS CHANGED

	TITLE	FORTRAN PDP-6/10
;;HARDFL==1							; *EJG* 06/23/76
HARDFL==0							; *EJG* 06/23/76
DEBUG==1
	IFDEF	REENTR,	<HISEG>

IFNDEF	FILE0,
<
	INTERNAL	TITLE,SUBTLE
TITLE:
	SIXBIT	/F4    /
	SIXBIT	/F40   /
	DEFINE LEVEL (WHO,VVV,UU,EDIT)	;"23-AU"
<
SUBTLE:	SIXBIT	/V'VVV'UU/	;"23-AU"
	LOC	<JOBVER=	137>	;"23-AU"
IFDEF	DEBUG,
<	BYTE (3) 7 (9) VVV (6) "UU"&77 (18) EDIT> ;"23-AU"
IFNDEF	DEBUG,
<	BYTE (3) WHO (9) VVV (6) "UU"&77 (18) EDIT> ;"23-AU"
	RELOC
>
	LEVEL	0,25,,0;##### UPDATE IF COMPILER CHANGES ;"23-AU"

IFDEF	REENTR,<

	EXTERNAL	PINATO,	PDPSW,	PROGN,	ERRMSG,ENDFLG
	EXTERNAL	LBFLG,	FEXADR,	ERRCNT,	LCANUM,IMDFLG
	EXTERNAL	NDISCA,	NUNPOS,	FAICAR,	FSTFLA,	ENDCOD	;"23P"
	EXTERNAL	COPRCT,	FMSBOX,	ERRBOX,	CCAFLA,	LFUTEM	;"23GG"
	EXTERNAL	SYMBOL,	CANCLU,	MAC1,	CON1,	LFUATO	;"23GG"
	EXTERNAL	RPACLU,	DAT1,	MAC2,	DAT2
	EXTERNAL	DAT3,	DAT4,	HITCNT,	ISAFLA
	EXTERNAL	NOPPNT,	BEXPNT,	RPRNAM,	RETPNT,	LSPDEF ;"23-AM"
	EXTERNAL	FARTEM,	ASTFLA,	IIAFLA,	DSTFLA
	EXTERNAL	GSTFLA,	JSTFLA,	BDPFLA,	ERRFLA
	EXTERNAL	PPEFLA,	FORFLA,	CRFSW,	SINFLA
	EXTERNAL	QFACCN,	MSTLOC,	CREPNT,	HOLBUF
	EXTERNAL	HBUIND,	ROLPNT,	ESIBOX,	DDOCNT
	EXTERNAL	DITCNT,	DLICNT,	MCOFLA,	CLBBOX
	EXTERNAL	CBABOX,	DUSCNT,	REGTEM,	EXPA
	EXTERNAL	EXPONE,	DARFLA,	IOLFLA,	JOUFLA
	EXTERNAL	TEMP,	DSPFLA,	SARFLA,	LATPNT
	EXTERNAL	LA1S13,	LA1S14,	PROBRE,	RROFLA
	EXTERNAL	FELFLA,	MINBOX,	ISCBOX,	MAXBOX
	EXTERNAL	VPNBOX,	SMABOX,	IBICNT,	SMIBOX
	EXTERNAL	ABLPNT,	ARGCNT,	ESTFLA,	CARNUM
	EXTERNAL	LACCCN,	TEMCNT,	IIVPNT,	MLBCNT
	EXTERNAL	LOCCNT,	LASACT,	LTEPNT,	STAPSA
	EXTERNAL	STACSA,	STAEXS,	STAWKS,	LAPTMP
	EXTERNAL	LAPEND,	SSATMP,	SSAEND,	STATBS
	EXTERNAL	AFDTPN,	RGRTMP,	PSTCRD,	OARNCL
	EXTERNAL	ARNCLU,	FRNCLU,	OPNCLU,	IMPCLU
	EXTERNAL	AROCLU,	OAROCL,	CPOCLU,	CONTEM
	EXTERNAL	APACLU,	FRAPCL,	TPOBOX,	ACOCNT
	EXTERNAL	BPACLU,	SEXCLU,	WORROL,	TOPS
	EXTERNAL	BOTTOM,	ANCHOR,	FLOORS,	EROADR
	EXTERNAL	AC00,	AC01,	AC02,	AC03
	EXTERNAL	AC04,	AC05,	AC06,	AC07
	EXTERNAL	AC10,	AC11,	AC12,	AC13
	EXTERNAL	AC14,	ROLMEM,	CRDCNT,	PAGCNT
	INTERNAL	ZERCOR,	PDPSET
	EXTERNAL	ZERA,	MACSW,	AC1SAV,	EXPSAV
	EXTERNAL	TTLERR,	NUMPRO,	PDPSWZ,	EXTSAV
	EXTERNAL	PROGNZ,	ERRCNZ,	PDPSTK,	JOBFFI
	EXTERNAL	XE,	XE1,	XE2,	XE3
	EXTERNAL	CMDBUF,	CMDPNT,	CMDCNT,	TTOBUF
	EXTERNAL	TTOPNT,	TTOCNT,	BINBUF,	BINPNT
	EXTERNAL	BINCNT,	LSTBUF,	LSTPNT,	LSTCNT
	EXTERNAL	SRCBUF,	SRCPNT,	SRCCNT,	LINCNT
	EXTERNAL	CARBUF,	APAEM,	SLPEM,	APAATO
	EXTERNAL	RSIEM,	SIGMAS,	RSITRA,	RSIATO
	EXTERNAL	SLBPNT,	ETYEM,	EOPPNT,	ETYATO
	EXTERNAL	PINEM,	PINATO,	IMPURE,	REGSAV
	EXTERNAL	GALPNT,	APLPNT,	AREPNT,	REGCNT	;"21V"
	EXTERNAL	ASTPNT,	CARPNT,	FREPNT,	OPCPNT
	EXTERNAL	SCAPNT,	SUBPNT,	GDMPNT,	LBLPNT
	EXTERNAL	ITEPNT,	DSTPNT,	NNAPNT,	ARRPNT
	EXTERNAL	CODPNT,	ERRPNT,	GSPPNT,	HCOPNT
	EXTERNAL	APNPNT,	CPOPNT,	UN2PNT,	LAPEND
	EXTERNAL	CEMADR,	PEMADR,	SEQPNT,	FICPNT
	EXTERNAL	DEFINE				;"21U"
	EXTERNAL	SAV15,	SAV16			;"21V"
	EXTERNAL	MULRET				;"22A"
>
	EXTERNAL	CHAR,	LSTOUT,	LSTTAB,	ERROUT,	BINOUT,	PANIC
	EXTERNAL	LSTFLG,	BINFLG,	CSWFLG,	ESWFLG,	MSWFLG,	TTYFLG
IFNDEF	FILE0,	;"23B"
<	EXTERNAL	HDRBIT,	ERROR	;"23J"
	EXTERNAL	ISWBIT	;"23Q"
>	;"23B"
	EXTERNAL	MOTFLG ;"23Q"
	INTERNAL	F4,	ASCIBL
	INTERNAL	EXIRLI,	LENGTI,	CSTATI
	INTERNAL	CRR,	EOF,	SPACE,	TAB,	N0
IFNDEF	FILE0,			;"23B"
<	INTERNAL	PDLOV	;"23J"
>				;"23B"
	INTERNAL	NCDML

IFNDEF	REENTR,
<	INTERNAL	ZERCOR,	PDPSET,	ROLMEM,	JOBFFI,	SEQPNT
	INTERNAL	PDPSWZ,	PROGNZ,	CARBUF,	EROADR,	CRDCNT,	LINCNT,	PAGCNT
	INTERNAL	ERRCNZ,	TTLERR,	NUMPRO,	BOTTOM,	FLOORS,	CORSIZ
	INTERNAL	XE,	XE1,	XE2,	XE3
	INTERNAL	AC00,	AC01,	AC02,	AC03
	INTERNAL	AC04,	AC05,	AC06,	AC07
	INTERNAL	AC10,	AC11,	AC12,	AC13
	INTERNAL	AC14,	EXTSAV

	INTERNAL	CMDBUF,	CMDPNT,	CMDCNT
	INTERNAL	TTOBUF,	TTOPNT,	TTOCNT
	INTERNAL	BINBUF,	BINPNT,	BINCNT
	INTERNAL	LSTBUF,	LSTPNT,	LSTCNT
	INTERNAL	SRCBUF,	SRCPNT,	SRCCNT
>>
;	IFDEF	$CCONS,	FLUSH COLLAPSE CONSTANTS

;	IFDEF	$FAD,	FLUSH FLOATING POINT INSTRUCTIONS

	IFDEF	$FAD,	<$CCONS=	0>	;$FAD IMPLIES $CCONS

;	IFDEF	$IMPL,	FLUSH IMPLICIT

;	IFDEF	$DATA,	FLUSH DATA STATEMENT

;	IFDEF	$CODE,	FLUSH LISTING OF BINARY (/E)

;	IFDEF	$NAME,	FLUSH NAMELIST

;	IFDEF	$CREF,	SUPPRESS CREF LISTING

;	IFDEF	ERRCO,	DEFINE ERROR MESSAGE QUALIFIER ONLY	;"23O"

;	IFDEF	HALFWD,	ASSEMBLE IN HALF-WORD POPS

;	IFDEF	DEBUG,	ASSEMBLE DEBUG PACKAGE

;	IFDEF	HARDFL,	ASSEMBLE FOR HARDWARE FORMAT FLT. PNT.	; *EJG* 06/23/76
	SPACE=	" "	-40
	DBLQT=	042	-40	;"23F"
	LBSIGN=	"#"	-40
	DOLLAR=	"$"	-40
	PERCNT=	"%"	-40
	AMPSND=	"&"	-40	;"23G"
	SNGLQT=	"'"	-40

	LPAREN=	"("	-40
	RPAREN=	")"	-40
	ASTERI=	"*"	-40
	PLUS=	"+"	-40
	COMMA=	","	-40
	MINUS=	"-"	-40
	PERIOD=	"."	-40
	SLASH=	"/"	-40

	N0=	"0"	-40
	N1=	"1"	-40
	N2=	"2"	-40
	N3=	"3"	-40
	N4=	"4"	-40
	N5=	"5"	-40
	N6=	"6"	-40
	N7=	"7"	-40
	N8=	"8"	-40
	N9=	"9"	-40

	EQUAL=	"="	-40
	INDCHA=	"@"	-40

	A=	"A"	-40
	B=	"B"	-40
	C=	"C"	-40
	D=	"D"	-40
	E=	"E"	-40
	F=	"F"	-40
	G=	"G"	-40
	H=	"H"	-40
	I=	"I"	-40
	L=	"L"	-40
	M=	"M"	-40
	N=	"N"	-40
	O=	"O"	-40
	P=	"P"	-40
	R=	"R"	-40
	S=	"S"	-40
	T=	"T"	-40
	X=	"X"	-40

	TAB=	"["	-40
	EOF=	"]"	-40
	CRR=	"<-"	-40
	UARROW=	"?"	-40
	FORM=	"\"	-40
	%00=	00
	%01=	01
	%02=	02
	%03=	03
	%04=	04
	%05=	05
	%06=	06
	%07=	07
	%10=	10
	%11=	11
	%12=	12
	%13=	13
	%14=	14
	%15=	15
	%16=	16
	%17=	17

	D0=	^D0
	D1=	^D1
	D2=	^D2
	D3=	^D3
	D4=	^D4
	D5=	^D5
	D6=	^D6
	D7=	^D7
	D8=	^D8
	D10=	^D10
	D12=	^D12
	D14=	^D14
	D16=	^D16

;7 LINES DELETED	;"23O"
	ZERRUN=	0	;ZERO RUNG
	ONERUN=	1	;ONE RUNG
	OFFRUN=	1	;OFFSET RUNG
	APPRUN=	1	;ARG PLEX PNTR RUNG
	CASRUN=	1	;COMMON AREA SIZE RUNG
	ASIRUN=	2	;ARRAY SIZE RUNG
	TWORUN=	2	;TWO RUNG
	LODKEY=	3	;LETTER OR DIGIT KEY
	SPNRUN=	3	;STATUS PNTR RUNG
	THRRUN=	3	;THREE RUNG
	UCNRUN=	4	;USE CNT RUNG
	MOIEFM=	4	;MAX ONES IN EXPON FOR MPY
	CSIRUN=	4	;CALC SIZE RUNG
	RORBAS=	6	;RUN ON ROLL BASE
	MAEFMP=	200	;MAX ABS EXPON FOR MPY

	LETKEY=	1	;LETTER KEY
	DIGKEY=	2	;DIGIT KEY
	DOEKEY=	10	;D OR E
	POMKEY=	20	;PLUS OR MINUS KEY
	CPAKEY=	40	;COMMA-VIRGULE-R PAREN
	COMKEY=	200	;COMMENT KEY

	CRFSTA= 34	;FLAG FOR CREF STATEMENT NUMBER
	CRFLIN=	35	;FLAG FOR CREF LINE
	CRFSYM=	36	;FLAG FOR CREF SYMBOL

	TSAREG=14	;TOP SINGLE ARITHMETIC REGISTER
IFDEF	FASTDP,
<	TDAREG=7
>
IFNDEF	FASTDP,
<	TDAREG=6	;TOP DOUBLE ARITHMETIC REGISTER
>
			;***CAUTION, TDAREG MUST BE EVEN***

	LBLROL=	0	;LBL ROLL
	OARROL=	1	;OBJECT ARRARY REF ROLL
	UN2ROL=	2	;UNUSED 2 ROLL
	APLROL=	3	;ARG PLEX ROLL
	PCOROL=	4	;PROLOG CODE ROLL
	CODROL=	5	;CODE ROLL
	GSPROL=	6	;GLOBAL SPROG ROLL
	REGROL=	7	;REG ROLL
	ICOROL=	10	;INT CONST ROLL
	ULBROL=	10	;UNDEFINE LBL ROLL
	CPOROL=	11	;CONST POOL ROLL
	MDLROL=	12	;MUL DEFINED LBL ROLL
	AERROL=	13	;ALLOC ERROR ROLL
	DEFROL=	13	;DEFINED GLOBAL DUMMY ROLL
	OCOROL=	14	;OCT CONST ROLL
	HCOROL=	15	;HOLLERITH CONST ROLL
	FCOROL=	16	;FL CONST ROLL ;"23EE"
	RCOROL= 16	;REAL CONST ROLL
	DPCROL=	16	;DOUBLE PREC CONST ROLL
	ENEROL=	16	;EQUIV NEST ROLL
	CCOROL=	17	;COMPLEX CONST ROLL
	CARROL=	17	;COMMON AREA ROLL
	SCAROL=	20	;SCALAR ROLL
	LDMROL=	21	;LOCAL DMY ROLL
	ARRROL=	22	;ARRAY ROLL
	NNAROL=	23	;NAMELIST NAME ROLL
	AREROL=	24	;ARRAY REF ROLL
	GALROL=	25	;GENERAL ALLOC ROLL
	ERRROL=	26	;ERROR ROL
	TEMROL=	27	;TEMP ROLL
	FREROL=	30	;FUNC REF ROLL
	SUBROL=	30	;SUBEXP ROLL
	APNROL=	31	;ARG PNTR ROLL
	SUDROL=	32	;SUBORDS ROLL
	NESROL=	33	;NEST ROLL
	GDMROL=	34	;GLOBAL DMY ROLL
	IMPROL=	35	;IMPLICIT ROLL
	LSPROL=	36	;LOCAL SPROG ROLL
	DLOROL=	37	;DO LOOPS OPEN ROLL
	ITEROL=	40	;ITEM TEMP ROLL
	ATEROL=	41	;ARRAY TEMP ROLL
	CTEROL=	41	;CONST TEMPT ROLL
	DLIROL=	42	;DATA LIST ROLL
	DIMROL=	42	;DIMENS ROLL
	DLCROL=	43	;DATA LIST CONST ROLL
	DARROL=	43	;DIMENS ARG ROLL
	DITROL=	44	;DATA ITEMS ROLL
	LIMROL=	44	;LIMITS ROLL
	DSTROL=	45	;DATA SCRIPT TERM ROLL
	DSVROL=	46	;DATA SCRIPT VAR ROLL
	ETEROL=	46	;EQUIV TEMP ROLL
	NITROL=	47	;NAMELIST ITEMS ROLL
	VARROL= 47	;VARIABLE POINTER ROLL
	IIDROL=	50	;INTEGER ID ROLL
	SIIROL=	51	;SUBSCRIPT INTEGER ID ROLL
	RIDROL=	52	;REAL ID ROLL
	LIDROL=	53	;LOGICAL ID ROLL
	CRFROL= 54	;CREF ROLL
	ASTROL=	55	;ARRAY STAT ROLL
	DPIROL=	56	;DOUBLE PRECISION ID ROLL
	CIDROL=	57	;COMPLEX ID ROLL
	EDAROL=	60	;EQUIV DATA ROLL
	CDAROL=	61	;COMMON DATA ROLL
	LRONUM=	62	;LAST ROLL NUMBER
	CNAROL=	62	;COMMON NAMES ROLL
	FTAROL=	63	;FIRST TABLE ROLL
	OPCROL=	64	;OP ROLL
	LFUROL=	65	;LIB FUNC ROLL
	CAPHEA=	170000		;COMMON AREA PNTR HEAD
	IBIEXP=	306	;INITIAL BINARY EXP 
	MDEEXP=	^D40		;MAX DECIMAL EXPONENT
	NOFREG=	17		;NUMBER OF REGS PLUS 1
	C6PNTR=	206		;COLUMN SIX PNTR

	WPL=	^D15		;WORDS PER BUFFER LINE

IFNDEF	NCC0,	<NCC0=	^D4 >
					;MAX NUMBER OF CARDS PER STATEMENT
IFNDEF	NCC1,	<NCC1=	^D19>

	;FIRST BUFFER CONTAINS 20 WORDS INSTEAD OF 15
	;IN ORDER TO PRINT OUT LONGER ERROR MESSAGES
	CBLEN0=	<NCC0+2>*WPL+5	
	CBLEN1=	<NCC1+2>*WPL+5	
		;AND THE REST ARE CONTINUATION CARDS


IFNDEF	EXLEN0,	<EXLEN0= 60>
					;EXIT ROLL LENGTH
IFNDEF	EXLEN1,	<EXLEN1=201>

IFNDEF	FILE0,	<IFNDEF	WORLEN,	<WORLEN=200>>	;LARGE COMPILER WORK ROLL LENGTH
IFNDEF	WORLEN,	<WORLEN=100>	;WORK ROLL LENGTH
IFNDEF	PDPLEN,	<PDPLEN= 40>	;%17 STACK LENGTH

IFDEF	REENTR,	<ZZ=0>		;NO OFFSET IF REENTRANT COMPILER
IFDEF	HALFWD,<ERRCO=0>	;SHORT ERRORS FOR SMALL COMPILERS
IFNDEF	HALFWD,
<
	DEFINE	OP	(NAME)	<
	NAME=	.-F4

	OPDEF	NAME	[Z	NAME       ]
	OPDEF	NAME'T	[Z	NAME!400000]
	OPDEF	NAME'F	[Z	NAME!200000]	>
>

IFDEF	HALFWD,
<
	DEFINE	OP	(NAME)	<
	NAME=	OPCNT

	DEFINE	NAME	(ADDR)	<
	HWD	NAME<-9!ADDR	>

	DEFINE	NAME'T	(ADDR)	<
	HWD	NAME<-9!ADDR!400000>

	DEFINE	NAME'F	(ADDR)	<
	HWD	NAME<-9!ADDR!200000>

	OPJSET	NAME
	>

	IF1,	<DEFINE	OPJSET	<OPCNT=	OPCNT+1 ;>>

	IF2,	<DEFINE	OPJSET	(NAME)	<
IFN	<OPCNT=	OPCNT+1><--7, <PRINTX -NAME- OVERFLOWS OP TABLE>
	IFDEF DEBUG, < 
	RELOC	DEBITB+OPCNT-1
	SIXBIT	/NAME/
	RELOC>
	CODE=	CODE+<.-F4><-<NN=NN-^D12>
	IFE NN,	<
	RELOC	OPJTBL+<OPCNT-1>/3
	+CODE
	RELOC
	NN=^D36+<CODE=0>>>>

	IF1,	<DEFINE	HWD	<BLOCK	1 ;>>

	IF2,	<DEFINE	HWD	(ADDR)	<
	IFE .&1,	<CODE=<ADDR><-^D18>
	IFN .&1,	<CODE=CODE!<ADDR>
	RELOC
	+CODE
	LOC>
	BLOCK	1>>

	OPCNT=0				;OP COUNTER


	IF2,	<
	CODE=	0			;JUMP TABLE ACCUMULATOR
	NN=^D36>			;CODE PACK COUNTER
>

	DEFINE	OPSAVE	(NAME)	<
	SYN	NAME,	NAME'SAV
	PURGE	NAME		>

	DEFINE	OPREST	(NAME)	<
	SYN	NAME'SAV,NAME
	PURGE	NAME'SAV	>
F4:
	MOVSI	%06,10000			;BYTE (3)0,SIGN
	MOVEM	%06,RSITRA+ZZ
	MOVSI	%06,700000			;BYTE (3)MASK
	MOVEM	%06,ETYEM+ZZ
	MOVEM	%06,LFUTEM+ZZ	;"23GG"
	MOVEI	%06,-1			;BYTE (18)0,MASK
	MOVEM	%06,SLPEM+ZZ
	MOVEI	%06,400000			;
	MOVEM	%06,APAEM+ZZ
	MOVEI	%06,-1				;BYTE (18)0,MASK
	MOVEM	%06,PINEM+ZZ
				;LINE DELETED ;"21V"
				;LINE DELETED ;"21V"

	SOS	%00					;JOBREL-1
	HRLI	%06,TOPS+1				;SETUP BLT POINTER
	HRRI	%06,TOPS+2
	HRRZM	%00,TOPS+1				;STORE TOP LOCATION (JOBREL-1)
	BLT	%06,EROADR				;FLOOD AREA WITH TOP LOCATION
	HLRZM	%00,TOPS  				;STORE JOBFF
	HLRZM	%00,BOTTOM				;ALL ROLLS HAVE 0 LENGTH EXCEPT ROLL 0
	HLRZM	%00,ANCHOR				;ROLL 0 HAS ALL FREE SPACE

	MOVSI	%06,-3				;DUMMY UP POINTERS TO MAKE
	SKIPA	%10,TABBAS				;OPTABLE (OPTABL) AND LIB FUNC TABLE (LFUTAB)
COMIN1:	HRRZM	%10,ANCHOR+FTAROL(%06)		;LOOK AND OPERATE LIKE THE REST OF
	HRRZM	%10,TOPS  +FTAROL(%06)		;THE ROLLS
	MOVE	%10,TABBAS+1(%06)
	HRRZM	%10,BOTTOM+FTAROL(%06)
	AOBJN	%06,COMIN1
IFNDEF	FILE0,
<
	TLNE	%16,MSWFLG	;SUPRESS MACRO CODE ?
	SETOM	MACSW+ZZ	;YES,SET UPPER MEMORY FLAG
>
IFDEF	FILE0,
<
	SETZM	MACSW+ZZ				;NO OPTION WITH SMALL COMPILER
>
IFNDEF	$CREF,
<
	TLNN	%16,CSWFLG	;CREF DESIRED?
	SETOM	CRFSW+ZZ	;YES, SET CREF SWITCH
>

	HRLI	%05,-WORLEN
	HRRI	%05,WORROL	;SET UP WORK ROLL
	MOVEI	%01,PRORUN	;FIRST POP LANGUAGE ROUTINE TO BE EXECUTED
IFDEF	DEBUG,
<
	HLLZM	%04,DEBS04	;SAVE ORIGINAL EXIT ROLL SIZE
	HLLZM	%05,DEBS05	;SAVE ORIGINAL WORK ROLL SIZE
>
	JRST	PSEML		;START EXECUTING PRORUN

IFNDEF	HALFWD,
<
	OP	JSB
JSBML:	HRR	%03,%01
	PUSH	%04,%03

	OP	JMP
JMPML:	HRRZ	%01,%02

PSEML:	MOVE	%06,POPMEM(%01)
	HLRZ	%02,%06
PSDISP:

IFDEF	DEBUG, <
	SKIPE	DEBSW
	PUSHJ	%17,DBEML>

	TRNN	%06,600000		;POP SETUP DISPATCH
	JRST	F4(%06)
	TRZE	%06,400000
	JUMPN	%03,F4(%06)
	TRZE	%06,200000
	JUMPE	%03,F4(%06)

NEXML:	AOJA	%01,PSEML		;NEXT ML

	OP	XML

	OP	XIT

	MOVEI	%11,EXIML
	JRST	0(%02)
>
IFDEF	HALFWD,
<
	DEFINE	JSB	(ADDR)	<
	HWD	660000!ADDR	>

	DEFINE	JSBT	(ADDR)	<
	HWD	700000!ADDR	>

	DEFINE	JSBF	(ADDR)	<
	HWD	720000!ADDR	>

JSBML:	HRR	%03,%01
	PUSH	%04,%03

	DEFINE	JMP	(ADDR)	<
	HWD	600000!ADDR	>

	DEFINE	JMPT	(ADDR)	<
	HWD	620000!ADDR	>

	DEFINE	JMPF	(ADDR)	<
	HWD	640000!ADDR	>

JMPML:	HRRZ	%01,%02

PSEML:	LDB	%02,[POINT 17,%01,34]	;GET FULL WORD ADDRESS
	TRNE	%01,1			;TEST HALF
	SKIPA	%02,POPMEM(%02)		;RIGHT HALF
	HLRZ	%02,POPMEM(%02)		;LEFT HALF
PSEML1:

IFDEF	DEBUG, <
	SKIPE	DEBSW
	PUSHJ	%17,DBEML>

	LDB	%06,[POINT  2,%02,19]	;GET FLAGS
	XCT	PSETBL(%06)		;TEST FLAGS
	LDB	%06,[POINT  7,%02,26]	;SET OP-CODE
	ANDI	%02,000777		;MASK ADDRESS
PSDISP:	IDIVI	%06,3
	LDB	%06,PSOTBL(%07)		;GET F4 ADDRESS
	JRST	F4(%06)

PSETBL:	JFCL				;NO FLAGS SET
	JUMPN	%03,NEXML		;FORGET IF TRUE
	JUMPE	%03,NEXML		;FORGET IF FALSE
	JRST	EXTADR			;EXTENDED ADDRESS

PSOTBL:	POINT	12,OPJTBL(%06),11
	POINT	12,OPJTBL(%06),23
	POINT	12,OPJTBL(%06),35
	DEFINE	XML	(ADDR)	<
	HWD	760000!<ADDR-F4>>

	DEFINE	XMLT	(ADDR)	<
	HWD	770000!<ADDR-F4>>

	DEFINE	XMLF	(ADDR)	<
	HWD	764000!<ADDR-F4>>

	SYN	XML,	XIT
	SYN	XMLT,	XITT
	SYN	XMLF,	XITF

EXTADR:					;EXTENDED ADDRESS
	LDB	%06,[POINT 3,%02,22]	;GET OP-CODE
	ANDI	%02,017777		;MASK ADDRESS
	XCT	EXTTBL(%06)		;EXECUTE TABLE
	AOJA	%01,PSEML		;UNSATISFIED CONDITIONAL
	TRNN	%02,014000		;XIT/XML
	JRST	F4(%02)			;UNCONDITIONAL
	TRZE	%02,010000
	JUMPN	%03,F4(%02)		;TRUE
	TRZE	%02,004000
	JUMPE	%03,F4(%02)		;FALSE
NEXML:	AOJA	%01,PSEML		;DIDN'T MAKE IT

EXTTBL:	JRST	    JMPML		;JMP
	JUMPN	%03,JMPML		;JMPT
	JUMPE	%03,JMPML		;JMPF
	JRST	    JSBML		;JSB
	JUMPN	%03,JSBML		;JSBT
	JUMPE	%03,JSBML		;JSBF
	JRST	    JOWML		;JOW
	SKIPA	%11,EXIMLP		;XIT/XML (SET JSP REG)
>
P2EML:					;POW 2 EXIT ML
	POP	%05,%00
P1EML:					;POW 1 EXIT ML
	POP	%05,%00
EXIML:					;EXIT ML
	POP	%04,%01
	HLRE	%03,%01
	AOJA	%01,PSEML		;POP SETUP ML

P1ETML:					;POW 1 EXIT TRUE ML
	POP	%05,%00
	JRST	ETRML			;EXIT TRUE ML
P2EFML:					;POW 2 EXIT FALSE ML
	POP	%05,%00
P1EFML:					;POW 1 EXIT FALSE ML
	POP	%05,%00
EFAML:					;EXIT FALSE ML
	TDZA	%03,%03			;ZERO WORD
ETRML:					;EXIT TRUE ML
	SETO	%03,
EXEQML:					;EXIT EQUAL ML
	POP	%04,%01
	AOJA	%01,PSEML		;POP SETUP ML
IFNDEF	HALFWD,
<
	OP	XNI
	MOVE	%10,ZZ(%02)
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	SUBI	%10,ZZ
	MOVE	%06,POPMEM+1(%01)
	HLRZ	%02,%06
	ADD	%02,%10
	AOJA	%01,PSDISP		;POP SETUP DISPATCH
>

IFDEF	HALFWD,
<
	OP	XNI
	MOVE	%10,ZZ(%02)
	PUSHJ	%17,APTML
	SUBI	%10,ZZ
	LDB	%02,[POINT 17,%01,34]
	TRNN	%01,1
	SKIPA	%02,POPMEM(%02)
	HLRZ	%02,POPMEM+1(%02)
	LDB	%06,[POINT  7,%02,26]	;SET OP-CODE
	ANDI	%02,777
	ADD	%02,%10
	AOJA	%01,PSDISP
>
IFNDEF	HALFWD,
<
	OP	FEX
	HRRZM	%02,FEXADR+ZZ		;FEX ADR
	AOJA	%01,PSEML		;POP SETUP ML
>

IFDEF	HALFWD,
<
	FEX=	OPCNT

	DEFINE	FEX	(ADDR)	<
	HWD	FEX<-9!<ADDR-.>
	IF2, <IFN <ADDR-.><--9, <PRINTX <FEX OVERFLOW - ADDR>>>>

	OPJSET	FEX

	ADD	%02,%01
	HRRZM	%02,FEXADR+ZZ
	AOJA	%01,PSEML
>
IFNDEF	HALFWD,
<
	OP	JOW
>

IFDEF	HALFWD,
<
	DEFINE	JOW	(ADDR)	<
	HWD	740000!ADDR	>
>

JOWML:	POP	%05,%00
	SOJL	%00,JMPML			;JUMP ML
	PUSH	%05,%00
	AOJA	%01,PSEML			;POP SETUP ML

	OP	EAWI
	MOVE	%02,INSTBL(%02)

	OP	EAW
	PUSH	%05,%02
	AOJA	%01,PSEML			;POP SETUP ML
	OP	W5
	MOVEI	%06,-5(%05)
	JRST	WOREXI			;WORK EXIT

	OP	W4
	MOVEI	%06,-4(%05)
	JRST	WOREXI			;WORK EXIT

	OP	W3
	MOVEI	%06,-3(%05)
	JRST	WOREXI			;WORK EXIT

	OP	W2
	MOVEI	%06,-2(%05)
	JRST	WOREXI

	OP	W1
	MOVEI	%06,-1(%05)
	JRST	WOREXI

	OP	W0
	MOVEI	%06,(%05)
WOREXI:					;WORK EXIT
	EXCH	%06,%02
	SUBI	%02,ZZ
	JRST	PSDISP			;POP SETUP DISPATCH


	OP	W3I
	SKIPA	%06,-3(%05)

	OP	W2I
	MOVE	%06,-2(%05)
	JRST	W0IXIT

	OP	W1I
	SKIPA	%06,-1(%05)

	OP	W0I
	MOVE	%06, 0(%05)
W0IXIT:	EXCH	%06,%02
	JRST	PSDISP
	OP	XW2.0
	MOVE	%10,-2(%05)		;  FOO,XW"N"."M"  =
	JRST	XWN.0			;  XNI,W"N"
					;  "M",FOO
	OP	XW1.0
	SKIPA	%10,-1(%05)

	OP	XW0.0
	MOVE	%10,0(%05)
XWN.0:	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVE	%06,%10
	JRST	WOREXI			;WORK EXIT

	OP	XW1.1
	SKIPA	%10,-1(%05)

	OP	XW0.1
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,1(%10)
	JRST	WOREXI			;WORK EXIT

	OP	XW1.2
	SKIPA	%10,-1(%05)

	OP	XW0.2
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,2(%10)
	JRST	WOREXI			;WORK EXIT

	OP	XW1.3
	SKIPA	%10,-1(%05)

	OP	XW0.3
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,3(%10)
	JRST	WOREXI			;WORK EXIT

	OP	XW0.4
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,4(%10)
	JRST	WOREXI			;WORK EXIT
	OP	SWT
	MOVE	%00,ZZ(%02)
	EXCH	%00,0(%05)
	MOVEM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	DIM
	SOSA	ZZ(%02)

	OP	ZER
	SETZM	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	NOZ
	SETOM	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	TLY
	AOSA	ZZ(%02)

	OP	SWH
	MOVSS	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	CLA
	POP	%05,%00

	OP	FET
	PUSH	%05,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	STO
	POP	%05,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	FTM
	SKIPA	%06,%03

	OP	STK
	MOVE	%06,0(%05)
	MOVEM	%06,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

LSSIML:	POP	%05,%02

	OP	LSS
	MOVE	%00,BCDTBL(%02)
	MOVEM	%00,SYMBOL+ZZ		;SYMBOL
	SETZM	DAT1+ZZ			;DATA 1
	SETZM	DAT2+ZZ			;DATA 2
	SETZM	DAT3+ZZ			;DATA 3
	AOJA	%01,PSEML		;POP SETUP ML

	OP	POW
	POP	%05,%00
	SOJG	%02,.-1
	AOJA	%01,PSEML		;POP SETUP ML

	OP	IPK
	SKIPA	%10,(%05)

	OP	IER
	SKIPA	%10,%05
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	MOVE	%00,ZZ(%02)
	ANDCAM	%00,0(%10)
	AND	%00,ZZ+1(%02)
	ORM	%00,0(%10)
	AOJA	%01,PSEML		;POP SETUP ML
	OP	IOR
	MOVE	%00,ZZ(%02)
	ORM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	IOM
	POP	%05,%00
	ORM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	EOR
	MOVE	%00,ZZ(%02)
	XORM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	EOM
	POP	%05,%00
	XORM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	AND
	OPSAVE	AND
	MOVE	%00,ZZ(%02)
	ANDM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	NOT
	SETCMM	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML
	OP	MPY
	MOVE	%00,ZZ(%02)
	IMULM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	MMY
	POP	%05,%00
	IMULM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	DIV
	OPSAVE	DIV
	MOVE	%06,0(%05)
	IDIV	%06,ZZ(%02)
	MOVEM	%06,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	ADD
	OPSAVE	ADD
	SKIPA	%02,ZZ(%02)

	OP	SUB
	OPSAVE	SUB
	MOVN	%02,ZZ(%02)

	OP	ADDA
	ADDM	%02,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SMY
	MOVNS	0(%05)

	OP	AMY
	POP	%05,%00
	ADDM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML
	OP	PLD
	MOVE	%06,ZZ(%02)
	MOVEM	%06,MAC1+ZZ		;MP AC1
	MOVE	%07,ZZ+1(%02)
	MOVEM	%07,MAC2+ZZ		;MP AC2
	AOJA	%01,PSEML			;POP SETUP ML

	OP	PST
	MOVE	%06,MAC1+ZZ		;MP AC1
	MOVEM	%06,ZZ(%02)
	MOVE	%07,MAC2+ZZ		;MP AC2
	MOVEM	%07,ZZ+1(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	PAD
	MOVE	%06,ZZ(%02)
	MOVE	%07,ZZ+1(%02)
	PUSHJ	%17,DPADD		;ADD TO MP AC ML
	AOJA	%01,PSEML			;POP SETUP ML
	OP	SNZ
	SKIPE	%03,ZZ(%02)
	SETO	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SEK
	SKIPA	%03,(%05)

	OP	SEQ
	POP	%05,%03
	EQV	%03,ZZ(%02)
	CAME	%03,AONLOW		;ALL ONES LOWER
	SETZ	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	ART
	HRRZ	%10,ZZ(%02)		;GET RH OF ADRRESS
	TRC	%10,070016		;COMPLEMENT BITS OF REG 15 PNTR
	TRNN	%10,770000		;WAS IT A REG POINTER ?
	TRNN	%10,007777		;YES, NOT POINTING TO DO REG ?
	JRST	SETFAL		;NO, SET FLAG FALSE & RETURN TO POP LANGUAGE
	MOVE	%10,ZZ(%02)		;GET REGISTER POINTER AGAIN
	PUSHJ	%17,APTML		;CALCULATE ACTUAL ADDRESS
	MOVE	%10,0(%10)		;GET CONTENTS OF REG POINTER
	LDB	%07,PHEBYT		;GET ROLL #
	CAIN	%07,27		;POINTS TO TEMP. ROLL ?
	TLZE	%10,020000		;YES, HAS REG CONTENTS CHANGED ? (INITIAL TEMP TRAIT)
	JRST	SETTRU		;NO, SET FLAG TRUE AND RETURN
	MOVEM	%10,ZZ(%02)		;YES, CHANGE REG POINTER TO TEMP. PNTR
	JRST	SETFAL		;SET FALSE AND RETURN
	OP	SGK
	SKIPA	%06,(%05)

	OP	SGT
	POP	%05,%06
	CAMG	%06,ZZ(%02)
SETFAL:	TDZA	%03,%03
SETTRU:	SETO	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SLK
	SKIPA	%06,(%05)

	OP	SLT
	POP	%05,%06
	CAML	%06,ZZ(%02)
	JRST	SETFAL
	JRST	SETTRU

	OP	SMK
	SKIPA	%03,0(%05)

	OP	SME
	POP	%05,%03
SOMEML:					;SET ON MASKED EQ ML
	EQV	%03,ZZ+1(%02)
	ORCM	%03,ZZ(%02)
	CAME	%03,AONLOW		;ALL ONES LOWER
	SETZ	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SPK
	SKIPA	%10,(%05)

	OP	SPT
	POP	%05,%10
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	SKIPA	%03,0(%10)

	OP	SON
	MOVE	%03,-1(%05)
	JRST	SOMEML			;SET ON MASKED EQ ML
	OP	SCE
	CAIE	%02,0(%14)
	JRST	SETFAL
	JRST	SETTRU

	OP	CSA
	SETO	%03,
	CAIE	%02,0(%14)
	TDZA	%03,%03
CSAXIT:	PUSHJ	%17,NCHML		;NEXT CHAR ML
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SCK
	TLNN	%14,0(%02)
	JRST	SETFAL
	JRST	SETTRU

	OP	CSF
	CAIN	%02,0(%14)
	JRST	CSAXIT

NFAML:					;NOTE FAIL ML
	MOVEI	%02,S1QT
	JSP	%11,CCEML

FAIML:					;FAIL ML
	JSP	%11,RELML
	MOVE	%01,FEXADR+ZZ
	JRST	PSEML

	OP	QSF
	MOVE	%12,%03
	PUSHJ	%17,QSAML		;QSA ML
	JUMPE	%03,QSF1			;$1
	MOVE	%03,%12
	AOJA	%01,PSEML			;POP SETUP ML

QSF1:	MOVE	%07,QFACCN+ZZ		;QSA FAIL CCNS
	HRRZI	%02,S2QT		;SYNTAX QT	;"23N"
	JSP	%11,LCEML1		;LCE ENTRY
FAIMLP:	JRST	FAIML			;FAIL ML
	OP	QSA
	PUSH	%17,NEXMLP		;NEXT ML
QSAML:					;QSA ML
	JSP	%11,LAPSML		;LOOK AHEAD POSITION SAVE ML
	MOVEI	%07,QTTBL(%02)
	HRLI	%07,(POINT 6,,)
	TDZA	%03,%03
QSAML1:	PUSHJ	%17,NCHML
	ILDB	%02,%07
	CAIN	%02,EOF
	SOJA	%03,POPOUT
	CAIN	%02,0(%14)
	JRST	QSAML1			;$1
	MOVE	%00,CARNUM+ZZ		;CARD-COL NUMBERS
	CAMN	%14,CSTAT+CRR		;CARRIAGE RETURN WITH KEYS
	MOVE	%00,LACCCN+ZZ		;LAST ACTIVE CCNS
	MOVEM	%00,QFACCN+ZZ		;QSA FAIL CCNS
	JSP	%11,LAPRML		;LOOK AHEAD POSITION RESET ML
	POPJ	%17,
	OP	FPC
	MOVE	%10,ZZ(%02)
	MOVE	%00,LACCCN+ZZ
	DPB	%00,[POINT 7,%10,17]
	HLRZS	%00
	DPB	%00,[POINT 5,%10,10]
	PUSH	%05,%10
	AOJA	%01,PSEML		;POP SETUP ML

PRNML:	TROA	%02,N0			;PRINT NUMERIC
	OP	PRC
	PUSH	%17,NEXMLP		;NEXT ML
PCHML:					;PRINT CHAR ML
IFNDEF	FILE0,			;"23B"
<	MOVE	%15,CARBUF	;"23D"
	TRZE	%15,1		;"23D"
	TRO	%16,HDRBIT	;"23D"
	MOVEM	%15,CARBUF	;"23D"
>				;"23B"
	SKIPE	ERRFLA+ZZ
	JRST	ERROUT
IFNDEF	FILE0,
<
	SKIPN	MACSW+ZZ	;SUPRESS LISTING ?
>
	TLNE	%16,LSTFLG	;IS THERE A LISTING ?
	POPJ	%17,		;NO LISTING,RETURN
	JRST	LSTOUT		;YES,LIST IT OUT

	OP	PRQ
	MOVEI	%07,QTTBL(%02)
	TLOA	%07,(POINT 6,,)
PRQML1:	PUSHJ	%17,PCHML
	ILDB	%02,%07
	CAIE	%02,EOF
	JRST	PRQML1
	AOJA	%01,PSEML

	OP	PCOL
	SKIPLE	REGSAV+ZZ	;A RANDOM UNUSED LOCATION
	JRST	PCOL1
	MOVE	%02,ZZ(%02)	;GET TABLE OFFSET
	HRRZ	%10,CSETBL(%02)	;GET NO. OF COLUMNS FOR NON TTY DEVICE
	TLNE	%16,TTYFLG	;LISTING TO TELETYPE ?
	HLRZ	%10,CSETBL(%02)	;YES, GET NO. OF COLUMNS FOR TTY
	MOVEM	%10,REGSAV+ZZ
PCOL1:	MOVEI	%02,TAB
	SOSG	REGSAV+ZZ
	MOVEI	%02,CRR
	PUSHJ	%17,PCHML
	AOJA	%01,PSEML
CSETBL:	XWD	3,5		;0 - ZER0
	XWD	^D9,^D15	;1 - ONE

	OP	ERK
	SKIPA	%10,(%05)

	OP	ERM
	POP	%05,%10
	PUSH	%17,NEXMLP

ERMML:					;ERK ENTRY
	HLLM	%03,0(%17)
	TLZ	%10,770000
	HRR	%10,%02
	MOVEM	%10,ERRBOX+ZZ		;ERROR BOX
	MOVEI	%02,ESEFIL		;ERROR SEARCH FILE
	PUSHJ	%17,REGML
	SKIPN	%03
	PUSHJ	%17,OERML		;ORDER ERRORS ML
	HLRE	%03,0(%17)
	POPJ	%17,

	OP	LCE
	SKIPA	%11,NEXMLP

	OP	LCF
LCFML:	MOVEI	%11,FAIML
	JRST	LCEML

	OP	CCE
	SKIPA	%11,NEXMLP

	OP	CCF
	MOVEI	%11,FAIML
CCEML:					;CCE ML
	MOVE	%07,CARNUM+ZZ		;CARD-COL NUM
	CAMN	%14,CSTAT+CRR
LCEML:	MOVE	%07,LACCCN+ZZ		;LAST ACTIVE CCN
LCEML1:					;LCE ENTRY
	CAMGE	%07,FAICAR+ZZ		;FAIL CARD-C
	JRST	0(%11)
	MOVEM	%02,ERRMSG+ZZ		;FOR SMALL COMPILER
	MOVEM	%07,FAICAR+ZZ		;FAIL CARD-C
	HRL	%02,%07
	LSH	%07,-^D11
	TLO	%02,0(%07)
	MOVEM	%02,FMSBOX+ZZ		;FAIL MSG BOX
	JRST	0(%11)
	OP	RSV
	MOVE	%10,TOPS(%02)		;TOPS
	SUB	%10,ANCHOR(%02)		;ANCHOR
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	MOVE	%10,BOTTOM(%02)		;BOTTOM
	MOVEM	%10,TOPS(%02)		;TOPS
	AOJA	%01,PSEML		;POP SETUP ML

	OP	MON
	POP	%05,%10
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	AOJA	%01,PSEML			;POP SETUP ML

	OP	MOA
	MOVE	%06,BOTTOM(%02)		;BOTTOM
	CAMG	%06,TOPS(%02)		;TOPS
	JRST	SETFAL
	PUSH	%05,0(%06)
	SOS	BOTTOM(%02)		;BOTTOM
	JRST	SETTRU

	OP	SRD
	PUSH	%17,NEXMLP
SRDML:					;SRD ML
	MOVE	%03,TOPS(%02)		;TOPS
	SUB	%03,BOTTOM(%02)		;BOTTOM
	ASH	%03,-^D35
	POPJ	%17,

	OP	CNT
	MOVE	%10,BOTTOM(%02)		;BOTTOM
	SUB	%10,TOPS(%02)		;TOPS
	PUSH	%05,%10
	AOJA	%01,PSEML			;POP SETUP ML
	OP	CAR
				;COPY AND RELEASE
	PUSHJ	%17,FROML
	MOVE	%12,BOTTOM(%02)
	SUB	%12,TOPS(%02)
	JUMPE	%12,CAR2
CAR1:	MOVE	%10,@BOTTOM(%02)
	SOS	BOTTOM(%02)
	EXCH	%02,0(%05)
	PUSHJ	%17,P1ORML
	EXCH	%02,0(%05)
	SOJG	%12,CAR1
CAR2:	POP	%05,%00

	OP	REL

	MOVE	%10,TOPS(%02)
	MOVEM	%10,BOTTOM(%02)
	CAMG	%10,ANCHOR(%02)
	AOJA	%01,PSEML
	SOS	BOTTOM(%02)
	MOVE	%10,0(%10)
	ADD	%10,ANCHOR(%02)
	MOVEM	%10,TOPS(%02)
	AOJA	%01,PSEML

IFNDEF	FILE0,			;"23B"
<	JOBERR=	42		;"23J"
	JOBCNI=	126		;"23J"
	JOBTPC=	127		;"23J"
PDLOV:	AOS	JOBERR		;INFORM CCL OF ERROR	;"23J"
	HRRZ	%11,JOBTPC	;GET LOCATION OF ERROR	;"23J"
	MOVE	%10,JOBCNI	;GET JOB STATUS WORD	;"23J"
	TRNN	%10,020000	;WAS THERE AN ILL MEM REF ?	;"23J"
	JRST	PDLOV1		;NO, IT WAS A PDL OV	;"23J"
	JSP	%10,ERROR	;PRINT ERROR AND GET NEXT SOURCE FILE	;"23J"
	SIXBIT /ILLEGAL MEMORY REFERENCE AT 6<-COMPILATION TERMINATED]/	;"23J"
PDLOV1:	JUMPL	%17,PDLOV2	;WORK STACK OK ?	;"23J"
	MOVE	%17,PDPSET	;NO, RESET TO ZERO	;"23J"
	JSP	%10,ERROR	;PRINT ERROR AND GET NEXT SOURCE FILE	;"23J"
	SIXBIT /WORK STACK OVERFLOW AT 6<-COMPILATION TERMINATED]/	;"23J"
PDLOV2:	MOVEI	%02,LCFML	;SIMULATE AN 'LCF    (M8QT)'	;"23J"
	HRRM	%02,JOBTPC	;"23J"
	MOVEI	%02,M8QT	;WHEN A PDL OV OCCURS	;"23J"
	SKIPL	%00,%04		;WAS IT THE EXIT ROLL ?	;"23J"
	MOVEI	%02,M18QT	;YES, MAKE SPECIFIC ERROR	;"23J"
	JRSTF	@JOBTPC		;"23J"
>				;"23B"
	OP	DNG
	PUSH	%17,NEXMLP

DNGML:				;DOWN TO NEXT GROUP ML
	SKIPE	%10,ROLPNT+ZZ(%02)
	AOJA	%10,DNGML1
	PUSHJ	%17,TPNML		;TYPE POINTER

DNGML1:	MOVEM	%10,ROLPNT+ZZ(%02)
	MOVEM	%10,CREPNT+ZZ
	PUSHJ	%17,APTML
	CAMG	%10,BOTTOM(%02)
	TDOA	%03,AONLOW
	SETZB	%03,ROLPNT+ZZ(%02)
	POPJ	%17,

	OP	FLP
	PUSH	%17,NEXMLP
FROML:				;FLIP ML
	MOVE	%07,BOTTOM(%02)
	MOVE	%10,TOPS(%02)
FROML1:	ADDI	%10,1
	CAMG	%07,%10
	POPJ	%17,
	MOVE	%00,0(%10)
	EXCH	%00,0(%07)
	MOVEM	%00,0(%10)
	SOJA	%07,FROML1
	OP	LGA
				;LOAD GROUP WITH ANSWER
	PUSHJ	%17,SRDML
NEXMLP:	JUMPE	%03,NEXML
	SETZ	%12,
	LDB	%10,RGRPNT	;ROLL GROUP SIZE POINTER
LGA1:	SOS	%06,BOTTOM(%02)
	MOVE	%00,1(%06)
	MOVEM	%00,SYMBOL+ZZ(%12)
	ADDI	%12,1
	SOJG	%10,LGA1
	SKIPN	SYMBOL+ZZ
	SETZ	%03,
	AOJA	%01,PSEML

	OP	NOG
	PUSHJ	%17,NOGML
	PUSH	%05,%10
	AOJA	%01,PSEML

NOGML:				;NUMBER OF GROUPS ML
	MOVE	%10,BOTTOM(%02)
	SUB	%10,TOPS(%02)
	LDB	%06,RGRPNT	;ROLL GROUP SIZE
	IDIV	%10,%06		;RESULT TO %10
	POPJ	%17,

	OP	PNG
	PUSHJ	%17,PNGML
	PUSH	%05,%10
	AOJA	%01,PSEML

PNGML:				;POINTER TO NEW GROUP ML
	PUSHJ	%17,NOGML		;NUMBER OF GROUPS ML

TPNML:				;TYPE POINTER ML
	ADDI	%10,1
	DPB	%02,PHEBYT
	TRNE	%10,100000
	TRNE	%10,200000
	CAIA
	DPB	%02,[POINT 3,%10,2]
	MOVEM	%10,ROLPNT+ZZ(%02)
	POPJ	%17,

	OP	DFA
	PUSHJ	%17,DNGML
	JUMPE	%03,NEXML
	PUSH	%05,0(%10)
	AOJA	%01,PSEML
	OP	CFP
	POP	%05,%10
	HRR	%12,%10
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	MOVN	%06,0(%10)
	JUMPE	%06,NEXML			;NEXT ML
	SUB	%10,%06
	SUB	%12,%06
	HRL	%12,%06
CFP2:	MOVE	%10,0(%10)
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	SUBI	%12,2
	AOBJP	%12,NEXML		;$1
	HRRZ	%10,%12
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	JRST	CFP2			;$2
	OP	AGF
	MOVE	%11,FILES(%02)
	LDB	%02,UFIMLP
	LDB	%12,RGRPNT
AGF1:	SOJL	%12,NEXML
	MOVE	%10,ZZ(%11)
	PUSHJ	%17,P1ORML
	AOJA	%11,AGF1

	OP	SRA
	PUSHJ	%17,ISEML
	JUMPE	%03,NEXML
	PUSH	%05,CREPNT+ZZ
	AOJA	%01,PSEML

	OP	CSE
	LDB	%10,UFIMLP	;ROLL #
	AOS	%10,ROLPNT+ZZ(%10)
	PUSHJ	%17,APTML
	PUSH	%17,NEXMLP
	SOJA	%10,RSEML

	OP	ISE
	PUSH	%17,NEXMLP
ISEML:	LDB	%12,UFIMLP	;ROLL #
	MOVE	%10,TOPS(%12)

RSEML:				;ROLL SEARCH ML
	LDB	%12,UFIMLP
	EXCH	%02,%12
	LDB	%06,RGRPNT
	MOVEM	%06,RGRTMP+ZZ
	MOVE	%11,FILES(%12)
	SETCM	%07,%11		;"23CC"
	TLNN	%07,77		;"23CC"
	JUMPGE	%11,RSEML2	;"23CC"
	TLOA	%11,777700

RSEML1:	ADD	%10,RGRTMP+ZZ
	CAML	%10,BOTTOM(%02)	;TEST FOR END
	JRST	SEXML		;END, EXIT
	MOVE	%07,%10		;SET UP TEMP REGS
	MOVE	%03,%11
	MOVEI	%06,1(%12)
RSEML3:	MOVE	%00,1(%07)
	XOR	%00,ZZ(%03)
	SKIPGE	FILES(%12)	;MASK?
	AND	%00,FILES(%06)	;YES
	JUMPN	%00,RSEML1	;BRANCH ON INEQUALITY
	AOBJP	%03,MSRML	;TEST FOR END
	ADDI	%07,1
	AOJA	%06,RSEML3
RSEML4:
	ADD	%10,RGRTMP+ZZ	;"23CC"
RSEML2:	CAML	%10,BOTTOM(%02)	;"23CC"
	JRST	SEXML		;"23CC"
	MOVE	%00,1(%10)	;"23CC"
	CAME	%00,ZZ(%11)	;"23CC"
	JRST	RSEML4		;"23CC"
	JRST	MSRML		;"23CC"
MSRML:				;MAKE SEARCH RESULT ML
	SUB	%10,TOPS(%02)
	IDIV	%10,RGRTMP+ZZ
	PUSHJ	%17,TPNML	;SET TYPE POINTER
	MOVEM	%10,CREPNT+ZZ	;CURRENT REG PNTR
	MOVEM	%10,ROLPNT+ZZ(%02)	;ROLL PNTR
	TDOA	%03,AONLOW	;SET TRUE ANSWER

SEXML:	SETZB	%03,ROLPNT+ZZ(%02)	;SET FALSE ANSWER
	POPJ	%17,		;EXIT

	OP	REG
	PUSH	%17,NEXMLP

REGML:				;REGISTER ML
	PUSHJ	%17,ISEML		;ROLL SEARCH ML
	JUMPN	%03,POPOUT	;EXIT IF FOUND
	PUSHJ	%17,PNGML		;POINTER TO NEW GROUP ML
	MOVEM	%10,CREPNT+ZZ	;CURRENT RGE PNTR
	MOVE	%11,FILES(%12)
	LDB	%12,RGRPNT

REG1:	SOJL	%12,POPOUT
	TLNN	%11,000070
	TDZA	%10,%10
	MOVE	%10,ZZ(%11)
	PUSHJ	%17,P1ORML
	AOBJN	%11,REG1
	JRST	REG1

UFIMLP:	POINT	6,FILES(%02),11
APTML:				;ADR POINTED TO ML
	LDB	%06,PHEBYT	;AC6 <- ROLL #
	ANDI	%10,7777	;AC10 <- ROLL PNTR (DISPLACEMENT)
	MOVEI	%10,-1(%10)	;AC10 <- # PREVIOUS GROUPS ;"21Z"
	HLRZ	%07,RGRSIZ(%06)	;AC7 <- BYTE (18) 0 (3) GROUP SIZE ;"21Z"
	CAIG	%07,177777	;GROUP SIZE > 1 ;"21Z"
	JRST	APTML1		;NO, AC10 = OFFSET ;"21Z"
	LSH	%07,-?D15	;AC7 <- GROUP SIZE ;"21Z"
	IMULI	%10,(%07)	;AC10 <- # PREVIOUS GROUPS * GROUP SIZE ;"21Z"
APTML1:	ADD	%10,TOPS(%06)	;AC10 <- OFFSET + ROLL BASE ADDRESS
	AOJA	%10,POPOUT	;AC10 <- ADDRESS POINTED TO ;RETURN 
	OP	RPL

	POP	%05,%11
	MOVE	%00,TOPS(%11)		;TOPS
	SUB	%00,BOTTOM(%11)		;BOTTOM
	MOVN	%06,%00
	HRL	%00,%00
	HRR	%00,TOPS(%11)		;TOPS
	SKIPA	%10,TOPS(%02)		;TOPS
RPLML1:	ADD	%10,0(%10)
	ADDI	%10,1
	CAMLE	%10,BOTTOM(%02)		;BOTTOM
	JRST	RPLML4			;$4
	CAME	%06,0(%10)
	JRST	RPLML1			;$3
	MOVE	%12,%00
	MOVEM	%10,1(%05)
RPLML2:	AOS	%07,1(%05)
	MOVE	%07,0(%07)
	CAME	%07,1(%12)
	JRST	RPLML1			;$3
	AOBJN	%12,RPLML2		;$2
	SUB	%10,TOPS(%02)		;TOPS
	DPB	%02,PHEBYT		;PNTR HEAD BYTE
	PUSH	%05,%10
	AOJA	%01,PSEML

RPLML4:	SUB	%10,TOPS(%02)		;TOPS
	DPB	%02,PHEBYT		;PNTR HEAD BYTE
	PUSH	%05,%10
	HLLZ	%12,%00
	MOVE	%10,%06
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
RPLML5:	MOVE	%10,TOPS(%11)		;TOPS
	ADDI	%10,1(%12)
	MOVE	%10,0(%10)
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	AOBJN	%12,RPLML5		;$5
	AOJA	%01,PSEML
ASCBCD:					;ASCII TO BCD
	POP	%05,%00
	MOVSI	%07,(POINT 7,%00,)
ASCBC1:	ILDB	%02,%07
	JUMPE	%02,NEXML
	SUBI	%02,40
	PUSHJ	%17,PCHML
	TLNE	%07,760000
	JRST	ASCBC1
	AOJA	%01,PSEML

LAPSML:					;LOOK AHEAD POSITION SAVE ML
	MOVEM	%13,LA1S13+ZZ		;LOOK AHEAD 13 SAVE
	MOVEM	%14,LA1S14+ZZ		;LOOK AHEAD 14 SAVE
	MOVE	%00,LAPBLT
	BLT	%00,LAPEND+ZZ
	JRST	0(%11)

LAPRML:					;LOOK AHEAD POSITION RESET ML
	MOVE	%13,LA1S13+ZZ		;LOOK AHEAD 13 SAVE
	MOVE	%14,LA1S14+ZZ		;LOOK AHEAD 14 SAVE
	MOVS	%00,LAPBLT
	BLT	%00,LACCCN+ZZ
	JRST	0(%11)

LAPBLT:	XWD	ESTFLA+ZZ,LAPTMP+ZZ
OPSCAN:
	HLRS	%10,OPCPNT+ZZ
	PUSHJ	%17,APTML
	LDB	%12,[POINT 6,0(%10),5]
OPSCA1:	SOJL	%12,SETFAL
	AOS	%10,OPCPNT+ZZ
	PUSHJ	%17,APTML
	LDB	%02,[POINT 6,0(%10),17]
	ADDI	%02,OQTTBL
	PUSHJ	%17,QSAML
	JUMPE	%03,OPSCA1
	AOJA	%01,PSEML

DESML:					;DESCEND ML
	HLRZ	%10,OPCPNT+ZZ		;OP PNTR
	JUMPE	%10,SIOPML		;SET INITIAL OP PNTR ML
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%10,[POINT 6,0(%10),5]
	ADDI	%10,1
	HLRS	OPCPNT+ZZ		;OP PNTR
	ADDB	%10,OPCPNT+ZZ		;OP PNTR
	HRLM	%10,OPCPNT+ZZ		;OP PNTR
EXIMLP:	JRST	EXIML			;EXIT ML
PHCML:					;PACK HOL CHAR ML
	CAIN	%14,TAB
	MOVEI	%14,-27			;ASCII SPACE(40) - ASCII TAB(11)
	MOVEI	%00," "(%14)
	IDPB	%00,HBUIND+ZZ
	LDB	%03,[POINT 5,HBUIND+ZZ,4]
	JUMPN	%03,SETTRU
	AOJA	%01,PSEML
DPADD:					;ADD TO MP AC FIN ML
	ADDB	%06,MAC1+ZZ		;MP AC 1
DPADD1:	JFCL	17,.+1
	ADDB	%07,MAC2+ZZ		;MP AC 2
	JFCL	02,.+2
	POPJ	%17,
	AOS	%06,MAC1+ZZ		;MP AC 1
	POPJ	%17,

CDAAML:					;CONV DIGIT AND ADV ML
CDAAM1:	MOVEI	%10,^D10		;CONST BASE BOX
	CAIG	%10,-N0(%14)
	JRST	EXIML			;EXIT ML
	AOS	NDISCA+ZZ		;NUM DIGITS SCANN
	MOVE	%06,MAC1+ZZ		;MP AC 1
	TLNE	%06,760000
	JRST	CDAAM3
	AOS	DUSCNT+ZZ		;DIGITS USED CN
	MOVE	%07,MAC2+ZZ		;MP AC 2
	ASHC	%06,3
	MOVEM	%06,MAC1+ZZ		;MP AC 1
	MOVEM	%07,MAC2+ZZ		;MP AC 2
	ASHC	%06,-2
	CAIN	%10,^D10
	PUSHJ	%17,DPADD		;ADD TO MP AC FIN ML
	MOVEI	%07,-N0(%14)
	PUSHJ	%17,DPADD1
CDAAM3:	PUSHJ	%17,NCHML
	JRST	CDAAM1
ASCML:					;ASCEND ML
	HLRZ	%10,OPCPNT+ZZ		;OP PNTR
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%10,[POINT 12,0(%10),17]
	JUMPE	%10,SOPML		;SET OP PNTR ML
	TRO	%10,640000
	TLOA	%10,0(%10)
SIOPML:					;SET INITIAL OP PNTR ML
	MOVE	%10,[XWD 640001,640001]	;INITIAL OP PNTR
SOPML:					;SET OP PNTR ML
	MOVEM	%10,OPCPNT+ZZ		;OP PNTR
	JRST	EXIML			;EXIT ML

SSCML:					;SUBORD SCAN ML
	HLRZ	%10,OPCPNT+ZZ		;OP PNTR
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%10,[POINT 6,0(%10),35]
	HRRZ	%01,SSATBL(%10)		;SUBORD SCAN ADR TB
	JRST	PSEML			;POP SETUP ML

OSRML:					;ORDER SUBORDS ROLL ML
	POP	%05,%10
	MOVEI	%02,SUDROL		;SUBORDS ROLL
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	MOVEI	%07,377777
	MOVSI	%06,(CAMG %10,%00)
	PUSHJ	%17,OROML		;ORDER ROLL ML
	PUSH	%05,@BOTTOM(%02)
	SOS	BOTTOM(%02)		;BOTTOM
	AOJA	%01,PSEML
OERML0:					;ORDER ERRORS ML
	PUSH	%17,NEXMLP
OERML:	MOVEI	%02,ERRROL		;ERROR ROLL
	MOVSI	%07,7777
	MOVSI	%06,(CAML %10,%00)
OROML:					;ORDER ROLL ML
	MOVE	%11,TOPS(%02)		;TOPS
	SUB	%11,BOTTOM(%02)		;BOTTOM
	MOVE	%12,BOTTOM(%02)		;BOTTOM
	MOVE	%10,0(%12)

OROML1:	AOJGE	%11,POPOUT
	MOVE	%00,-1(%12)
	AND	%10,%07
	AND	%00,%07
	XCT	%06
	POPJ	%17,
	MOVE	%10,-1(%12)
	EXCH	%10,0(%12)
	MOVEM	%10,-1(%12)
	SOJA	%12,OROML1

OGRML:					;OP GEN RUN ML
	TDZA	%02,%02
REDIML:					;REL DISP ML
	MOVEI	%02,RELDST-OGATBL-3
	POP	%05,%10
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	ADD	%02,0(%10)
	ANDI	%02,007777		;DISPL MASK
	HRRZ	%01,OGATBL(%02)		;OP GEN ADR TBL
	JRST	PSEML			;POP SETUP ML

GRUML:					;GEN RUN ML
	LDB	%10,[POINT 5,0(%05),23]	;GEN PNTR HD BYTE
	SKIPGE	%10		;IS ROLL OUT OF RANGE "22A"
	JRST	SYSERR
	CAILE	%10,APNROL
	JRST	SYSERR
	HLRZ	%01,PGATBL-RORBAS(%10)	;PNTR GEN ADR TBL
	JRST	PSEML			;POP SETUP ML

SYSERR:				;SYSTEM ERROR
	HRRZI	%02,M17QT	;SYSTEM ERROR - ROLL OUT OF RANGE
	JRST	LCFML		;LAST COLUMN FAIL ML
BOSML:					;BINARY ORDER SELECT ML

	MOVE	%06,-1(%05)
	MOVE	%07,0(%05)
	ANDI	%06,377777
	ANDI	%07,377777
	CAMG	%06,%07
	AOJA	%01,PSEML
	MOVE	%06,-1(%05)
	EXCH	%06,0(%05)
	MOVEM	%06,-1(%05)
	SETCMM	-2(%05)
	AOJA	%01,PSEML
	XWD	RPNGEN,RPNGEN	;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
PGATBL:				;PNTR GEN ADR TBL
	XWD	EXIT,0
OGATBL:					;OP GEN ADR TBL
	XWD	RPNGEN,XORGEN	;REG PNTR GEN,XOR GEN
	XWD	CPNGEN,ORGEN	;CONST PNTR GEN,OR GEN
	XWD	CPNGEN,ANDGEN	;CONST PNTR GEN,AND GEN
	XWD	CPNGEN,RGFNLI	;CONST PNTR GEN,REL GEN FOR
	XWD	CPNGEN,RGFNLI	;CONST PNTR GEN, NOT LOGICAL IF
	XWD	CPNGEN,RGFNLI	;CONST PNTR GEN,(DITTG
	XWD	CPNGEN,ASUGEN	;CONST PNTR GEN,ADD SUB GEN
	XWD	CPNGEN,MPYGEN	;CONST PNTR GEN,MPY GEN
	XWD	CPNGEN,DIVGEN	;CONST PNTR GEN,DIV GEN
	XWD	VPNGEN,EXPGEN	;VAR PNTR GEN,EXPON GEN
SSATBL:					;SUBORD SCAN ADR TBL
	XWD	VPNGEN,SUSCAN	;VAR PNTR GEN,SUBEXP SCAN
	XWD	VPNGEN,LUNSCA	;VAR PNTR GEN,LOGICAL UNARY SCAN
	XWD	VPNGEN,ELESCA	;VAR PNTR GEN,ELEMENT SCAN
	XWD	ARPGEN,EQVGEN	;ARRAY REF PNTR GEN,EQV GEN
	XWD	FRPGEN,0	;FUNC REF PNTR GEN,0
	XWD	TPNGEN,SSUSCA	;TEMP PNTR GEN,SIGNED SUBEXP SCAN
RELDST:					;RELATIONAL DISP TBL
	XWD	TPNGEN,EQNEGE	;TEMP PNTR GEN,EQ NE GEN
	XWD	SUBGEN,GTLTGE	;SUBEXP GEN,GT LT GEN
	XWD	VPNGEN,GELEGE	;VAR PNTR GEN,GE LE GEN
	OP	POC
	MOVE	%10,INSTBL(%02)
	PUSHJ	%17,P1OCML		;PUT 10 ON CODE ROLL ML
	AOJA	%01,PSEML			;POP SETUP ML

	OP	BRI
	MOVE	%12,INSTBL(%02)
	MOVE	%07,0(%05)
	MOVEI	%11,NEXML		;NEXT ML
	JRST	BARFML			;BUILD ABS REF FIN ML

	OP	BAK
	SKIPA	%10,(%05)

	OP	BAI
	POP	%05,%10
	LDB	%07,[POINT 4,INSTBL(%02),^L<Z 1,>]
	ADD	%07,[7070001]
	PUSH	%05,%07
	PUSH	%05,%10
	JRST	BUIML			;BUILD ML

	OP	BLK
BLKML:	HLLZ	%06,INSTBL(%02)
	PUSH	%05,%06
	MOVE	%06,@INSTBL(%02)
	MOVEM	%06,SYMBOL+ZZ		;SYMBOL
	MOVEI	%02,BLKPL			;BLK PL
	JRST	JSBML			;JSB ML
	OP	BTY
	JSP	%11,PTMML		;PNTR TYPE MOD ML

BINIML:	POP	%05,%02

	OP	BIN
	MOVE	%00,-1(%05)
	EXCH	%00,0(%05)
	PUSH	%05,%00
	JRST	BUIML			;BUILD ML

	OP	BTK
	JSP	%11,PTMML		;PNTR TYPE MOD ML

BIKIML:	POP	%05,%02

	OP	BIK
	PUSH	%05,-1(%05)
	PUSH	%05,-1(%05)
	MOVE	%00,0(%05)

BUIML:					;BUILD ML
	MOVE	%02,INSTBL(%02)
	TLNN	%02,777777
	JUMPN	%02,JSBML			;JSB ML
	TRNE	%02,777777
	JRST	BBSLML			;BUILD BY SR LINK ML
	MOVM	%06,%02
	HRRI	%02,BUIINS
	SKIPGE	%02
	MOVEI	%02,DOUBUI
	EXCH	%06,-1(%05)
	EXCH	%06,0(%05)
	ANDCMI	%06,400000
	PUSH	%05,%06
	JRST	JSBML			;JSB ML
BBSLML:					;BUILD BY SR LINK ML
	MOVE	%07,INSTBL+.PSHJ1
	EXCH	%07,-1(%05)
	SUBI	%07,1
	ANDI	%07,17
	TRNN	%02,77
	LSH	%07,6
	OR	%07,%02
	MOVEM	%07,SYMBOL+ZZ		;SYMBOL
	MOVEI	%02,BSSLIN		;BUILD SYS SR LINK
	JRST	JSBML			;JSB ML

SGEML:					;SCALE GEN ML
	POP	%05,%12
	POP	%05,%06
	MOVE	%07,-1(%05)
	JRST	BARML			;BUILD ABS REF ML
PTMML:					;PNTR TYPE MOD ML
	HRLOI	%10,%05
PTMML1:	TRC	%10,-1
	LDB	%06,[POINT 3,@%10,2]
	HLLZ	%00,TSEMAT(%06)		;TYPE SELECTION MATRIX
	TLZ	%00,77
	OR	%00,[Z PTTBL+1(%10)]
	LDB	%06,%00
	JUMPE	%06,PTMML1
	ADDI	%02,-1(%06)
	JRST	1(%11)

PTTBL:					;PNTR TYPE TBL
	OCT	000011211122
	OCT	000011200034

BFIML:					;BUILD FINAL ML
	POP	%05,%06			;ADDRESS
	POP	%05,%07			;REGISTER
	POP	%05,%12			;INSTRUCTION
	XORI	%06,070000		;CLEAR ROLL NUMBER FIELD IF REG PNTR
	TRNN	%06,370000		;DOES IT LOOK LIKE A REG PNTR ?
	TLNN	%06,7			;YES,IS IT REALLY A REG OR JUST A CONSTANT
	SOJA	%07,CAMOCM		;NO, NOT A REG - CONSTRUCT AND MOVE ON CODE ROLL
	TRZN	%06,400000		;SECOND INSTRUCTION OF A DOUBLE BUILD ?
	SUBI	%06,1			;NO,CORRECT OFFSET
BARML:					;BUILD ABS REF ML
	HRR	%12,%06			;PUT ADDRESS INTO INSTR. E FIELD
BARFML:					;BUILD ABS REF FIN ML
	SUBI	%07,1			;CORRECT REGISTER OFFSET
	DPB	%07,[POINT 4,%12,12]	;INST AC BYTE
	MOVE	%10,INSTBL+ABSINS
BARFMX:	PUSHJ	%17,P1OCML
BARFMY:	MOVE	%10,%12
	PUSH	%17,%11
P1OCML:	MOVEI	%02,CODROL
	JRST	P1ORML
CAMOCM:					;CONSTRUCT AND MOVE ON CODE ML
	XORI	%06,070000
	HRR	%12,%06
	DPB	%07,[POINT 4,%12,12]	;INST AC BYTE
	JRST	BARFMY

ITIDFM:					;ISOLATE TYPE IN DISPL FIELD ML
	LDB	%00,[POINT 3,0(%05),2]
	MOVEM	%00,0(%05)
	AOJA	%01,PSEML

B2RML:					;BUILD 2ND REF ML
	POP	%05,%12
	HLLO	%12,INSTBL(%12)
	TLO	%12,37
	MOVE	%07,@BOTTOM+CODROL	;BOTTOM
	TLZ	%07,777000
	TRNE	%07,400000
	AOJA	%07,B2RML1		;$1
	TRNE	%07,770000
	TROA	%07,400000
	AOJA	%07,B2RML1		;$1
	ADD	%12,%07
	AOJA	%12,BARFMY		;PUT 10 ON ROLL ML

B2RML1:	ADD	%12,%07
	MOVE	%10,INSTBL+ABSINS
	AOJA	%12,BARFMX
MFPML:					;MAKE FL POWER ML
	LDB	%06,[POINT 8,0(%05),8]
	SUBI	%06,201
	MOVEM	%06,0(%05)
	JRST	ETRML			;EXIT TRUE ML
FPO2CM:					;FX POWER OF 2 CHECK ML
	MOVE	%06,DAT1+ZZ		;DATA 1
	JUMPE	%06,EFAML			;EXIT FALSE ML
	SETZB	%07,%00
FPO2C1:	LSHC	%06,-1
	CAIL	%07,0
	AOJA	%00,FPO2C1		;$1
	JUMPN	%06,EFAML			;EXIT FALSE ML
	PUSH	%05,%00
	JRST	ETRML			;EXIT TRUE ML
BSLML:					;BUILD SWITCHED LOAD ML
	POP	%05,%06
	MOVE	%06,INSTBL(%06)
	MOVEM	%06,-3(%05)
	HLRZS	0(%05)
BIRML:					;BUILD IMMED REF ML
	POP	%05,%06
	POP	%05,%00
	POP	%05,%07
	POP	%05,%12
	JRST	BARML			;BUILD ABS REF ML
IITML:					;INSERT INST TAG ML
	POP	%05,%00
	SUBI	%00,1
	DPB	%00,[POINT 4,-3(%05),17];INST TAG BYTE
	AOJA	%01,PSEML

RREML:					;REGS RESET ML
	HRRZ	%06,TOPS+REGROL		;TOPS
	HRLI	%06,1(%06)
	SETZM	1(%06)
	ADDI	%06,2
	BLT	%06,@BOTTOM+REGROL
	AOJA	%01,PSEML
COCCO0:	LSH	%06,3
	TDOA	%06,%00

COCCON:	TDZA	%06,%06

	PUSHJ	%17,NCHML		;NEXT CHAR ML
	MOVEI	%00,-N0(%14)
	CAIG	%00,7
	JRST	COCCO0			;$0
	SKIPE	MCOFLA+ZZ		;MINUS CONST FLAG
	MOVNS	%06
	MOVEM 	%06,DAT1+ZZ		;DATA 1
	JRST	EFAML			;EXIT FALSE ML


BTSML:					;BINARY TYPE SELECT ML
	LDB	%06,[POINT 3,-1(%05),2]
	LDB	%07,[POINT 3,-2(%05),2]
	CAIL	%06,6
	CAIGE	%07,6
	JRST	BTSML1			;$1
	CAME	%06,%07
	TDZA	%03,%03
BTSML1:	SETO	%03,
	MOVSI	%00,770000
	AND	%00,TSEMAT(%06)		;TYPE SELECTION MA
	OR	%00,[POINT 3,TSEMAT(%07),35]
	POP	%05,%10
	TLZ	%10,700000
	LDB	%06,%00
	LSHC	%06,-3
	OR	%10,%07
	PUSH	%05,%10
	PUSH	%05,%07
	AOJA	%01,PSEML
ITSML:					;INTRINSIC TYPE SET ML
	MOVE	%06,CREPNT+ZZ		;AC6<-LFUTAB POINTER
	ANDI	%06,7777		;AC6<-DISPLACEMENT OF ENTRY
	LSH	%06,1		;AC6<-DISPLACEMENT * GROUP SIZE ;"23AI"
	MOVE	%07,0(%05)		;AC7<-W0<-GSPROL POINTER ;"23II"
	TLZ	%07,700000		;ASSUME TYPE INTEGER ;"23II"
	CAIL	%06,EOILIB-LFUTAB	;END OF INT LIBS ;"23II"
					;LINE DELETED ;"23II"
	TLO	%07,200000		;IF NOT AN INTEGER TRY REAL ;"23II"
	CAIL	%06,EORLIB-LFUTAB	;END OF REAL LIBS
	TLO	%07,600000		;IF NOT REAL TRY DBL PREC ;"23II"
	CAIL	%06,EODLIB-LFUTAB	;END OF DBL LIBS
	TLO	%07,700000		;IF NOT DBL PREC THEN COMPLEX ;"23II"
	MOVEM	%07,0(%05)		;W0<-GSPROL POINTER W/PROPER TYPE ;"23II"
	AOJA	%01,PSEML

IFNDEF HARDFL,<							; *EJG* 06/25/76
PMNML:	MOVE	%07,DAT1+ZZ		;HIGH ORDER WORD IN AC
	DFN	%07,DAT2+ZZ		;NEGATE DOUBLE WORD
	MOVEM	%07,DAT1+ZZ		;STORE HIGH ORDER WORD
	AOJA	%01,PSEML		;RETURN IF NEGATIVE
>								; *EJG* 06/25/76
IFDEF HARDFL,<							; *EJG* 06/25/76
PMNML:	DMOVN	%06,DAT1+ZZ		;DOUBLE NEGATIVE	; *EJG* 06/25/76
	DMOVEM	%06,DAT1+ZZ					; *EJG* 06/25/76
	AOJA	%01,PSEML					; *EJG* 06/25/76
>								; *EJG* 06/25/76
PMN6ML:	SKIPE	DAT2+ZZ		;LOW ORDER WORD ZERO ?
	AOS	DAT1+ZZ		;NO,INCREMENT HIGH ORDER WORD
PMNCML:	MOVNS	DAT1+ZZ		;NEGATE
	MOVNS	DAT2+ZZ		;NEGATE
	AOJA	%01,PSEML		;RETURN

REGSML:				;REGISTER SEARCH ML
	HLRZ	%10,EOPPNT+ZZ	;GET LH OF OP PNTR
	ANDI	%10,700000	;ISOLATE TYPE
	MOVEI	%07,TSAREG	;ASSUME SINGLE PRECISION
	CAIL	%10,600000	;DOUBLE PRECISION OR COMPLEX?
	HRROI	%07,TDAREG	;YES, SET TOP REGISTER AND FLAG
	MOVE	%06,TOPS+REGROL	;POINT TO TOP OF REGROL
	HRLI	%06,(Z (%02))	;SET FOR INDIRECT THRU %02
	MOVEI	%02,3		;SET TO REGISTER TWO	;"21V"
REGSM1:	SKIPE	@%06		;IS THIS REGISTER AVAILABLE?
	JRST	REGSM2		;NO, TEST FOR END
	JUMPG	%07,REGSM3	;YES, TEST COMPLETED IF SINGLE
IFNDEF	FASTDP,
<	TRNN	%02,1		;DOUBLE, IS IT AN EVEN REG?
	JRST	REGSM2		;NO, DON'T USE IT
>
	ADDI	%02,1		;YES, TAKE A PEEK AT ITS MATE
	SKIPN	@%06		;SKIP IF NOT AVAILABLE
	SOJA	%02,REGSM3	;OK, FINISH UP
REGSM2:	CAIGE	%02,1(%07)	;REGISTER IN USE, TEST FOR END
	AOJA	%02,REGSM1	;NOT THE END, TEST NEXT
	MOVEI	%02,1(%07)	;END, POINT TO TOP ARITH REG
REGSM3:	MOVEI	%06,-2(%02)	;COUNT REGS (REG2=1)	;"21V"
	TRO	%02,<REGROL>B23	;SET POINTER TO REGROL
	HRL	%02,%10		;SET TYPE POINTER
	TLO	%02,7		;MARK IT AS A REGISTER
	PUSH	%05,%02		;PLACE ON TOP OF WORK ROLL
	CAMG	%06,REGCNT+ZZ	;HIGHEST REG SO FAR ?	;"21V"
	AOJA	%01,PSEML	;NO, EXIT
	CAIL	%10,600000	;DOUBLE REGISTER ?	;"21V"
	AOS	%06		;YES, INDICATE HIGHEST REG	;"21V"
	MOVEM	%06,REGCNT+ZZ	;SAVE FOR POSTERITY	;"21V"
	AOJA	%01,PSEML	;EXIT	;"21V"


TSAML:					;TEMP STATUS ADVANCE ML
	MOVEI	%10,WORROL
	SUBI	%10,-1(%05)
	HRLS	%10
	HRRI	%10,WORROL		;WORK ROLL
	MOVE	%06,0(%05)
TSAML1:	HRRZ	%07,-1(%05)
	XOR	%07,0(%10)
	TRZE	%07,777777
	JRST	TSAML2			;$2
	TLZ	%07,767777
	XOR	%07,%06
	MOVEM	%07,0(%10)
TSAML2:	AOBJN	%10,TSAML1		;$1
	AOJA	%01,PSEML
OCHML:					;OP CHECK ML
	MOVSI	%01,-12
	HRRI	%01,OQTTBL		;OP QT TBL
OCHML1:	MOVE	%02,%01
	PUSHJ	%17,QSAML		;QSA ML
	JUMPN	%03,EFAML			;EXIT FALSE ML
	AOBJN	%01,OCHML1		;$1
	JRST	ETRML			;EXIT TRUE ML

IIAEX1:	JSP	%11,RELML
	POP	%04,%00
	AOJA	%01,PSEML

MCAPML:	HLRZ	%00,0(%05)
	TRO	%00,CAPHEA
	MOVEM	%00,0(%05)
	AOJA	%01,PSEML

CBMOFF:	POP	%05,%00
	SUB	%00,0(%05)
	HLL	%00,1(%05)
	MOVEM	%00,0(%05)
	AOJA	%01,PSEML

GETOPC:					;GET OP CODE
	LDB	%10,[POINT 9,-3(%05),8]
	PUSH	%05,%10
	AOJA	%01,PSEML
RMEML0:					;$3
	SOS	BOTTOM(%02)
RMEML:					;REASSIGN MEMORY ML
				;2 LINES DELETED ;"23CC"
	MOVEI	%00,^D30		;"23CC"
	MOVE	%15,FLOORS		;ANCHOR+1
	SUB	%15,BOTTOM		;BOTTOM
	CAMG	%15,%00			;COMPARE GROUP SIZE
	JRST	PREMEM			;PRESS MEMORY
	MOVE	%07,BOTTOM(%02)		;BOTTOM
	SUB	%07,%00
	MOVE	%06,FLOORS		;ANCHOR+1
	HRL	%06,%06
	SUB	%06,%00
	BLT	%06,@%07
	HRRZ	%06,%02
	MOVNS	%00
RMEML2:	ADDM	%00,TOPS(%06)		;TOPS+1
	ADDM	%00,BOTTOM(%06)		;BOTTOMS+1
	ADDM	%00,ANCHOR(%06)		;ANCHORS+1
	SOJG	%06,RMEML2

P1ORML:					;PUT 10 ON ROLL ML
	AOS	%06,BOTTOM(%02)		;BOTTOM
	CAMLE	%06,FLOORS(%02)		;FLOORS
	JRST	RMEML0			;REASSIGN MEMORY ML $3
	MOVEM	%10,0(%06)
POPOUT:	POPJ	%17,
PREMEM:					;PRESS MEMORY
	PUSH	%17,%10
	PUSH	%17,%11
PREME8:	MOVEI	%06,LRONUM		;LAST ROLL NUMBER
PREME1:	HRRZ	%10,FLOORS(%06)		;FLOORS
	HRRZ	%07,BOTTOM(%06)		;BOTTOM
	JUMPLE	%06,PREME4
	CAML	%07,%10
	SOJA	%06,PREME1		;$1
	MOVE	%11,10
	SUB	%11,%07
	ADDM	%11,BOTTOM(%06)		;BOTTOM
	ADDM	%11,TOPS(%06)		;TOPS
	ADD	%11,ANCHOR(%06)		;ANCHOR
	EXCH	%11,ANCHOR(%06)		;ANCHOR
PREME3:	CAMG	%07,%11
	SOJA	%06,PREME1		;$1
	MOVE	%15,0(%07)		;"23CC"
	MOVEM	%15,0(%10)		;"23CC"
	SUBI	%07,1
	SOJA	%10,PREME3		;$3

PREME4:	SUB	%10,%07
	CAMG	%10,%00
	JRST	PREME5			;$5
	POP	%17,%11
	POP	%17,%10
	JRST	P1ORML

PREME5:
IFNDEF	FILE0,
<
	PUSHJ	%17,PANIC		;TRY TO GET 1K MORE CORE
	MOVEI	%10,2000		;ADD 1K TO LAST FLOOR
	ADDM	%10,FLOORS+LRONUM
	JRST	PREME8
>
IFDEF	FILE0,
<
	EXIT
>
	IFDEF	PDP6,
	<
FCMML:					;FL CONST MAKER ML
	MOVEI	%12,IBIEXP		;INIT BINARY EXPON
	MOVE	%06,MAC1+ZZ		;MP AC 1
	MOVE	%07,MAC2+ZZ		;MP AC 2
	JUMPG	%06,FCMML1		;$1
	EXCH	%06,%07
	SETZ	%12,
	JUMPLE	%06,FCFML
	MOVEI	%12,IBIEXP-^D35

FCMML1:	TLNE	%06,200000
	JRST	FCMML2
	ASHC	%06,1
	SOJA	%12,FCMML1	;DECREMENT BIN EXP VALUE

FCMML2:	MOVM	%00,EXPONE+ZZ		;EXPONE
	CAILE	%00,MDEEXP		;MAX DEC EXPON
	JRST	FCMML3			;SET FL OVFLO ML
	MOVE	%10,EXPA+ZZ		;EXPONEN
	JUMPE	%10,AFCPML		;ADJ FL CONST POS ML
	AOJE	%10,AFCNML		;ADJ FL CONST NEG ML
FCMML3:					;SET FL OVFLO ML
	SKIPGE	EXPA+ZZ
	TDZA	%06,%06
	HRLOI	%06,377777		;LARGEST FLOATING CONST
	MOVEM	%06,MAC1+ZZ
	MOVEM	%06,MAC2+ZZ
	MOVEI	%12,400
	JRST	FCFML
AFCPML:					;ADJ FL CONST POS ML
	MOVEM	%06,MAC1+ZZ		;MP AC 1
	MOVEM	%07,MAC2+ZZ		;MP AC 2
AFCPM1:	SOJL	%00,FCMFML		;FL CONST MAKER FIN ML
	ASHC	%06,-2
	ADDI	%12,3
	PUSHJ	%17,DPADD		;ADD TO MP AC FIN ML
	JUMPGE	%06,AFCPM1		;$1
	ASHC	%06,-1
	TLZ	%06,400000
	TLZ	%07,400000
	AOJA	%12,AFCPML

AFCNM1:	CAMGE	%06,HORTEN		;HIGH ORDER TEN
	JRST	AFCNM2			;$2
	ASHC	%06,-1
	ADDI	%12,1
AFCNM2:	MOVE	%10,%07
	DIV	%06,HORTEN		;HIGH ORDER TEN
	DIV	%07,HORTEN		;HIGH ORDER TEN
	SUBI	%12,4
AFCNML:	SOJGE	%00,AFCNM1

FCMFML:					;FL CONST MAKER FIN ML
	JFCL	17,.+1			;CLEAR FLAGS
	MOVEI	%00,200			;PDP-6 ROUNDING BIT
	SKIPE	PDPSWZ			;PDP-10?
	MOVEI	%00,200<-8		;YES, GET PDP-10 ROUNDING BIT
	ADD	%07,%00			;ROUND	
	JFCL	02,.+2	
	JRST	FCMFM2			;$2
	AOJGE	%06,FCMFM2		;$2
	ASHC	%06,-1
	ADDI	%12,1
FCMFM2:	ASHC	%06,-8
	DPB	%12,[POINT 8,%06,8]	;STORE EXPONENT
	CAMLE	%07,[XWD 200000,0]	;SHOULD WE ROUND?
	ADDI	%06,1(%03)		;YES, IF SINGLE

	SKIPN	PDPSWZ
	JRST	FCMFM3

	JUMPE	%03,FCMFM3		;BRANCH IF SINGLE
	LSH	%07,-8			;MAKE ROOM FOR EXPONENT
	HRREI	%10,-^D27(%12)
	SKIPL	%10
	SKIPN	%07			;OR AC+1 IS ZERO,
	TDZA	%07,%07			;SET TO ZERO
	DPB	%10,[POINT 8,%07,8]	;OTHERWISE STORE EXPONENT

FCMFM3:	MOVEM	%06,MAC1+ZZ		;MP AC 1
	MOVEM	%07,MAC2+ZZ		;MP AC 2
FCFML:					;FL CONST FINAL ML
	MOVMM	%12,EXPONE+ZZ		;EXPONE
	AOJA	%01,PSEML
	
	>
	IFNDEF	PDP6,

<		;FLOATING POINT CONSTANT GENERATOR
		;CONVERTS AN INTEGER CONSTANT TO A DOUBLE PRECISION
		;FLOATING POINT CONSTANT

FCMML:
	MOVEM	%01,AC1SAV+ZZ	;SAVE AC1
	MOVEI	%12,276	;PICKUP MAX BINARY EXPONENT
	MOVE	%07,MAC2+ZZ	;PICKUP CONSTANT
	SKIPLE	%06,MAC1+ZZ	;LOAD  6 AND SKIP IF LESS 0
	JRST	FCMML0		;NOT ZERO
	MOVEI	%12,200	;RESET EXPONENT
	JUMPE	%07,FCFML	;JUMP IF BOTH = 0
	ASHC	%06,^D27		;SHIF INTO HIGH
	MOVEI	%12,243
FCMML0:	TLNN	%06,777000	;BITS IN EXPONENT FIELD ?
	JRST	FCMML1		;NO, CONTINUE
	ASHC	%06,-1		;SHIFT RIGHT ONE
	AOJA	%12,FCMML0	;KEEP TRACK OF EXPONENT
FCMML1:	TLNE	%06,400		;BIT 9 = 1
	JRST	FCMML2	;YES
	ASHC	%06,1
	SOJA	%12,FCMML1	;DECREMENT BINARY EXP
FCMML2:	DPB	%12,[POINT 8,%06,8];DEPOSIT EXPONENT IN 06
IFNDEF HARDFL,<							; *EJG* 06/25/76
	MOVE	%10,%07		;SET UP LOW ORDER EXP
	MOVEI	%07,0
	LSH	%10,-8		;CLEAR OUT BITS

	SUBI	%12,^D27	;REDUCE EXP
	DPB	%12,[POINT 8,%10,8];DEPOSIT EXP
	FADL	%06,%10		;NORMALIZE RESULT
>								; *EJG* 06/25/76
IFDEF HARDFL,<							; *EJG* 06/25/76
;;;;;	LSH	%07,-1	; ** SIGH, FLUSHED THIS LOSING LINE **	; *EJG* 01/16/78
>								; *EJG* 06/25/76
	MOVM	%01,EXPONE+ZZ	;GET MAGNITUDE OF DECIMAL EXP
	CAILE	%01,^D76	;GREATER THAN MAX
	JRST	FCMML3		;YES OVERFLOW ERROR
	JUMPE	%01,FCMFM4	;EXP = 0?


	CAIG	%01,^D38	;EXP GREATER 38
	JRST 	FCMML4		;NO
	SUBI	%01,^D38	;REDUCE EXP BY 38
	MOVEM	%01,EXPSAV+ZZ	;SAVE DIFFERENCE
	MOVEI	%01,^D38	;SET FOR FIRST MULT OR DIV
FCMML4:	LSH	%01,1
	MOVE	%00,TENS(%01)	;LOOKUP POWER OF TEN


	MOVE	%01,TENS+1(%01)	;LOAD IN 00 AND 01


	MOVE	%10,EXPA+ZZ	;GET EXPONENT SIGN
	JUMPE	%10,AFCPML	;POS EXP
	AOJE	%10,AFCNML	;NEG EXP
FCMML3:
	MOVEI	%12,400		;SET FOR OVERFLOW
	SKIPGE	EXPA+ZZ	;IS EXPONENT NEGATIVE
	TDZA	%06,%06	;YES ZERO ON UNDERFLOW
	HRLOI	%06,377777	;NO MAX NUMBER ON OVERFLOW
	MOVEM	%06,MAC1+ZZ	;DAT1
	MOVEM	%06,MAC2+ZZ	;DAT2
	JRST	FCFML
			;DOUBLE FLOATING MULTIPLY
			;BY POWER OF TEN IN 00 AND 01

			;MULTIPLICAND IN 06 AND 07


AFCPML:
IFNDEF HARDFL,<							; *EJG* 06/25/76
	MOVE	%10,%06	;LOAD 10 WITH HI ORDER PART
	JFCL	17,.+1		;CLEAR FLAGS
	FMPR	%10,%01		;FIRST X PROD TO 10
	JFCL	17,.+1
	FMPR	%07,%00		;NEXT X PROD TO 07
	JFCL	17,.+1
	UFA	%07,%10		;ADD X PRODUCTS
	JFCL	17,.+1
	FMPL	%06,%00		;HI PROD TO 06
	JFCL	10,FCMML3	;OVERFLOW ERROR
	UFA	%07,%10		;ADD LO BITS INTO 10
	JFCL	17,.+1

	FADL	%06,%10		;NORMALIZE
>								; *EJG* 06/25/76
IFDEF HARDFL,<							; *EJG* 06/25/76
	JFCL	17,.+1		;CLEAR FLAGS			; *EJG* 06/25/76
	DFMP	%06,%00						; *EJG* 06/25/76
>								; *EJG* 06/25/76
	JFCL	10,FCMML3	;OVERFLOW ERROR

	JRST	FCMFM3
			;DOUBLE FLOATING DIVIDE
			;BY POWER OF TEN IN 00 AND 01
			;DIVIDEND IN 06 AND 07
AFCNML:
	JFCL	17,.+1	;CLEAR FLAGS
IFNDEF HARDFL,<							; *EJG* 06/25/76
	FDVL	%06,%00		;DIVIDE HI ORDER ARGS
	MOVN	%10,%06		;NEGATE RESULT TO 10
	JFCL	10,FCMML3	;OVERFLOW OR UNDERFLOW ERROR
	FMPR	%10,%01		;MULT BY LO ORDER BITS
	JFCL	10,.+2	;IF OVERFLOW THEN CLEAR 10
	CAIA	%10,0		;FAST SKIP
	MOVEI	%10,0		;CLEAR 10
	UFA	%07,%10		;ADD LO PROD TO 10
	JFCL	10,.+2
	CAIA	%10,0
	MOVEI	%10,0		;CLEAR 10 IF OVERFLOW
	FDVR	%10,%00		;DIV LO BITS BY DIVISOR
	JFCL	10,.+2
	CAIA	%10,0
	MOVEI	%10,0
	FADL	%06,%10		;NORMALIZE FINAL ANS
>								; *EJG* 06/25/76
IFDEF HARDFL,<							; *EJG* 06/25/76
	DFDV	%06,%00						; *EJG* 06/25/76
>								; *EJG* 06/25/76
	JFCL	10,FCMML3	;ERROR IF OVERFLOW NOW
FCMFM3:				;CHECK FOR XTRA MULT OR DIV
	MOVE	%01,EXPSAV+ZZ	;GET ANY SAVED EXPONENT
	JUMPE	%01,FCMFM4	;NONE LEFT
	SETZM	EXPSAV+ZZ	;CLEAR SAVE AREA
	JRST	FCMML4		;GO ONE MORE TIME
FCMFM4:
	MOVEM	%06,MAC1+ZZ
	MOVEM	%07,MAC2+ZZ	;SAVING ANS
FCFML:
	MOVMM	%12,EXPONE+ZZ	;EXPONENT
	MOVE	%01,AC1SAV+ZZ	;RESTORE AC1
	AOJA	%01,PSEML	;RETURN

TENS:			;POWER OF TEN TABLE IN DOUBLE PRECISION
	201400000000	;D00
	0
	204500000000	;D01
	0
	207620000000	;D02
	0	;
	212764000000	;D03
	0
	216470400000	;D04
	0
	221606500000	;D05
	0
	224750220000	;D06
	0
	230461132000	;D07
	0
	233575360400	;D08
	0
	236734654500	;D09
	0
	242452013710	;D10
	0
	245564416672	;D11
	0
IFNDEF HARDFL,<							; *EJG* 06/25/76
	250721522450	;D12
	215400000000
	254443023471	;D13
	221240000000
	257553630407	;D14
	224510000000
	262706576511	;D15
	227432000000
	266434157115	;D16
	233760200000
	271543212741	;D17
	236354240000
	274674055531	;D18
	241647310000
	300425434430	;D19
	245110475000
	303532743536	;D20
	250132614200
	306661534465	;D21
	253561357240
	312417031701	;D22
	257446725444
	315522640261	;D23
	262760512755
	320647410336	;D24
	265354635550
        324410545213	;D25
	271024002441
	327512676455	;D26
	274631003151
	332635456171	;D27
	277177204004
	336402374713	;D28
	303617422402
	341503074076	;D29
	306563327103	;
	344623713116	;D30
	311320214724
	347770675742	;D31
	314004260111
	353473426555	;D32
	320202556055
	356612334310	;D33
	323443311471
	361755023372	;D34
	326554174007
	365464114134	;D35
	332543515404	;
	370601137163	;D36
	335674440705
	373741367020	;D37
	340653551067
	377454732312	;D38
	344413241542
>								; *EJG* 06/25/76
IFDEF HARDFL,<							; *EJG* 06/25/76
	250721522450	;D12					; *EJG* 06/25/76
	200000000000						; *EJG* 06/25/76
	254443023471	;D13					; *EJG* 06/25/76
	120000000000						; *EJG* 06/25/76
	257553630407	;D14					; *EJG* 06/25/76
	244000000000						; *EJG* 06/25/76
	262706576511	;D15					; *EJG* 06/25/76
	215000000000						; *EJG* 06/25/76
	266434157115	;D16					; *EJG* 06/25/76
	370100000000						; *EJG* 06/25/76
	271543212741	;D17					; *EJG* 06/25/76
	166120000000						; *EJG* 06/25/76
	274674055531	;D18					; *EJG* 06/25/76
	323544000000						; *EJG* 06/25/76
	300425434430	;D19					; *EJG* 06/25/76
	044236400000						; *EJG* 06/25/76
	303532743536	;D20					; *EJG* 06/25/76
	055306100000						; *EJG* 06/25/76
	306661534465	;D21					; *EJG* 06/25/76
	270567520000						; *EJG* 06/25/76
	312417031701	;D22					; *EJG* 06/25/76
	223352622000						; *EJG* 06/25/76
	315522640261	;D23					; *EJG* 06/25/76
	370245366400						; *EJG* 06/25/76
	320647410336	;D24					; *EJG* 06/25/76
	166316664100						; *EJG* 06/25/76
	324410545213	;D25					; *EJG* 06/25/76
	012001220450						; *EJG* 06/25/76
	327512676455	;D26					; *EJG* 06/25/76
	314401464562						; *EJG* 06/25/76
	332635456171	;D27					; *EJG* 06/25/76
	077502001716						; *EJG* 06/25/76
	336402374713	;D28					; *EJG* 06/25/76
	307611201141						; *EJG* 06/25/76
	341503074076	;D29					; *EJG* 06/25/76
	271553441371						; *EJG* 06/25/76
	344623713116	;D30					; *EJG* 06/25/76
	150106351667						; *EJG* 06/25/76
	347770675742	;D31					; *EJG* 06/25/76
	002130044245						; *EJG* 06/25/76
	353473426555	;D32					; *EJG* 06/25/76
	101267026547						; *EJG* 06/25/76
	356612334310	;D33					; *EJG* 06/25/76
	221544634301						; *EJG* 06/25/76
	361755023372	;D34					; *EJG* 06/25/76
	266076003361						; *EJG* 06/25/76
	365464114134	;D35					; *EJG* 06/25/76
	261646602127						; *EJG* 06/25/76
	370601137163	;D36					; *EJG* 06/25/76
	336220342554						; *EJG* 06/25/76
	373741367020	;D37					; *EJG* 06/25/76
	325664433310						; *EJG* 06/25/76
	377454732312	;D38					; *EJG* 06/25/76
	205520661075						; *EJG* 06/25/76
>								; *EJG* 06/25/76
>
ECHML:					;EXPON CHECK ML
	MOVM	%06,0(%05)
	CAILE	%06,MAEFMP		;MAX ABS EXPON FOR MPY
	JRST	SETFAL			;EXIT FALSE ML
	MOVEI	%10,MOIEFM
ECHML1:	LSHC	%06,-1
	TLNE	%07,400000
	SOJL	%10,SETFAL
	JUMPN	%06,ECHML1		;$1
	JRST	SETTRU			;EXIT TRUE ML

IEAML:					;INTEGER EXPON ABSTRACT ML
	POP	%05,%06
	MOVEI	%07,^D34
IEAML1:	LSH	%06,1
	TLZN	%06,400000
	SOJA	%07,IEAML1		;$1
	MOVEM	%06,ISCBOX+ZZ		;INTEGER SCANER
	MOVEM	%07,IBICNT+ZZ		;INTEGER BITS CN
	AOJA	%01,PSEML

IFNDEF	$IMPL,
<
ICFCCS:	SKIPA	%06,%14
>
ICFSSE:	LDB	%06,[POINT 6,SYMBOL+ZZ,5]
	HRRZM	%06,IMPCLU+ZZ		;IMPLICIT C
	AOJA	%01,PSEML

SYMSC1:	MOVE	%07,[POINT 6,SYMBOL+ZZ]
SYMSC2:	TLNE	%07,770000
	IDPB	%14,%07
	PUSHJ	%17,NCHML
	TLNE	%14,LODKEY
	JRST	SYMSC2
	AOJA	%01,PSEML		;GET NEXT POP

IFNDEF	$CREF,
<
CRFML:					;CREF ML
IFNDEF	FILE0,				;"23B"
<	MOVE	%02,CARBUF		;"23D"
	TRZE	%02,1			;"23D"
	TRO	%16,HDRBIT		;"23D"
	MOVEM	%02,CARBUF		;"23D"
>					;"23B"
	POP	%05,%00			;GET TOP OF WORK ROLL
	HRREI	%02,CRFSYM-40		;ASSUME SYMBOL
	JUMPL	%00,CRFML3		;TEST FOR STATEMENT LABEL
CRFML1:	TRNE	%00,007700		;YES, PAD LEADING CHAR.
	JRST	CRFML2
	TRO	%00,N0
	ROT	%00,-6			;PUT "0" IN LEADING POSITION
	JRST	CRFML1
CRFML2:	TRO	%00,P			;APPEND "P"
	HRREI	%02,CRFSTA-40
CRFML3:	PUSHJ	%17,LSTOUT		;LIST IT
	MOVSI	%07,(POINT 6,%00,)	;SET BYTE POINTER
CRFML4:	ILDB	%02,%07			;GET A SIXBIT CHARACTER
	JUMPE	%02,CRFML5		;BRANCH IF END
	PUSHJ	%17,LSTOUT		;LIST IT
	TLNE	%07,770000		;TEST FOR END
	JRST	CRFML4			;NO, GET ANOTHER
CRFML5:	HRREI	%02,CRFSYM-40
	PUSHJ	%17,LSTOUT		;FLAG END
	AOJA	%01,PSEML

>

ST5RAD:
	SETZ	%10,
	MOVSI	%06,(POINT 6,0(%05),)
ST5RA2:	ILDB	%07,%06
	LDB	%07,[POINT 6,CSTAT(%07),8]
	JUMPE	%07,ST5RA3
	IMULI	%10,50
	ADD	%10,%07
	TLNE	%06,770000
	JRST	ST5RA2
ST5RA3:	MOVEM	%10,0(%05)
	AOJA	%01,PSEML

BTOBCD:	POP	%05,%06
	SETZ	%10,
BTOBC2:	IDIVI	%06,^D10
	ADDI	%07,N0
	LSHC	%07,-6
	JUMPN	%06,BTOBC2		;$2
	PUSH	%05,%10
	AOJA	%01,PSEML
PUNCH1:	SETZB	%06,%07
	MOVE	%11,TOPS+CODROL		;TOPS
PUNCH2:	CAML	%11,BOTTOM+CODROL
	AOJA	%01,PSEML
	SKIPE	DSTFLA+ZZ		;DATA STA FLAG
	JRST	PUNCH4			;$4
	SKIPE	PPEFLA+ZZ		;PUNCH PEEK FLAG
	SOJL	%06,PUNCH5
PUNCH3:	AOS	LOCCNT+ZZ		;LOC CNTR
PUNCH4:	MOVE	%00,1(%11)

IFNDEF	$CODE,
<
	TLNN	%16,ESWFLG
	PUSHJ	%17,PRICOD
>
	TLNN	%16,BINFLG
	PUSHJ	%17,BINOUT		;OUTBIN
	AOJA	%11,PUNCH2

PUNCH5:	SETZ	%06,
	SKIPE	%07
	SOJA	%07,PUNCH4		;$4
	HLLO	%00,1(%11)
	AOJN	%00,PUNCH3
	HRRZ	%00,1(%11)
	ANDI	%00,770000
	JUMPE	%00,PUNCH6		;$2
	CAIE	%00,600000
	CAIN	%00,310000
PUNCH6:	AOJA	%07,PUNCH4		;$4
	XORI	%00,500000
	JUMPN	%00,PUNCH4		;$4
	MOVE	%06,1(%11)
	ANDI	%06,077777
	JRST	PUNCH4			;$4

IFNDEF	$CODE,
<
PRICOD:					;PRINT CODE
	MOVSI	%10,(POINT 3,%00,)
PRICO1:	ILDB	%02,%10
	PUSHJ	%17,PRNML
	TLNE	%10,770000
	JRST	PRICO1
	MOVEI	%02,CRR
	JRST	PCHML
>
SSAML:					;STATUS SAVE ML
	MOVEM	%13,STAPSA+ZZ		;STATUS PSAV
	MOVEM	%14,STACSA+ZZ		;STATUS CSAV
	MOVE	%00,SSABLT
	BLT	%00,SSAEND+ZZ		;STATUS VARS SAVE EN
	MOVEM	%04,STAEXS+ZZ		;STATUS EXSAV
	MOVEM	%05,STAWKS+ZZ		;STATUS WKSAV
	HRRZI	%06,LRONUM		;LAST ROLL NUMBER
SSAML1:	HRRZ	%00,TOPS(%06)		;TOPS
	SUB	%00,ANCHOR(%06)		;ANCHOR
	HRLM	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	HRRZ	%00,BOTTOM(%06)		;BOTTOM
	SUB	%00,ANCHOR(%06)		;ANCHOR
	HRRM	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	SOJGE	%06,SSAML1		;$1
	AOJA	%01,PSEML

SSABLT:	XWD	ESTFLA+ZZ,SSATMP+ZZ
RELML:					;RELEASE ML
	MOVE	%13,STAPSA+ZZ		;STATUS PSAV
	MOVE	%14,STACSA+ZZ		;STATUS CSAV
	MOVS	%00,SSABLT
	BLT	%00,LTEPNT+ZZ		;LOCAL TEMP PNTR
	MOVE	%04,STAEXS+ZZ		;STATUS EXSAV
	MOVE	%05,STAWKS+ZZ		;STATUS WKSAV
	HRRZI	%06,LRONUM		;LAST ROLL NUMBER
RELML1:	HLRZ	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	CAIN	%06,ERRROL		;ERROR ROLL
	JRST	RELML2			;$2
	ADD	%00,ANCHOR(%06)		;ANCHOR
	HRRZM	%00,TOPS(%06)		;TOPS
	HRRZ	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	ADD	%00,ANCHOR(%06)		;ANCHOR
	HRRZM	%00,BOTTOM(%06)		;BOTTOM
RELML2:	SOJGE	%06,RELML1		;$1
	JRST	0(%11)
ILACH1:	MOVSI	%00,(POINT 6,0(%05),)
	POP	%05,%06
ILACH2:	ILDB	%07,%00
	TLNE	%00,770000
	JUMPN	%07,ILACH2
	DPB	%06,%00
	JRST	EXIML
PW0ML:					;PRINT W0 ML
	MOVSI	%03,(POINT 6,0(%05),)	;6-BIT POINTER
	MOVEI	%01,6
PW0ML1:	ILDB	%02,%03
;	JUMPE	%02,P1EML
	PUSHJ	%17,PCHML		;PRC ML
	SOJG	%01,PW0ML1		;$1
	JRST	P1EML			;POW 1 EXIT ML

POLML:					;PRINT OCTAL LOC ML

	HRLZ	%03,0(%05)
	MOVEI	%06,6
	MOVEI	%02,0
POLML1:	LSHC	%02,3
	SKIPN	%02
	SOJG	%06,POLML1		;$1
	PUSHJ	%17,PRNML		;PRC ML
POLML2:
	MOVSI	%02,7
	SOJG	%06,POLML1		;$1
	JRST	P1EML			;POW 1 EXIT ML

PWOML:	MOVE	%03,0(%05)
	MOVEI	%06,15
	JRST	POLML2
FINML:					;FL INTEGER ML

IFNDEF	$FAD,
<
	POP	%05,%06			;GET THE ARGUMENT
	IDIVI	%06,400000		;HIGH ORDER IN RH(%06)
	SKIPE	%06			;IMPLIES INT .LT. 18 BITS
	TLC	%06,254000		;SET EXP TO 27+17 DEC
	TLC	%07,233000		;SET EXP TO 27 DEC
	FAD	%06,%07			;NORMALIZE AND ADD
	PUSH	%05,%06			;SAVE RESULTS
	AOJA	%01,PSEML
>

IFDEF	$FAD,
<
	SKIPN	%06,0(%05)
	AOJA	%01,PSEML
	MOVEI	%07,244000
	SUBI	%07,001000
	LSH	%06,1
	JUMPG	%06,.-2
	LSH	%06,-^D9
	TSO	%06,%07
	MOVEM	%06,0(%05)
	AOJA	%01,PSEML
>
IFNDEF	$CCONS,
<

CARML:					;CONST ARITH ML
	JFCL	17,.+1
	POP	%05,%06
	POP	%05,%07
	POP	%05,%10
	XCT	CAOTBL(%10)		;CONST ARITH OPS TBL
	JFCL	10,EFAML		;EXIT FALSE ML
	PUSH	%05,%06
	AOJA	%01,PSEML

CAOTBL:					;CONST ARITH OPS TBL
	ADD	%06,%07
	SUB	%06,%07
	IMUL	%06,%07
	IDIV	%06,%07
	FADR	%06,%07
	FSBR	%06,%07
	FMPR	%06,%07
	FDVR	%06,%07
>
PAFML:					;PRINT AC FIELD ML
	SKIPA	%06,[POINT 4,0(%05),12]
PTAML:					;PRINT TAG ML
	MOVSI	%06,(POINT 4,0(%05),17)
	LDB	%02,%06
	ROT	%02,-3
	TLNN	%06,040000		;DON'T PRINT LEADING ZERO IN INDEX
	TRNE	%02,-1
	PUSHJ	%17,PRNML
	LSH	%02,-^D33
	PUSHJ	%17,PRNML
	AOJA	%01,PSEML

SOAFBM:					;SWITCH OCT AND FET BCD ML
	MOVE	%10,CODPNT+ZZ		;CODE PNTR
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%06,[POINT 9,0(%10),8]	;CODE INDEX BYTE
	PUSH	%05,IBCTBL(%06)		;INST BCD TBL
	CAIL	%06,NACBRE
	TDZA	%03,%03
	SETO	%03,
	IDIVI	%06,4
	LDB	%07,SOAFBT(%07)
	DPB	%07,[POINT 9,0(%10),8]	;CODE INDEX BYTE
	AOJA	%01,PSEML

SOAFBT:	POINT	9,IOCTBL(%06), 8
	POINT	9,IOCTBL(%06),17
	POINT	9,IOCTBL(%06),26
	POINT	9,IOCTBL(%06),35
SUEML:					;SET UP ERRORS ML
	MOVEI	%02,ERRROL		;ERROR ROLL
	PUSHJ	%17,DNGML		;DNG ML
	HRLI	%10,(POINT 5,,10)
	MOVEM	%10,CEMADR		;CRRNT ERROR MESS ADR
	POPJ	%17,

LFXML:	SETZM	LBFLG+ZZ
					;LABEL FIELD XLATE ML
	CAMN	%14,CSTAT+SPACE
LFXML1:	PUSHJ	%17,NCHML
	HRRZ	%07,CARNUM+ZZ
	SUBI	%07,6
	CAME	%14,CSTAT+CRR
	JUMPLE	%07,LFXML2
	PUSH	%05,%03
	MOVEM	%03,MAC2+ZZ
	AOJA	%01,PSEML

LFXML2:	JUMPE	%07,LFXML3
	TLNN	%14,DIGKEY
	JRST	LFXML4
	IMULI	%03,^D10
	ADDI	%03,-N0(%14)
	JRST	LFXML1

LFXML3:	CAMN	%14,CSTAT+N0
	JRST	LFXML1
LFXML4:	SKIPE	LBFLG+ZZ
	JRST	LFXML1
	SETOM	LBFLG+ZZ
	MOVSI	%10,200+6(%07)
	MOVEI	%02,S8QT		;ILLEGAL CHARACTER IN LABEL	;"23L"
	PUSHJ	%17,ERMML
	JRST	LFXML1
NCHML0:
	PUSH	%17,%11
NCHML:					;NEXT CHARACTER ML
	MOVEM	%13,LASACT+ZZ		;LAST ACTIVE
	MOVE	%00,CARNUM+ZZ
	MOVEM	%00,LACCCN+ZZ
NCHML1:	PUSHJ	%17,NICML		;NEXT INPUT CHAR ML
	CAMN	%14,CSTAT+SPACE		;IF BLANK
	JRST	NCHML1			;GET ANOTHER
	CAME	%14,CSTAT+TAB		;IF TAB
	POPJ	%17,			;EXIT
	TRZ	%00,7			;ROUND UP TO NEXT TAB COLUMN	;"23H"
	ADDI	%00,^D8			;CARD # IN AC0 VIA NICML	;"21O"
	HRRM	%00,CARNUM+ZZ		;CHANGE COLUMN #	;"21O"
	JRST	NCHML1			;GET ANOTHER CHARACTER	;"21O"
NICML0:
	PUSH	%17,%11
NICML:					;NEXT INPUT CHAR ML
	AOS	CARNUM+ZZ		;INCREMENT COLUMN COUNT
	ILDB	%14,%13			;GET NEXT CHAR FROM BUFFER
	CAIN	%14,CRR			;TEST FOR CR
	JRST	NICML1
					;LINE DELETED	;"21A"
					;LINE DELETED	;"21A"
	HRRZ	%00,CARNUM+ZZ
	CAIG	%00,^D72		;TEST FOR END OF LINE
	JRST	NICML4			;NO, SET FLAGS AND EXIT
NICML1:	HLRZ	%13,CARNUM+ZZ
	CAML	%13,LCANUM+ZZ		;TEST FOR CONTINUATION
	JRST	NICML3			;NO, SET CR AND EXIT
	IMULI	%13,WPL
					;LINE DELETED ;"21A"
					;LINE DELETED ;"21A"
	ADDI	%13,CARBUF+2
	HRLI	%13,(POINT 6,,)
	HLLOS	CARNUM+ZZ
	MOVEI	%00,7
	ADDM	%00,CARNUM+ZZ
	JRST	NICML

NICML3:	MOVEI	%14,CRR
NICML4:	MOVE	%14,CSTAT(%14)		;SET FLAGS
	POPJ	%17,
NLIML:					;NEXT LINE ML
	MOVE	%06,@SEQPNT		;TEST FOR EOF
	JUMPGE	%06,NLIML1
	SETOB	%03,ESTFLA+ZZ		;YES, SET END STATEMENT FLAG
	AOJA	%01,PSEML

NLIML1:	HRL	%06,SEQPNT		;MOVE UP LAST CARD
	HRRI	%06,CARBUF
	BLT	%06,CARBUF+WPL-1
	SETZB	%03,LCANUM+ZZ

NLIML2:	AOS	%06,LCANUM+ZZ		;INCREMENT CARD	NUMBER
	CAMLE	%06,CRDCNT		;TEST OVERFLOW
	AOSA	%07,CCAFLA+ZZ
	PUSHJ	%17,NCDML		;GET NEXT COMPLETE CARD
	JUMPL	%07,NLIML2		;BRANCH	IF CONTINUATION	CARD
	MOVSI	%07,1
	MOVEM	%07,CARNUM+ZZ		;INIT CARD-COLUMN COUNT
	MOVE	%13,[POINT 6,CARBUF+1,]
	PUSHJ	%17,NICML
	AOJA	%01,PSEML
NCDML:					;NEXT CARD ML
	MOVE	%06,LCANUM+ZZ		;LAST CARD NUMBER
	PUSHJ	%17,LINSET		;SETUP NEW LINE & POINTERS
	SETZM	-1(%06)			;CLEAR SEQUENCE NUMBER
	SETZM	0(%06)			;SET SPACES IN LABEL FIELD
	MOVNI	%10,5			;SET # OF CHARACTERS IN LABEL FIELD
	PUSHJ	%17,CHAR		;GET A CHARACTER
	LDB	%07,[POINT 1,CSTAT(%14),^L<<COMKEY>B17>];GET COMMENT FLAG
IFNDEF	FILE0,			;"23Q"
<	TLNN	%16,ISWBIT		;D=SPACE ?	;"23Q"
	JRST	NCDML1+1		;NO, CONTINUE	;"23Q"
	CAIN	%14,"D"-40		;COLUMN 1 = D ?	;"23Q"
	SETZB	%07,%14			;AC7=0 FOR REGULAR LINE	;"23Q"
					;& AC14=SPACE(0 IN SIXBIT)	;"23Q"
>					;"23Q"
	SKIPA				;DON'T GET A NEW CHARACTER

NCDML1:	PUSHJ	%17,CHAR		;GET A CHARACTER
	JUMPG	%10,NCDML2		;IN LABEL FIELD ?
	CAIE	%14,TAB			;YES, TAB SPACING ?
	JRST	NCDML2
	JUMPG	%07,NCDML2		;"23H"
	PUSHJ	%17,CHAR		;YES, GET SPECIAL CONTINUATION CHAR
	HRLI	%06,(POINT 6,,29)	;POINT TO COLUMN 5 +1
	CAIL	%14,N1			;DIGIT FROM ONE TO NINE ?
	CAILE	%14,N9			;(CONTINUATION CHAR W/TAB)
	TLZA	%06,770000		;NO, POINT TO COLUMN 6+1
	TDZA	%10,%10			;COLUMN COUNT = COL 6
	MOVEI	%10,1			;COLUMN COUNT = COL 7
NCDML2:	CAIG	%10,^D80-5		;75 CHARACTER LINE EXCEEDED ?
	IBP	%06			;NO, INCREMENT BYTE POINTER
	DPB	%14,%06			;STORE CHARACTER
	CAIN	%14,CRR			;END OF LINE ?
	POPJ	%17,			;YES, RETURN
	CAIN	%14,TAB			;TAB ?	;"21O"
	JRST	NCDML5			;"21O"
	JUMPG	%07,NCDML3		;SKIP IF COMMENT	;"23L"
	JUMPGE	%10,NCDML4		;OR OUTSIDE THE LABEL FIELD	;"23L"
	CAIN	%14,SPACE		;SPACE OR DIGIT IN LABEL ONLY	;"23L"
	JRST	NCDML3			;"23L"
	LDB	%02,[POINT 1,CSTAT(%14),^L<<DIGKEY>B17>];GET DIGIT KEY	;"23L"
	SKIPG	%02			;IF NON-DIGIT IN LABEL FIELD	;"23L"
	MOVEI	%07,1(%07)		;DISABLE AS CONTINUATION CARD	;"23L"
NCDML4:	JUMPN	%10,NCDML3		;COLUMN 6 WITH OUT TAB ?
	CAIE	%14,SPACE		;SPACE OR ZERO ?
	CAIN	%14,N0			;(ILLEGAL CONTINUATION CHARACTERS)
NCDML3:	AOJA	%10,NCDML1		;YES, GET NEXT CHARACTER
	SOJA	%07,NCDML3
NCDML5:	CAIG	%10,2			;BEFORE FIRST TAB COLUMN ?	;"23H"
	MOVEI	%10,0			;CLEAR POSSIBLE NEGATIVE COUNT	;"23H"
	TRZ	%10,7			;CHANGE COUNT TO NEXT TAB COLUMN-1	;"23H"
	TRO	%10,1			;"23H"
	CAILE	%10,2			;COUNT=2 AT FIRST TAB COLUMN	;"23H"
	MOVEI	%10,^D8(%10)		;COUNT=COUNT+8 W/2= LAST DIGIT	;"23H"
	JRST	NCDML3			;AND CONTINUE	;"21O"
PSTML0:
	PUSH	%17,%11
PSTML:					;PRINT STATEMENT ML
	SETZM	ERRPNT+ZZ		;ERROR ROLL PNTR
	PUSHJ	%17,SUEML		;SET UP ERRORS ML
	MOVEM	%03,ERRFLA+ZZ		;ERROR FLAG
	SETOM	PSTCRD+ZZ		;INIT CARD COUNT
PSTML1:	AOS	%06,PSTCRD+ZZ
	CAML	%06,LCANUM+ZZ		;TEST FOR END
	JRST	PSTML7			;YES
	PUSHJ	%17,LINSET
	PUSHJ	%17,PLIML		;PRINT LINE ML
	JUMPE	%03,PSTML1		;BRANCH IF NO ERRORS
	LDB	%00,CEMADR		;ERROR
	SUB	%00,PSTCRD+ZZ		;THIS CARD?
	SOJN	%00,PSTML1		;NO
IFNDEF	FILE0,
<
	AOS	ERRCNT+ZZ		;TALLY ERROR COUNT
>
	MOVE	%00,CEMADR
	HRLI	%00,(POINT 6,,)		;CHANGE P & S FIELDS
	MOVEM	%00,PEMADR		;PRINT ERROR MSG ADDRESS
	MOVEI	%11,N1			;ERROR CNTR
PSTML2:	ADD	%11,LHAMAS+ZZ		;DECREMENT ERROR COUNT
	MOVE	%06,FICPNT		;FIRST INPUT CHAR PNTR
	LDB	%12,[POINT 7,@CEMADR,17]
PSTML3:	ILDB	%02,%06
	CAIN	%02,CRR			;TEST FOR END
	JRST	PSTML4			;YES
	CAIN	%12,1			;ERRONEOUS COLUMN?
	MOVEI	%02,UARROW		;YES
	CAIE	%02,UARROW		;"?"?
	MOVEI	%02,SPACE		;NO, SUBSTITUTE BLANK
	DPB	%02,%06
	SOJA	%12,PSTML3
PSTML4:	PUSHJ	%17,SUEML		;SET UP ERRORS ML
	LDB	%00,CEMADR
	SUB	%00,PSTCRD+ZZ
	SOSN	%00
	JUMPN	%03,PSTML2
					;LINE DELETED	;"23O"
	MOVE	%06,PSTCRD+ZZ
	PUSHJ	%17,PLIML		;PRINT LINE ML
PSTML5:	SETZM	CARBUF+1
	AOS	%06,PEMADR		;PRINT ERROR MSG ADDRESS
	HRR	%06,-1(%06)		;GET TRUE ADDRESS
	ADDI	%06,QTTBL
	MOVEI	%07,CARBUF+1
	HRLI	%07,(POINT 6,,29)
PSTML6:	ILDB	%00,%06
	IDPB	%00,%07
					;4 LINES DELETED ;"23Q"
	CAIE	%00,EOF			;TEST FOR END OF MESSAGE
	JRST	PSTML6			;NO
	MOVEI	%00,CRR			;YES, SET CR
	DPB	%00,%07
	MOVEI	%06,0
	PUSHJ	%17,LINSET	;ERROR MESSAGE IN 1ST BUFFER
	PUSHJ	%17,PLIML
	AOBJN	%11,PSTML5	
				;34 LINES DELETED	;"23O"
	JRST	PSTML1

PSTML7:	SETZM	ERRFLA+ZZ		;CLEAR ERROR FLAG
LINSET:	IMULI	%06,WPL
				;2 LINES DELETED	;"21A"
	ADDI	%06,CARBUF
	HRLI	%06,(POINT 7,,)
	MOVEM	%06,SEQPNT
	HRLI	%06,(POINT 6,,)
	MOVEM	%06,FICPNT
	AOS	%06,FICPNT
	POPJ	%17,			;EXIT
PLIML:					;PRINT LINE ML
PLIML1:	MOVE	%07,SEQPNT		;SEQNUM POINTER
	HRLI	%07,(POINT 6,,35)	;SET SIXBIT BYTE POINTER
IFNDEF	FILE0,				;"23B"
<	MOVE	%02,(%07)		;GET SEQNUM	;"21A"
	TRNE	%02,1			;HEADER REQUESTED ?	;"21A"
	TRO	%16,HDRBIT		;YES, INFORM EXEC	;"21A"
>					;"23B"
PLIML5:	ILDB	%02,%07			;PICK UP CHARACTER
	CAIN	%02,CRR			;CARRIAGE RETURN?
	JRST	PLIML6			;YES
	CAIE	%02,SPACE		;SPACE?
	MOVEM	%07,1(%05)		;NO, MARK IT
					;2 LINES DELETED	;"21A"
	JRST	PLIML5

PLIML6:	IDPB	%02,1(%05)		;MARK THE END OF LINE
IFNDEF	$CREF,
<
;	SKIPE	PSTCRD+ZZ		;FIRST LINE OF STATEMENT ?;LINE DELETED ;"21X"
;	JRST	.+4			;NO, DON'T OUTPUT CREF LINE;LINE DELETED ;"21X"
	HRREI	%02,CRFLIN-40
	TLNN	%16,CSWFLG
	PUSHJ	%17,LSTOUT
>
	SKIPN	ERRFLA+ZZ		;ERROR LINE PRINT ?
	JRST	.+6			;NO, OUTPUT TABS
	MOVEI	%15,^D8			;8 "*" = 1 TAB
	MOVEI	%02,ASTERI		;OUTPUT "*"
	PUSHJ	%17,PLIML7
	SOJG	%15,.-2			;OUTPUT 8 OF THEM
	JRST	.+3
	MOVEI	%02,TAB
	PUSHJ	%17,PLIML7		;PRINT TAB
	TLNE	%16,MOTFLG		;M SWITCH OR TTY LISTING ?
	JRST	PLIML2-1		;YES,NO MORE TABS
	MOVEI	%06,3			;SET TO THREE TABS
	PUSHJ	%17,LSTTAB		;OUTPUT TAB
	SOJG	%06,.-1			;TEST FOR END
	MOVE	%07,SEQPNT		;SEQNUM POINTER
PLIML2:	ILDB	%02,%07			;LIST SEQUENCE NUMBER
	JUMPE	%02,PLIML3
	SUBI	%02,40			;CONVERT TO SIXBIT
	PUSHJ	%17,PLIML7		;OUTPUT CHARACTER
	TLNE	%07,760000		;TEST FOR END
	JRST	PLIML2
PLIML3:	SETZM	@SEQPNT			;INITIALIZE SEQNUM
	HRLI	%07,(POINT 6,,35)	;SET TO SIXBIT
	MOVEI	%02,TAB			;LEAD OFF WITH TAB
PLIML4:	PUSHJ	%17,PLIML7		;LIST CHARACTER
	ILDB	%02,%07			;GET NEXT
					;2 LINES DELETED ;"21A"
	CAIE	%02,CRR			;TEST FOR END
	JRST	PLIML4			;NO, GET ANOTHER

PLIML7:	SKIPE	ERRFLA+ZZ
	JRST	ERROUT
	TLNN	%16,LSTFLG
	JRST	LSTOUT
	POPJ	%17,
IFDEF	HALFWD,
<
OPJTBL:					;OP JUMP TABLE

	IF2,	<IFN CODE,	<
	RELOC	OPJTBL+<OPCNT-1>/3
	+CODE
	RELOC>>

	BLOCK	<OPCNT+2>/3
>
IFDEF	DEBUG,
<
ERRCO=	0	;"23O"
 

IFNDEF	FILE0,
<
	EXTERNAL	DEBSW
	EXTERNAL	DEBSW1,	DEBSW2,	DEBSW3,	DEBSW4,	DEBSW5,	DEBSW6
>

IFDEF	HALFWD,
<
	INTERNAL	DEBITB

DBEML:
	MOVEM	%02,DEBSAV
	AOS	DEBCNT
	SKIPG	DEBSW
	JRST	DBEMLE
	AOS	DEBNXT
	HLRZ	%10,DEBSW1
	CAIN	%10,0(%01)
	IORM	%10,DEBLSW
	SKIPE	DEBLSW
	JRST	DBEMLE
	HLRZ	%07,DEBSW2
	HRRZ	%10,DEBSW2
	CAIG	%07,0(%01)
	CAIGE	%10,0(%01)
	CAIA
	JUMPN	%10,DBEMLE
	LDB	%10,[POINT 2,DEBSAV,19]
	CAIE	%10,3
	JRST	DBEMLB
	LDB	%10,[POINT 3,DEBSAV,22]
	MOVE	%07,DEBSW3
DBEMLA:	SKIPGE	%07
	JUMPE	%10,DBEMLE
	LSH	%07,1
	SOJGE	%10,DBEMLA
	JRST	DBEMLF

DBEMLB:	SETOM	DEBTMP
	LDB	%02,[POINT 7,DEBSAV,26]
DBEMLC:	AOS	%10,DEBTMP
	CAILE	%10,3
	JRST	DBEMLF
	MOVE	%07,%10
	IMULI	%07,^D36
	MOVE	%00,DEBSW4(%10)
DBEMLD:	JUMPE	%00,DBEMLC
	CAMN	%07,%02
	JUMPL	%00,DBEMLE
	LSH	%00,1
	AOJA	%07,DBEMLD

DBEMLF:
	SKIPE	DEBNXT
	JRST	DBEXIT

DBEMLE:
	PUSHJ	%17,DEBTAB
	MOVE	%07,[POINT 3,%01,17]
	PUSHJ	%17,DEBDMP
	LDB	%07,[POINT 2,DEBSAV,19]
	CAIL	%07,3
	JRST	DBEML1
	LDB	%07,[POINT 7,DEBSAV,26]
	MOVE	%10,DEBITB(%07)
	PUSHJ	%17,DEBSIX
	LDB	%07,[POINT 2,DEBSAV,19]
	XCT	DEBXTB(%07)
	PUSHJ	%17,LSTOUT
	PUSHJ	%17,DEBTAB
	PUSHJ	%17,DEBSP
	PUSHJ	%17,DEBSP
	PUSHJ	%17,DEBSP
	MOVE	%07,[POINT 3,DEBSAV,26]
	PUSHJ	%17,DEBDMP
	JRST	DBEFIN

DBEML1:	LDB	%07,[POINT 3,DEBSAV,22]
	CAIL	%07,7
	JRST	DBEML2
	MOVE	%10,DEBJTB(%07)
	PUSHJ	%17,DEBSIX
	PUSHJ	%17,DEBTAB
	PUSHJ	%17,DEBSP
	LDB	%10,[POINT 13,DEBSAV,35]
	MOVE	%07,[POINT 3,%10,20]
	PUSHJ	%17,DEBDMP
	JRST	DBEFIN

DBEML2:	LDB	%07,[POINT 2,DEBSAV,24]
	MOVE	%10,XITTBL(%07)
	PUSHJ	%17,DEBSIX
	PUSHJ	%17,DEBTAB
	PUSHJ	%17,DEBSP
	PUSHJ	%17,DEBSP
	LDB	%10,[POINT 11,DEBSAV,35]
	MOVE	%07,[POINT 3,%10,23]
	PUSHJ	%17,DEBDMP
	JRST	DBEFIN
>
DEBSP:	MOVEI	%02,SPACE
	JRST	LSTOUT

DEBSIX:	SETZ	%07,
	LSHC	%07,6
	MOVE	%02,%07
	PUSHJ	%17,LSTOUT
	JUMPN	%10,DEBSIX
	POPJ	%17,

IFDEF HALFWD,<
DEBITB:	BLOCK	OPCNT			;DEBUG INST TABLE

DEBXTB:	CAIA
	MOVEI	%02,F
	MOVEI	%02,T

DEBJTB:	SIXBIT	/JMP/
	SIXBIT	/JMPT/
	SIXBIT	/JMPF/
	SIXBIT	/JSB/
	SIXBIT	/JSBT/
	SIXBIT	/JSBF/
	SIXBIT	/JOW/

XITTBL:	SIXBIT	/XIT/
	SIXBIT	/XITF/
	SIXBIT	/XITT/

DEBTMP:	0
DEBCNT:	0
DEBLSW:	0
DEBNXT:	0

>

	DEBSAV:	0

IFNDEF	HALFWD,
<

DBEML:
	MOVEM	%02,DEBSAV
	MOVE	%07,[POINT 3,%01,17]
	PUSHJ	%17,DEBDMP		;DUMP POPMEM ADDRESS
	MOVE	%07,[POINT 3,%06]
	PUSHJ	%17,DEBDMP

>
DBEFIN:

	MOVEI	%02,T
	SKIPN	%03
	MOVEI	%02,F
	PUSHJ	%17,LSTOUT
	PUSHJ	%17,DEBTAB

	MOVE	%07,%04		;GET EXIT ROLL POINTER
	SUB	%07,DEBS04		;COMPUTE PRESENT LEVEL
	PUSHJ	%17,DEBLVL		;PRINT LEVEL & CONTENTS
	MOVE	%07,%05			;GET WORK ROLL POINTER
	SUB	%07,DEBS05		;COMPUTE PRESENT LEVEL
	PUSHJ	%17,DEBLVL		;PRINT LEVEL & CONTENTS
	SKIPN	%07,DEBSW6		;LIST UPPER MEMORY LOCATION?
	JRST	DBEFI3			;NO, CONTINUE
	TLZE	%07,1			;LIST IN SIXBIT?
	JRST	DBEFI1			;YES, SETUP & LIST
	HRRZS	%07			;CLEAR LEFT HALF
	ADD	%07,[POINT 3,ZZ,]		;MAKE BYTE POINTER WITH ADDRES+ZZ
	PUSHJ	%17,DEBDMP		;DUMP IN OCTAL
	JRST	DBEFI2			;CONTINUE
DBEFI1:	MOVE	%10,ZZ(%07)		;GET CONTENTS
	PUSHJ	%17,DEBSIX		;DUMP IN SIXBIT
DBEFI2:	PUSHJ	%17,DEBTAB		;OUTPUT A TAB
DBEFI3:	HRRZ	%02,%14
	CAIL	%02,TAB
	MOVEI	%02,UARROW
	PUSHJ	%17,LSTOUT
	MOVEI	%02,CRR
	PUSHJ	%17,LSTOUT

IFDEF	HALFWD,
<
REPEAT 0,
<	MOVE	%02,DEBSW
	TRNE	%02,2
	PUSHJ	%17,ROLLST

>
DBEXIT:	HRRZ	%10,DEBSW1
	CAIN	%10,0(%01)
	SETZM	DEBLSW
>
	MOVE	%02,DEBSAV
	POPJ	%17,


DEBDMP:	ILDB	%02,%07
	ADDI	%02,20
	PUSHJ	%17,LSTOUT
	TLNE	%07,770000
	JRST	DEBDMP
DEBTAB:	MOVEI	%02,TAB
	JRST	LSTOUT
DEBLVL:					;OUTPUT LEVEL & CONTENTS
	MOVE	%10,[POINT 3,%07,8]	;POINT TO FOURTH BYTE
	ILDB	%02,%10			;GET IT
	TLNE	%07,700			;LEADING ZERO?
	TROA	%02,N0			;NO, CONVERT TO SIXBIT
	MOVEI	%02,SPACE		;YES, SUBSTITUTE SPACE
	PUSHJ	%17,LSTOUT		;LIST IT
	ILDB	%02,%10			;FETCH NEXT BYTE
	TLNE	%07,770			;LEADING ZEROS?
	TROA	%02,N0			;NO, CONVERT TO SIXBIT
	MOVEI	%02,SPACE		;YES, SUBSTITUTE SPACE
	PUSHJ	%17,LSTOUT		;LIST IT
	ILDB	%02,%10			;FETCH LOW ODER BYTE
	TRO	%02,N0			;CONVERT TO SIXBIT
	PUSHJ	%17,LSTOUT		;LIST IT
	PUSHJ	%17,DEBSP		;LIST TWO SPACES
	PUSHJ	%17,DEBSP
	HRLI	%07,(POINT 3,,)		;PREPARE TO LIST CONTENTS
	MOVEI	%10,6			;SET COUNT FOR HALF
DEBLV1:	ILDB	%02,%07			;FETCH NEXT OCTAL CHARACTER
	TRO	%02,N0			;CONVERT TO SIXBIT
	PUSHJ	%17,LSTOUT		;LIST IT
	SOSN	%10			;TIME FOR CENTER SPACE?
	PUSHJ	%17,DEBSP		;YES, LIST IT
	TLNE	%07,770000		;FINISHED?
	JRST	DEBLV1			;NO, CONTINUE OUTPUT
	JRST	DEBTAB			;YES, TAB AND EXIT
DEBS04:	BLOCK	1			;INITIAL EXIT ROLL POINTER
DEBS05:	BLOCK	1			;INITIAL WORK ROLL POINTER


>; END IFDEF DEBUG
REPEAT 0,
<
ROLLST:	SKIPN	DEBSW5			;EXIT IF NO ROLLS
RLST1:	POPJ	%17,			;ARE SPECIFIED
	MOVEI	%07,0			;START ROLL COUNT AT 0
	MOVE	%11,%07			;START ENTRY COUNT AT 0
	MOVEI	%12,[POINT 6,DEBSW5]	;SET UP BYTE POINTER
DPBYTE:	ILDB	%02,%12			;PICK UP A ROLL NO.
	TLNN	%12,770000		;IS THIS THE LAST ROLL
	JRST	RESET			;NO, GET THE NEXT
	JUMPE	%02,DPBYTE		;THROW IT AWAY IF 0
	CAIN	%02,77			;DO I WANT ROLL 0
	SETZ	%02,			;THEN MAKE IT RIGHT
	MOVEM	%02,ROLL(%07)		;STORE ROLL NO.
	MOVE	%10,BOTTOM(%02)		;FIRST ENTRY ON ROLL
	SUB	%10,ANCHOR(%02)		;LAST ENTRY
	HRLM	%10,ROLL(%07)		;STORE THE ROLL SIZE
	ADD	%11,%10			;TO TELL IF ANY NEED BE LISTED
	AOJA	%07,DPBYTE		;

RESET:	JUMPE	%11,RLST1		;NO ROLL ENTRIES TO BE LISTED
	MOVEI	%10,0			;0 ROLL COUNT
	MOVEM	%07,COUNT		;SAVE THE NO. OF ROLLS
BUBSRT:	MOVEI	%11,1(%10)		;AC11=AC10+1
BSRTA:	CAMLE	%11,COUNT		;ARE WE AT THE END
	AOJA	%10,BSRTB		;SEE IF WE ARE FINISHED
	HLR	%12,ROLL(%11)		;SEE WHICH IS GREATER
	HLR	%07,ROLL(%10)		;
	CAML	%07,%12			;
	AOJA	%11,BSRTA		;THE LARGER IS ON TOP
	MOVE	%02,ROLL(%11)		;SWITCH THEM
	MOVE	%12,ROLL(%10)		;IF THEY ARE NOT
	MOVEM	%02,ROLL(%10)		;
	MOVEM	%12,ROLL(%11)		;
	AOJA	%11,BSRTA		;BACK FOR MORE
BSRTB:	CAME	%10,COUNT		;ARE WE DONE YET
	JRST	BUBSRT			;NO
	MOVEI	%10,0			;YES, 0 THE POINTER
	PUSHJ	%17,DEBTAB		;MAKE A TAB
ROPRIN:	PUSHJ	%17,DEBTAB		;ANOTHER
	MOVEI	%07,[POINT 3,ROLL(%10),29]	;
	PUSHJ	%17,DEBDMP		;DUMP THE ROLL
	AOJ	%10,			;INCRUMENT THE POINTER
	CAMG	%10,COUNT		;THRU YET
	JRST	ROPRIN			;NO
	PUSHJ	%17,DEBCR		;YES, CARRIAGE RETURN
	MOVEI	%10,0			;0 THE POINTER
	PUSHJ	%17,DEBTAB		;MAKE A TAB
ENPRIN:	PUSHJ	%17,DEBTAB		;AGAIN
	HLR	%11,ROLL(%10)		;PICKUP THE ROLL SIZE
	MOVEI	%07,[POINT 3,%11,26]	;
	PUSHJ	%17,DEBDMP		;
	AOJ	%10,			;INCRUMENT THE POINTER
	CAMG	%10,COUNT		;ARE WE THRU
	JRST	ENPRIN			;NO

	MOVEI	%10,0			;YES, 0 THE POINTER
ADRSET:	HRR	%11,ROLL(%10)		;EXCHANGE ROLL NO.
	MOVE	%11,BOTTOM(%11)		;
	HRRM	%11,ROLL(%10)		;
	AOJ	%10,			;
	CAMG	%10,COUNT		;THRU?
	JRST	ADRSET			;NO
	SETZM	RUNG			;YES, 0 THE RUNG POINTER

ENTRY:	MOVEI	%10,0			;0 POINTER
	MOVE	%07,RUNG		;EXCEEDED MAX. RUNGS?
	CAILE	%07,77			;
	JRST	RLST1			;YES, EXIT
	PUSHJ	%17,ENDCHK		;ANYTHING TO LIST?
	JUMPE	%12,RLST1		;NO
	MOVEI	%07,[POINT 3,RUNG,29]	;
	PUSHJ	%17,DEBDMP		;DUMP THE RUNG NO.

RENTRY:	MOVEI	%07,[POINT 3,@ROLL(%10)]	;
	PUSHJ	%17,DEBDMP		;DUMP ROLL CONTENTS
	MOVE	%12,ROLL(%10)		;DECREMENT ROLL SIZE
	SUB	%12,[1000001]		;AND ADDRESS
	TLNE	%12,777777		;SIZE 0 MEANS DONOT LIST
	SETZ	%12,			;
	MOVEM	%12,ROLL(%10)		;
	PUSHJ	%17,ENDCHK		;ANYTHING ELSE TO LIST?
	JUMPN	%12,NONZ		;
	PUSHJ	%17,DEBCR		;NO, CARRIAGE RETURN
	AOS	RUNG			;TRY THE NEXT RUNG
	JRST	ENTRY			;
NONZ:	AOJ	%10,			;YES
	CAMG	%10,COUNT		;LAST ROLL?
	JRST	RENTRY			;NO
	PUSHJ	%17,DEBCR		;YES
	JRST	ENTRY			;
ENDCHK:	MOVEM	%10,HOLD		;SAVE PRESENT COUNTER
	MOVEI	%12,0			;0 ANY LEFT INDICATOR
	CAIE	%10,0			;0 FOR POINTER IF 0
ENDCH1:	ADDI	%10,1			;LOOK FIRST AT NEXT ROLL
	CAMLE	%10,COUNT		;LAST ROLL
	JRST	ENDCH2			;GET THE NEXT ONE
	HLR	%11,ROLL(%10)		;NO, PICK UP SIZE
	ADD	%12,%11			;KEEP TRACK OF IT
	JRST	ENDCH1			;GET THE NEXT ONE
ENDCH2:	MOVE	%10,HOLD		;RETURN PRESENT COUNT
	POPJ	%17,

DEBCR:	MOVEI	%02,CRR			;SETUP CARRIAGE RETURN
	JRST	LSTOUT			;LIST IT

RUNG:	BLOCK 1
COUNT:	BLOCK 1
HOLD:	BLOCK 1
ROLL:	EXP 0,0,0,0,0,0
>
;....EOF1

	SUBTTL	FX2 V.25	20-JAN-72

	;UPDATE IF COMPILER IS CHANGED

;COPYRIGHT 1971,72 DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.
				;REINSTATE CONFLICTING OP-CODES
	OPREST	ADD
	OPREST	SUB
	OPREST	DIV
	OPREST	AND

POPMEM:

IFNDEF	HALFWD,
<
	PHASE	0
>

IFDEF	HALFWD,
<
	LOC	0
>
LAPSAV:					;LOOK AHEAD POSITION SAVE
	XML	(LAPSML)
LAPRES:					;LOOK AHEAD POSITION RESET
	XML	(LAPRML)
DESCEN:					;DESCEND
	XIT	(DESML)
SUBSCA:					;SUBORD SCAN
	XIT	(SSCML)
OGERUN:					;OP GEN RUN
	XIT	(OGRML)
RELDIS:					;RELATIONAL OP DISPATCH
	XIT	(REDIML)
GENRUN:					;GEN RUN
	XIT	(GRUML)
SCAGEN:					;SCALE GEN
	XML	(SGEML)
BSHREF:					;BUILD SECOND HALF REF
	XML	(B2RML)
OPCHEC:					;OP CHECK
	XIT	(OCHML)
PW0OCT:				;PRINT W0 OCTAL
	XML	(PWOML)
NEXCHA:					;NEXT CHAR
	XML	(NCHML0)
NINCHA:					;NEXT INPUT CHAR
	XML	(NICML0)
COCNPL:
	XML	(COCCON)	;CONVERT OCTAL CONSTANT
PRISTA:					;PRINT STATEMENT
IFNDEF	$CREF,
<
	MOA	(CRFROL)
	XMLT	(CRFML)
	JMPT	(PRISTA)
>
	XIT	(PSTML0)
BSSLIN:					;BUILD SYS SR LINK
	FET	(SYMBOL)
	NOZ	(SAV16)		;SAVE REG 16 ONLY IF SYS SUB ;"21V"
	W1	(SWT)
	BAI	(.MEI2)	;MOVEI 16 INST
	FET	(R10PNT)	;REG 10 PNTR
BSSLI1:
	JSB	(SRITGE)	;STORE REG IN TEMP GEN
	XW0.0	(ZER)		;ZERO RUNG
	W0	(TLY)		;W0
	SMK	(DREEM)	;DO REG EM
	JMPF	(BSSLI1)	;$1
	POW	(D1)		;ONE
	STO	(SYMBOL)
BLKPL:					;BLK PL
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	IOR	(GSPPNT)	;GLOBAL SPROG PNTR
	JMP	(MOCOEX)	;MOVE ON CODE EXIT
DOUBUI:					;DOUBLE BUILD
	JSB	(BUIINS)	;BUILD INSTRUCTION
	MOA	(CODROL)	;CODE ROLL
	W0	(FET)		;W0
	MON	(CODROL)	;CODE ROLL
	SMK	(LBLEM)	;LBL EM
	SMKF	(APOEM)	;ADR PLUS ONE EM
	ADD	(APOSTA)	;ADR PLUS ONE STAMP
	SUBT	(RCOMAS)	;REG CORR MASK
	POCT	(ABSINS)	;ABS INST
MOCOEX:					;MOVE ON CODE EXIT
	MON	(CODROL)	;CODE ROLL
EXIT:
	XIT	(EXIML)
BUIINS:					;BUILD INSTRUCTION
	SMK	(AREEM)	;ARRAY REF EM
	JMPT	(BARREF)	;BUILD ARRAY REF
	SMK	(CONEM)	;CONST PNTR EM
	JMPT	(BCOREF)	;BUILD CONST REF
	SMK	(LDMEM)	;LOCAL DMY EM
	XITF	(BFIML)		;BUILD FINAL	;"21D"
	STK	(APAATO)	;ADR PARITY ATOM
	XW0.1	(CLA)		;LOCAL DMY TEMP RUNG
	IER	(APAEM)	;ADR PARITY EM
	XIT	(BFIML)		;BUILD FINAL	;"21D"
BHOREF:					;BUILD HOLLERITH REF
	STK	(HCOPNT)	;HOLLERITH CONST PNTR
	FET	(APNPNT)	;ARG PNTR PNTR
	W1	(SWT)		;W1
	RSV	(APNROL)	;ARG PNTR ROLL
	CFP	(APNROL)	;ARG PNTR ROLL
	FLP	(APNROL)	;ARG PNTR ROLL
	DFA	(HCOROL)	;HOLLERITH CONST ROLL
	STO	(CPOCLU)	;CONST POOL CLUE
	ISE	(CPOFIL)	;CONST POOL FILE
	JMPF	(BHORE2)	;$2
BHORE4:
	FET	(CPOPNT)	;CONST POOL PNTR
	STO	(UN2PNT)	;UNUSED 2 PNTR
	ZER	(APNPNT)	;ARG PNTR PNTR
	DNG	(APNROL)	;ARG PNTR ROLL
BHORE1:
	DFA	(APNROL)	;ARG PNTR ROLL
	FETF	(UN2PNT)	;UNUSED 2 PNTR
	RELF	(APNROL)	;ARG PNTR ROLL
	JMPF	(BHORE3)	;$3
	DNG	(CPOROL)	;CONST POOL ROLL
	POWF	(D1)		;PRUNE UNMATCHED LITERAL ;"23Z"
	JMPF	(BHORE2)
	XNIT	(CPOPNT)	;CONST POOL PNTR
	SEKT	(ZERRUN)	;ZERO RUNG
	POW	(D1)
	JMPT	(BHORE1)	;$1
	CSE	(CPOFIL)	;CONTINUE SEARCH FOR EQUALITY
	JMPT	(BHORE4)	;TRY AGAIN IF ANOTHER MATCH IS FOUND
BHORE2:
	PNG	(CPOROL)	;CONST POOL ROLL
	EAW	(CPOROL)	;CONST POOL ROLL
	CAR	(APNROL)	;ARG PNTR ROLL
BHORE3:
	W1	(SWT)		;W1
	STO	(APNPNT)	;ARG PNTR PNTR
	XIT	(BFIML)		;BUILD FINAL	;"21D"
BARREF:					;BUILD ARRAY REF
	W1	(FET)		;W1
	EOR	(REGSTA)	;REG STAMP
	W2	(SWT)		;W2
	W1	(SWT)		;W1
	JSB	(SCRGEN)	;SCRIPT GEN
	JMPF	(BARRE2)	;$2
	XW1.2	(FET)		;SCRIPT EXP RUNG
	JSB	(RSATE1)	;REG SAVE TEST $1
	XW0.0F	(ZER)		;ZERO RUNG
	W2	(FET)		;W2
	SME	(TEMEM)	;TEMP EM
	XMLF	(IITML)	;INSERT INST TAG
BARRE2:
	W1F	(SWT)		;W1
	JMPF	(BARRE3)	;$3
	W0	(FET)		;W0
	W4	(EOR)		;W4
	AND	(DISMAS)	;DISPL MASK
	SEQ	(ZERO)	;ZERO
	JSBT	(SRITGE)	;STORE REG IN TEMP GEN
	FETT	(R16PNT)	;REG 16 PNTR
	W1T	(SWT)		;W1
	BINT	(.ME0)	;MOVE INST
	XML	(IITML)	;INSERT INST TAG
	W1	(SWT)		;W1
	W2	(FET)		;W2
	IER	(REGEM)	;REG EM
	XML	(TSAML)	;TEMP STATUS ADVANCE
	JSB	(RLOGEN)	;REG LOAD GEN
BARRE3:
	W2	(STO)		;W2
	XW0.1	(FET)		;ARRAY REF OFFSET RUNG
	STO	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	SMK	(APOEM)	;ADR PLUS ONE EM
	DIMT	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	XW0.0	(CLA)		;ARRAY REF NAME RUNG
	SMK	(DMYEM)	;DMY EM
	FETT	(ZERO)	;ZERO
	SUBT	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	XMLT	(BIRML)	;BUILD IMMED REF ML
	SNZ	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	XITF	(BFIML)		;BUILD FINAL	;"21D"
	STO	(OARNCL)	;OBJECT ARRAY REF NAME CLUE
	REG	(OARFIL)	;OBJECT ARRAY REF FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	XIT	(BFIML)	;BUILD FINAL
SCRGEN:					;SCRIPT GEN
	XW0.2	(FET)		;SCRIPT EXP RUNG
	SEK	(ZERO)	;ZERO
	XMLT	(P1EFML)	;POW ONE EXIT FALSE
	SMK	(DREEM)	;DO REG EM
	SMKT	(PLUEM)	;PLUS EM
	XMLT	(ETRML)	;EXIT TRUE
	ZER	(RROFLA)	;RESET REG ONE FLAG
	SON	(DITEM)	;DOUBLE ITEM EM
	FET	(RZEPNT)	;REG ZERO PNTR
	JMPF	(SCRGE1)	;$1
	XW0.1	(SNZ)		;REG ONE PNTR
	XW0.1F	(NOZ)		;ZERO RUNG
	NOZF	(RROFLA)	;RESET REG ONE FLAG
SCRGE1:
	XW0.0	(SNZ)		;ZERO RUNG
	XW0.0F	(NOZ)		;ZERO RUNG
	CLA	(EOPPNT)	;EXP OP PNTR
	W1	(SWT)		;W1
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(GENRUN)	;GEN RUN
	JSB	(GNIR0G)	;GRNTEE NOT IN REG 0 GEN
	JSB	(GIRGEN)	;GRNTEE IN REG GEN
	JSB	(GPRGEN)	;GRNTEE POS REG GEN
	W1	(SWT)		;W1
	STO	(EOPPNT)	;EXP OP PNTR
	FET	(RZEPNT)	;REG ZERO PNTR
	XW0.0F	(ZER)		;ZERO RUNG
	SNZ	(RROFLA)	;RESET REG ONE FLAG
	XW0.1T	(ZER)		;ZERO RUNG
	XML	(P1ETML)	;POW 1 EXIT TRUE
BCOREF:					;BUILD CONST REF
	SMK	(HCOEM)	;HOLLERITH CONST EM
	JMPT	(BHOREF)	;BUILD HOLLERITH REF
	SMK	(DITEM)	;DOUBLE ITEM EM
	JMPT	(DCOREG)	;DOUBLE CONST REG
	SMK	(APOEM)	;ADR PLUS ONE EM
	XW0.1T	(FET)		;ONE RUNG
	XW0.0F	(FET)		;ZERO RUNG
	SON	(LTYEM)	;LOGICAL TYPE EM
	SEKT	(TRUCON)	;TRUE CONST
	JMPT	(RABCRE)	;REG AND BUILD CONST REF
	XML	(GETOPC)	;GET OP CODE
	SEQ	(MOVINS)	;MOVE INST EM
	JMPF	(TIMBUI)	;TEST IMMED BUILD
	SMK	(RHOEM)	;RIGHT HALF ONES EM
	EAWT	(.RLOI0)	;HRLOI INST
	XITT	(BSLML)	;BUILD SWITCHED LOAD ML
	SMK	(ZRHEM)	;ZERO RIGHT HALF EM
	EAWT	(.MSI0)	;HRLZI INST
	XITT	(BSLML)	;BUILD SWITCHED LOAD ML
	SMK	(LHZEM)	;LEFT HALF ZERO EM
	JMPT	(BICREF)	;BUILD IMMED CONST REF
RABCRE:					;REG AND BUILD CONST REF
	STO	(CPOCLU)	;CONST POOL CLUE
	REG	(CPOFIL)	;CONST POOL FILE
	CLA	(CPOPNT)	;CONSTANT POOL PNTR
	XIT	(BFIML)		;BUILD FINAL	;"21D"
TIMBUI:					;TEST IMMED BUILD
	XML	(GETOPC)	;GET OP CODE
	SGK	(MIMINS)	;MAX IMMED INST
	JMPT	(TSTFAD)	;TEST FLOATING INST
	POW	(D1)		;PRUNE OP CODE
	SLK	(ZERO)	;ZERO
	SGKF	(MIMADR)	;MAX IMMED ADR
	JMPT	(RABCRE)	;REG AND BUILD CONST REF
BICREF:					;BUILD IMMED CONST REF
	FET	(BICFAC)	;BUILD IMMED CONST FACTOR
	W4	(AMY)
	XIT	(BIRML)	;BUILD IMMED REF

TSTFAD:					;TEST FLOATING IMMEDIATE
	SLT	(MIFINS)	;MAX FLOATING IMMED INST

	SNZT	(PDPSW)	;TEST MACHINE TYPE

	SMKT	(ZRHEM)	;TEST RIGHT HALF ZERO
	W0T	(SWH)		;SWAP HALVES
	JMPT	(BICREF)	;BUILD IMMED CONST REF

	JMP	(RABCRE)
DCOREG:					;DOUBLE CONST REG
	XW0.1	(FET)		;ONE RUNG
	XW1.0	(FET)		;ZERO RUNG
	STK	(CPOCLU)	;CONST POOL CLUE
	ISE	(CPOFIL)	;CONST POOL FILE
	JMPF	(DCORE2)	;$2
DCORE1:
	DFA	(CPOROL)	;CONST POOL ROLL
	POWF	(D1)		;ONE
	PNGF	(CPOROL)	;CONST POOL ROLL
	STOF	(CPOPNT)	;CONST POOL PNTR
	DIMF	(CPOPNT)	;CONST POOL PNTR
	JMPF	(DCORE3)	;$3
	W2	(SEQ)		;W2
	POWT	(D2)		;TWO
	DIMT	(CPOPNT)	;CONST POOL PNTR
	JMPT	(DCORE4)	;$4
	CSE	(CPOFIL)	;CONST POOL FILE
	JMPT	(DCORE1)	;$1
DCORE2:
	PNG	(CPOROL)	;CONST POOL ROLL
	STO	(CPOPNT)	;CONST POOL PNTR
	MON	(CPOROL)	;CONST POOL ROLL
DCORE3:
	MON	(CPOROL)	;CONST POOL ROLL
DCORE4:
	CLA	(CPOPNT)	;CONST POOL PNTR
	XIT	(BFIML)		;BUILD FINAL	;"21D"
PRORUN:					;PROGRAM RUN
SCAOPE:					;SCAN OPEN
	FET	(INTEPN)	;INITIAL TEMP PNTR
	STO	(AFDTPN)	;ARITH FUNC DEF TEMP PNTR
	FET	(FALCON)	;FALSE CONST
	MON	(ICOROL)	;INT CONST ROLL
	FET	(TRUCON)	;TRUE CONST
	MON	(ICOROL)	;INT CONST ROLL
	FET	(ONE)		;ONE
	MON	(ICOROL)	;INT CONST ROLL
	FET	(TWO)		;TWO
	MON	(ICOROL)	;INT CONST ROLL
	FET	(MOSPOS)	;MOST POSITIVE
	MON	(ICOROL)	;INT CONST ROLL
	FET	(ZERO)	;ZERO
	MON	(FCOROL)	;FL CONST ROLL
	FET	(ZERO)		;"23EE"
	MON	(FCOROL)	;"23EE"
	NOZ	(FSTFLA)
	NOZ	(LOCCNT)	;LOC CNT
	EAW	(NOFREG)
SCAOP1:
	JOW	(PRORU1)
	EAW	(D0)
	MON	(REGROL)
	JMP	(SCAOP1)

PRORU1:
	SNZ	(ESTFLA)
	XMLF	(NLIML)
	JMPT	(FINUP)
	SNZ	(CCAFLA)
	JSBF	(STASCA)
	JMPF	(PRORU1)
PRORU2:
	DIM	(LCANUM)
PRORU4:
	SCE	(CRR)
	JSBF	(NEXCHA)
	JMPF	(PRORU4)
	LCE	(M15QT)
	JSB	(ISTPAR)
	JSB	(PRISTA)
	JSB	(OUTCOD)
	ZER	(CCAFLA)
	XML	(NLIML)
	SNZ	(CCAFLA)
	JMPT	(PRORU2)
PRORU3:
	LCE	(M15QT)
	JSB	(PRISTA)
	JMP	(PRORU1)
SCACLO:					;SCAN CLOSE
; BUILD ENTRY AND EXIT FOR SUBS AND FUNCTS
; NAME OF PROG PNTR         ENTRY NAME EM
; R50 PROG NAME
; BEGIN EXECUTION PNTR
; RETURN PNTR
	XNI	(NOPPNT)	;NAME OF PROG PNTR
	FET	(ZERRUN)	;ZERO RUNG
	SEK	(MAITES)	;MAIN. TEST
	ZERF	(MSTLOC)	;MAIN START LOC
	JMPF	(SCACL1)	;$1
	SNZ	(ENDCOD)	;END CODE ALREADY GENERATED ?	;"23P"
	JMPT	(SCACL3)	;YES, GENERATE THE RESET.	;"23P"
	LSS	(EXIT.)	;EXIT.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	BAI	(.JSA1)	;JSA 16,INST
SCACL3:				;"23P"
	JSB	(BENHEA)	;BIN ENTRY HEADER
	MOA	(CODROL)	;CODE ROLL
	POC	(..RES0)	;RESET. INST
	FET	(LOCCNT)	;LOC CNTR
	SNZ	(ENDCOD)	;END CODE ALREADY GENNED ?	;"23P"
	W0F	(TLY)		;NO, COUNT THE CALL TO EXIT	;"23P"
	W0	(TLY)		;COUNT THE RESET.	;"23P"
	STO	(MSTLOC)	;MAIN START LOC
	JSB	(BJTBEG)	;BIN JMP TO BEGINNING
	XML	(P2EML)	;PRUNE TWO EXIT
SCACL1:
	SEQ	(DATTES)	;DATA. TEST
	JSBF	(BJTRET)	;BIN JMP TO RETURN
	JSB	(BENHEA)	;BIN ENTRY HEADER
	MOAT	(CODROL)	;CODE ROLL
	MOAT	(CODROL)	;CODE ROLL
	XMLT	(P2EML)	;PRUNE TWO EXIT
	FET	(NOPPNT)	;GET NAME OF PROGRAM POINTER
	SME	(FSPEM)	;IS THIS PROGRAM A FUNCTION ?
	FTM	(SINFLA)	;YES,SET AN UNUSED FLAG
	JSB	(BSAAIA)	;BIN SAVE ACS AND INIT ARGS
	JSB	(BJTBEG)	;BIN JMP TO BEGINNING
	FET	(RETPNT)	;RETURN PNTR
	JSB	(MLBGEN)	;MADE LBL GEN
	SNZ	(MULRET)	;MULT RETURN? "22A"
	JMPF	(SCACL2)	;NO "22A"
	JSB	(PTEMAK)	;PERM TEMP MAKER "22A"
	DIM	(TEMCNT)	;CHANGE BACK TO END OF AC BLOCK ;"22A"
	STK	(RETPNT)	;RETURN PNT "22A"
	BAI	(.MEM2)		;MOVEM "22A"
SCACL2:			;"22A"
	JSB	(BREACS)	;BIN RESTORE ACS
	FET	(NOPPNT)	;NAME OF PROG PNTR
	XW0.0	(FET)		;GET THE PROGRAM NAME
	STO	(SYMBOL)	;SETUP FOR ISE SEARCH
	JSB	(TYPSET)	;GET THE PROPER TYPE "24-1"
				;LINE DELETED "24-1"
	FET	(RZEPNT)	;REG ZERO PNTR
	SRD	(GDMROL)	;GLOBAL DUMMY ROLL
	ZERF	(ARGCNT)	;ARGUMENT COUNT
	JSBT	(BREARG)	;BINARY RESTORE ARGS
	W1	(SWT)		;W1
	SMK	(FSPEM)	;FUNCT SPROG EM
	BTYT	(.ME0)	;MOVE INST
	SNZ	(MULRET)	;"22A"
	FETT	(RETPNT)	;RETURN POINT "22A"
	BAIT	(.SKG0)		;SKIPG "22A"
	FET	(ARGCNT)	;ARG CNT
	ADD	(RZEPNT)	;REG ZERO PNTR
	BAI	(.JRA1)		;JRA 16,XR16
	SNZ	(MULRET)	;"22A"
	XMLF	(P1EML)		;"22A"
	FET	(RETPNT)	;RETURN POINT "22A"
	BAI	(.ADD2)		;ADD "22A"
	POC	(ABSINS)	;ABSOLUTE INST "22A"
	POC	(.JRA2)		;JRA "22A"
	XML	(P1EML)	;PRUNE ONE EXIT

BENHEA:					;BIN ENTRY HEADER
	FET	(ELOOP)	;ENTRY LOADER OP
	MON	(CODROL)	;CODE ROLL
	FET	(RPRNAM)	;R50 PROG NAME
	IER	(ENAEM)	;ENTRY NAME EM
	MON	(CODROL)	;CODE ROLL
	XNI	(NOPPNT)	;NAME OF PROG PNTR
	FET	(ZERRUN)	;ZERO RUNG
	EAW	(PERCNT)	;PERCENT
	JSB	(ILACHA)	;INSERT LABEL CHAR
	JSB	(LBLMAK)	;LBL MAKER
	IOR	(LHAMAS)	;LEFT HALF MASK
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	POC	(ABSINS)	;ABS INST
	POC	(.ARG0)	;ARG INST
	XIT	(EXIML)	;EXIT
BJTBEG:					;BIN JMP TO BEGINNING
	FET	(BEXPNT)	;BEGIN EXECUTION PNTR
	JMP	(BJTRE1)	;BIN JMP TO RETURN $1
BJTRET:				;BIN JMP TO RETURN
	SNZ	(ENDCOD)	;END CODE ALREADY GENNED ?	;"23P"
	XITT	(EXIML)		;YES, RETURN	;"23P"
	SNZ	(MULRET)	;MULTIPLE RETURN? "22A"
	POCT	(ABSINS)	;ABS INST "22A"
	POCT	(.MEI1)		;"22A"
	SNZ	(RETPNT)	;RETURN PNTR
	JSBF	(LBLMAK)	;LBL MAKER
	STKF	(RETPNT)	;RETURN PNTR
	FETT	(RETPNT)	;RETURN PNTR
BJTRE1:
	BAI	(.JRST0)	;JRST INST
	XIT	(EXIML)	;EXIT
BSAAIA:					;BIN SAVE ACS AND INIT ARGS
	FET	(RZEPNT)	;REG O PNTR
	JSB	(BSRGEN)	;BLOCK SAVE REGS GEN
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	STK	(FARTEM)	;FIFTEEN ARG TEMP
	SRD	(GDMROL)	;GLOBAL DMY ROLL
	XITF	(P1EML)
	BAI	(.MEI0)
INIARG:					;INIT ARGS
	FET	(RZEPNT)	;START INDEXING AT 0(16)
	ZER	(GDMPNT)	;GLOBAL DMY PNTR
	JMP	(INIAR2)	;$2

INIAR3:
	POW	(D1)
	BIK	(.PSH1)
INIAR1:
	W0	(TLY)		;W0
INIAR2:
	DFA	(GDMROL)	;GLOBAL DMY ROLL
	ZER	(DSPFLA)	;DUMMY SPROG FLAG
	XMLF	(P1EML)	;PRUNE ONE EXIT
	SEK	(ASTERX)	;ASTERISK? "22A"
	STO	(SYMBOL)	;SYMBOL
	JMPT	(INIAR1)	;YES GO BACK "22A"
	ISE	(GSPFIL)	;GLOBAL SPROG FILE
	FETT	(CREPNT)	;CRRNT REG PNTR
	IPKT	(APNEM)	;ALLOC PNTR EM
	NOZT	(DSPFLA)	;DUMMY SPROG FLAG
	JSB	(IDCLAS)	;ID CLASSIFY
	JSBF	(REGSCA)	;REGISTER SCALAR
	SNZ	(DSPFLA)	;DUMMY SPROG FLAG
	W1T	(SWT)		;W1
	XNI	(GDMPNT)	;GLOBAL DMY PNTR
	STK	(ZERRUN)	;ZERO RUNG
	POWT	(D1)		;ONE
	JSB	(PTEMAK)	;PERM TEMP MAKER
	IOR	(CMUEM)	;CONST MULTIPLIER EM
	STO	(DAT1)	;DATA 1
	PNG	(GALROL)	;GENERAL ALLOC ROLL
	AGF	(GALFIL)	;GENERAL ALLOC FILE
	IER	(APNEM)	;ALLOC PNTR EM
	XW1.0	(STO)		;ZERO RUNG
	SNZ	(DSPFLA)	;DUMMY SPROG FLAG
	JMPT	(INIAR3)	;$3
	SMK	(SCAEM)	;SCALAR EM
	JMPF	(INIAR3)	;$4
INIAR4:
	W2	(SWT)		;W2
	W1	(SWT)		;W1
	BIK	(.PSH2)	;PUSH* XR16 INST
	W1	(SWT)		;W1
	W2	(SWT)		;W2
	SME	(DITEM)	;DOUBLE ITEM EM
	JMPF	(INIAR1)	;$1
	BAK	(.RRZ1)	;HRRZ 1 XR16 INST
	POC	(ABSINS)	;ABS INST
	POC	(.PSH3)	;PUSH 0 11 XR1 INST
	JSB	(PTEMAK)	;PERM TEMP MAKER
	POW	(D1)		;ONE
	JMP	(INIAR1)	;$1
BREARG:					;BIN RESTORE ARGS
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	CNT	(DEFROL)	;HOW MANY ARGS DEFINED ? ;"22P"
	SEQ	(ZERO)		;NONE ? ;"22P"
	POWT	(D1)		;YES, PRUNE TEMP POINTER ;"22P"
	BINF	(.RROI0)	;NO, HRROI 0 INST ;"22P"
	CNT	(GDMROL)	;GLOBAL DMY ROLL
	STK	(ARGCNT)	;ARG CNT
	ADD	(BREPNT)	;BLANK REG PNTR
BREAR1:
	ZER	(TEMP)	;CLEAR SUBI COUNT
BREAR2:
	SUB	(ONE)		;DECREMENT REG COUNT
	MOA	(GDMROL)	;GLOBAL DMY ROLL
	RELF	(DEFROL)	;RELEASE AERROL FOR FUTURE USE
	XITF	(P1EML)	;PRUNE ONE EXIT
	SEK	(ASTERX)	;ASTERISK? "22A"
	JMPT	(BREAR3)	;YES "22A"
	SMK	(SCAEM)	;SCALAR EM
	TLYF	(TEMP)		;ONLY SCALARS ARE ELIGABLE FOR ;"22P"
	POWF	(D1)		;RESTORATION ;"22P"
	JMPF	(BREAR2)	;SKIP IF NOT ELIGABLE ;"22P"
	XW0.0T	(FET)		;YES, GET NAME
	XW0.0T	(CLA)		;GET NAME ENTRY
	STOT	(SYMBOL)	;AND STORE FOR SEARCH
	ISET	(DEFFIL)	;HAS IT BEEN DEFINED ?
	JMPT	(BREAR4)	;YES, SKIP AROUND ;"22P"
	TLYF	(TEMP)		;INCREMENT SUBI COUNT
	SMK	(DITEM)		;DOUBLE ARG?"22P"
	TLYT	(TEMP)		;YES, INCREMENT SUBI COUNT "22P"
	POW	(D1)
	JMP	(BREAR2)
BREAR4:			;"22P"
	SNZ	(TEMP)
	FETT	(TEMP)
	ADDT	(RZEPNT)
	BAIT	(.SUBI0)	;SUBI 0,0
	SME	(DITEM)	;DOUBLE ITEM EM
	BAKT	(.RRO1)	;HRRO 1 XR16 INST
	POCT	(ABSINS)	;ABS INST
	POCT	(.POP1)	;POP 0 1 XR1 INST
	BIK	(.POP2)	;POP* XR16 INST
	JMP	(BREAR1)	;$1
BREAR3:
	POW	(D1)		;PRUNE ASTERISK "22A"
	JMP	(BREAR2)	;BACK "22A"
				;22 LINES DELETED	;"23C"
BREACS:				;BIN RESTORE ACS
	FET	(ABLPNT)	;GET AC BLOCK PNTR ;"21V"
	SNZ	(SINFLA)	;FUNCTION ? ;"21V"
	JMPF	(BREAC1)	;NO, RESTORE AC15/16 ONLY ;"21V"
	FET	(REGCNT)	;GET # OF CONTIGUOUS REGS ;"21V"
	SGT	(THREE)		;BLT OVERHEAD REQUIRED ? ;"21V"
	JMPF	(BREAC3)	;NO, GEN MOVE'S ;"21V"
	FET	(RONPNT)	;MAKE END OF REGS ;"21V"
	ADD	(REGCNT)	;POINTER ;"21V"
	W0	(TLY)		;CORRECTLY ;"21V"
	W1	(SWT)		;AND POSITION IT FOR THE BIK ;"21V"
	BIK	(.MSI0)		;GEN MOVSI END REG,BLOCK
	W1	(SWT)		;SAVE BLOCK PNTR FOR FUTURE USE ;"21V"
	FET	(RZEPNT)	;FAKE AN IMMEDIATE ;"21V"
	ADDA	(D2)		;MODE 2 ;"21V"
	BIN	(.HRRI0)	;GEN HRRI END REG,2 ;"21V"
	W0	(FET)		;GET END REG PNTR ;"21V"
	BIN	(.BLT0)		;GEN BLT END REG,END REG ;"21V"
	POW	(D1)		;PUT BLOCK PNTR BACK ON TOP ;"21V"
	W0	(TLY)		;MAKE PNTR COME OUT RIGHT ;"21V"
BREAC1:				;$1, TRY TO RESTORE AC15/16 ;"21V"
	ADDT	(REGCNT)	;POINT TO REG15 LOC ;"21V"
				;2 LINES DELETED "24-2"
	BAK	(.ME1)		;GEN MOVE 15,TEMP. ;"21V"
	W0	(TLY)		;POINT TO REG 16 LOC ;"21V"
BREAC2:			;$2, RESTORE AC16 ;"21V"
				;2 LINES DELETED "24-2"
	FET	(R16PNT)	;GET REG 16 PNTR ;"21V"

	W1	(SWT)		;PUT IN PROPER ORDER ;"21V"
	BIN	(.ME0)		;GEN MOVE 16,TEMP. ;"21V"
	XIT	(P1EML)		;EXIT PRUNING TEMP PNTR ;"21V"
BREAC3:				;$3, RESTORE WITH MOVE'S ;"21V"
	SNZ	(REGCNT)	;ANY REGS SAVED ? ;"21V"
	JMPF	(BREAC1)	;NO, TRY AC 15/16 ;"21V"
	FET	(RONPNT)	;GET REG ONE PNTR ;"21V"
	FET	(REGCNT)	;GET # OF REGS SAVED ;"21V"
	W2	(SWT)		;PUT IN PROPER ORDER ;"21V"
BREAC4:				;$4, ITERATION POINT ;"21V"
	W2	(DIM)		;DECREMENT REG COUNT ;"21V"
	W1	(TLY)		;INCREMENT REG COUNT ;"21V"
	BIK	(.ME0)		;GEN MOVE 2/3/4,BLOCK/+1/+2 ;"21V"
	W0	(TLY)		;INCREMENT TEMP PNTR ;"21V"
	W2	(SNZ)		;MORE REGS TO RESTORE ? ;"21V"
	JMPT	(BREAC4)	;YES, RESTORE THEM ;"21V"
	W2	(SWT)		;PUT COUNT ON TOP ;"21V"
	POW	(D2)		;PRUNE COUNT & REG PNTR ;"21V"
	JMP	(BREAC1)	;"21V"
				;LINE DELETED	;"23C"
STASCA:					;STA SCAN
	FEX	(SSCFIN)	;STA SCAN FINISH
	XML	(RREML)	;REGS RESET
	ZER	(FAICAR)	;FAIL CARD-COL
	FET	(AFDTPN)	;ARITH FUNC DEF TEMP PNTR
	STO	(LTEPNT)	;LOCAL TEMP PNTR
	SCK	(COMKEY)	;COMMENT KEY
	SCEF	(CRR)		;CARRIAGE RETURN
	JMPT	(SSCFIN)	;STA SCAN FINISH
	JSB	(LFIXLA)	;LBL FIELD XLATE
	ZER	(IOLFLA)	;IOL FLAG
	ZER	(ISAFLA)	;IF STA ACTIVE FLAG
	RSV	(ERRROL)
	SCE	(CRR)		;DID LFIXLA FIND A <CR> ?	;"23E"
	JSBF	(STAXLA)	;NO, STA XLATE
SSCFIN:					;STA SCAN FINISH
	RSV	(LIMROL)	;LIMITS ROLL
	EAW	(LIMROL)	;LIMITS ROLL
	CAR	(ERRROL)	;ERROR ROLL
	EAW	(ERRROL)	;ERROR ROLL
	CAR	(LIMROL)	;LIMITS ROLL
	SNZ	(FORFLA)	;FORMAT STA FLAG
	ZERT	(FORFLA)	;FORMAT STA FLAG
	JSBF	(PRISTA)	;PRINT STATEMENT
	REL	(ERRROL)	;ERROR ROLL
	JSB	(OUTCOD)	;OUTPUT CODE
	REL	(TEMROL)	;TEMP ROLL
	REL	(SUBROL)	;SUBEXP ROLL
	REL	(APLROL)	;ARG PLEX ROL "20E"
	XIT	(EXIML)	;EXIT
LFIXLA:					;LBL FIELD XLATE
	JSB	(DCOINI)
	XML	(LFXML)
	JMPF	(LFIXL3)	;$3
IFNDEF	$CREF,
<
	SNZ	(CRFSW)
	FETT	(DAT2)
	XMLT	(BTOBCD)
	MONT	(CRFROL)
>
	REG	(LBLFIL)	;LBL FILE
	CLA	(LBLPNT)	;LBL PNTR
	SPKT	(DEFTRA)	;DEFINED TRAIT
	IPKT	(MDETRA)	;MUL DEFINED TRAIT
	IPKF	(DEFTRA)	;DEFINED TRAIT
	MOA	(DLOROL)	;DO LOOPS OPEN ROLL
	STKT	(SLBPNT)	;STA LBL PNTR
	MONT	(DLOROL)	;DO LOOPS OPEN ROLL
	SMKT	(SLPEM)	;STA LBL EM
	ZERF	(IIVPNT)	;INSIDE INDUC VAR PNTR
LFIXL3:
	STO	(SLBPNT)	;STA LBL PNTR
	JMP	(ICLGEN)	;IF CLOSE GEN
STAXLA:					;STA XLATE
	XML	(SSAML)	;STATUS CONTROL
	FEX	(MPRXLA)	;MAIN PROGRAM XLATE
	SCE	(S)		;S
	JMPT	(SSTXLA)	;SUBROUTINE STA XLATE
	SCE	(F)		;F
	JMPT	(FSTXLA)	;FUNCTION STA XLATE
	SCE	(I)		;I
	JMPT	(IFSXLA)	;INTEGER FUNCTION STA XLATE
	SCE	(R)		;R
	JMPT	(RFSXLA)	;REAL FUNCTION STA XLATE
	SCE	(D)		;D
	JMPT	(DPFSXL)	;DOUBLE PREC FUNCTION STA XLATE
	SCE	(C)		;C
	JMPT	(CFSXLA)	;COMPLEX FUNCTION STA XLATE
	SCE	(L)		;L
	JMPT	(LFSXLA)	;LOGICAL FUNCTION STA XLATE
IFNDEF	$DATA,
<
	SCE	(B)		;B
	JMPT	(BDSXLA)	;BLOCK DATA STA XLATE
>
	JMP	(MPRXLA)	;MAIN PROGRAM XLATE
SSTXLA:					;SUBROUTINE STA XLATE
	QSF	(SUBQT)	;SUBROUTINE QT
	JSB	(SYMSCA)	;SYMBOL SCAN
	JSB	(REGSCA)	;REGISTER SCALAR
	CSA	(LPAREN)	;L PAREN
	JMPF	(SHEEXI)	;SPROG HEAD EXIT
	JMP	(DSESCA)	;DMY SEQ SCAN

IFNDEF	$DATA,
<
BDSXLA:					;BLOCK DATA STA XLATE
	QSF	(BLOQT)	;BLOCK QT
	CSF	(D)		;D
	QSF	(ATAQT)	;ATA QT
	SCE	(CRR)
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	SNZ	(FSTFLA)	;FIRST STA FLAG
	LCFF	(O1QT)	;ORDER QT
	LSS	(DAT.)
	NOZ	(BDPFLA)	;BLOCK DATA PROG FLAG
	JMP	(HSTFIN)	;HEAD STA FINISH
>

IFSXLA:					;INTEGER FUNCTION STA XLATE
	QSF	(INTQT)
	CSA	(ASTERI)	;INTEGER=	;"23G"
	CSA	(N2)		;INTEGER*2	;"23G"
	FTM	(SINFLA)	;"23G"
	CSA	(N4)		;OR INTEGER*4	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(IIDFIL)	;INTEGER ID FILE
	SNZ	(SINFLA)	;SUBSCRIPT INTEGER ? ;"23G"
	AGFT	(SIIFIL)	;YES, DEFINE IT ;"23G"
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
RFSXLA:					;REAL FUNCTION STA XLATE
	QSF	(REAQT)		;REAL QT
	CSA	(ASTERI)	;REAL=	;"23G"
	CSAT	(N8)		;REAL*8 ?	;"23G"
	JMPT	(DPFSX1)	;YES, DOUBLE PRECISION=REAL*8	;"23G"
	CSA	(N4)		;REAL*4	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(RIDFIL)	;REAL ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
DPFSXL:					;DOUBLE PREC FUNCTION STA XLATE
	QSF	(DPRQT)	;DOUBLE PRECISION QT
DPFSX1:			;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(DPIFIL)	;DOUBLE PREC ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
CFSXLA:					;COMPLEX FUNCTION STA XLATE
	QSF	(COMPQT)	;COMPLEX QT
	CSA	(ASTERI)	;COMPLEX=	;"23G"
	CSAT	(N1)		;"23G"
	SCET	(N6)		;COMPLEX*16 ?	;"23G"
	CCFT	(S5QT)		;YES, ILLEGAL TYPE SPECIFICATION
	CSA	(N8)		;COMPLEX*8	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(CIDFIL)	;COMPLEX ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
LFSXLA:					;LOGICAL FUNCTION STA XLATE
	QSF	(LOGQT)
	CSA	(ASTERI)	;LOGICAL=	;"23G"
	CSA	(N1)		;LOGICAL*1	;"23G"
	CSA	(N4)		;OR LOGICAL*4	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(LIDFIL)	;LOGICAL ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
FSTXLA:					;FUNCTION STA XLATE
	JSB	(FNASCA)	;FUNCTN NAME SCAN
FDSSCA:					;FUNCTION DMY SEQ SCAN
	CSF	(LPAREN)	;L PAREN
	JSB	(REGSCA)	;REGISTER SCALAR
	IER	(FSPEM)	;FUNC SPROG EM
DSESCA:					;DMY SEQ SCAN
	CSA	(DOLLAR)	;$? "22A"
	CSAF	(ASTERI)	;*? "22A"
	FETT	(ASTERX)	;ASTERISK "22A"
	MONT	(GDMROL)	;"22A"
	NOZT	(MULRET)	;SET FOR MULTIPLE RETURN "22A"
	JMPT	(DSESC1)	;"22A"
	JSB	(IDSCAN)	;ID SCAN
	REGF	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I1QT)	;ID CONFLICT QT
DSESC1:				;"22A"
	CSA	(COMMA)	;COMMA
	JMPT	(DSESCA)	;DMY SEQ SCAN
	CSF	(RPAREN)	;R PAREN
SHEEXI:					;SPROG HEAD EXIT
	SCE	(CRR)
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	SNZ	(FSTFLA)	;FIRST STA FLAG
	LCFF	(O2QT)	;ORDER QT
	XW0.0	(FET)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	STO	(NOPPNT)	;NAME OF PROG PNTR
HSTFIN:					;HEAD STA FINISH
	JSB	(GHEGEN)	;GLOBAL HEAD GEN
	XML	(SSAML)	;STATUS CONTROL
	XIT	(ETRML)	;EXIT TRUE EOL
FNASCA:					;FUNCTN NAME SCAN
	QSF	(FUNQT)	;FUNCTION QT
SYMSCA:
	ZER	(SYMBOL)
	SCK	(LETKEY)
	XITF	(NFAML)
	XML	(SYMSC1)	;SYMBOL SCAN
IFNDEF	$CREF,
<
	SNZ	(CRFSW)
	FETT	(SYMBOL)
	MONT	(CRFROL)
>
	XIT	(EXIML)

IIAEXI:					;ILLEGAL IF ARG EXIT
	LCE	(M4QT)	;ILLEGAL IF ARG QT
	XIT	(IIAEX1)	;$1

	POW	(D3)		;THREE
	REL	(CODROL)	;CODE ROLL
	JMP	(ISTPAR)	;ILLEGAL STA PARSE
MPRXLA:					;MAIN PROGRAM XLATE
	SNZ	(FSTFLA)	;FIRST STA FLAG
	LSST	(MAIN.)	;MAIN.
	JSBT	(GHEGEN)	;GLOBAL HEAD GEN
IASXLA:					;IF ARG STA XLATE
	XMLT	(SSAML)	;STATUS CONTROL
	FEX	(FEXFDG)	;ASSIGNMENT OR AFDS XLATE
	CSA	(G)		;G
	JMPT	(GTOGRO)	;GO TO GROUP
	CSA	(D)		;D
	JMPT	(DODODI)	;DO OR DATA OR DIMENSION
ISTXLA:					;IF STA XLATE
	QSF	(IF.QT)	;IF(QT
	JSB	(ESACOL)	;EXP SCAN AND COLLAPSE
	CSF	(RPAREN)	;R PAREN
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(LISXLA)	;LOGICAL IF STA XLATE
	JSB	(EIRGEN)	;EXP IN REG GEN
	SMK	(CTYEM)	;COMPLEX EXPRESSION?
	LCFT	(M4QT)	;YES, ERROR
	JSB	(LBLSCA)
	CSF	(COMMA)
	AND	(RHAMAS)
	JSB	(LBLSCA)
	SCE	(CRR)		;"23HH"
	ANDT	(RHAMAS)	;"23HH"
	W0T	(FET)		;"23HH"
	JMPT	(ISTXL1)	;"23HH"
	CSF	(COMMA)
	AND	(RHAMAS)
	JSB	(LBLSCA)
	SCE	(CRR)
	CCFF	(S10QT)
	AND	(RHAMAS)	;RIGHT HALF MASK
ISTXL1:				;"23HH"
	W3	(FET)		;W3
	SME	(MINEM)	;MINUS EM
	W2T	(SWT)		;W2
	NOZ	(ISAFLA)	;IF STA ACTIVE FLAG
	JMP	(GEXFIN)	;GOTO EXIT FIN
LISXLA:					;LOGICAL IF STA XLATE
	SCE	(EQUAL)
	XITT	(FAIML)		;FAIL	;"23A"
	JMPT	(FAIL)	;FAIL
	ZER	(IIAFLA)	;ILLEGAL IF ARG FLAG
	FET	(SLBPNT)	;STA LBL PNTR
	W1	(SWT)		;W1
	JSB	(LAPSAV)	;LOOK AHEAD POSITION SAVE
	QSA	(GOTQT)	;GOTO QT
	SCKT	(DIGKEY)	;DIGIT KEY
	JSBF	(LAPRES)	;LOOK AHEAD POSITION RESET
	NOZT	(IIAFLA)	;ILLEGAL IF ARG FLAG
	SMK	(SUBEM)	;SUBEXP EM
	SPKT	(OTAEM)	;OP TABLE EM
	XW0.0T	(FET)		;OP PNTR RUNG
	SPTT	(ROPTRA)	;REL OP TRAIT
	JMPT	(LISXL3)	;$3
	JSB	(EIRGEN)	;EXP IN REG GEN
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	EORT	(NOTMAS)	;NOT MASK
	SMK	(NOTEM)	;NOT EM
	EAWT	(.JUL0)	;JUMPL INST
	EAWF	(.JUGE0)	;JUMPGE INST
	JMP	(LISXL2)	;$2
LISXL3:
	XW0.1	(FET)		;A PART RUNG
	XW1.2	(FET)		;B PART RUNG
	XW2.0	(FET)		;OP PNTR RUNG
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(RELDIS)	;RELATIONAL OP DISPATCH
	W0	(FET)		;W0
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	EORT	(SEVEN)	;SEVEN
	W5	(EOM)		;W5
	SEQ	(ZERO)	;ZERO
	JSBT	(RELGE9)	;REL GEN $9
	POW	(D1)		;ONE
	EAWT	(.JRST0)	;JRST INST
	EAWF	(.JUG0)	;JUMPG INST
	W3F	(AMY)		;W3
	W3T	(STO)		;W3
	CLAT	(RZEPNT)	;REG ZERO PNTR
	W3	(STO)		;W3
	POW	(D1)		;ONE
LISXL2:
	W1	(SWT)		;W1
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	ZER	(IIAFLA)	;ILLEGAL IF ARG FLAG
	JSBT	(LBLSCA)	;LBL SCAN
	NOZT	(JOUFLA)	;JUMP OUT FLAG
	JSBF	(LBLMAK)	;LBL MAKER
	STKF	(SLBPNT)	;STA LBL PNTR
	W2	(FET)
	XML	(BINIML)
	JMPT	(LISXL1)	;$1
	FET	(ASTFLA)	;ACTIVE STA FLAG
	NOZ	(ASTFLA)	;ACTIVE STA FLAG
	XML	(RREML)	;REG RESET
	REL	(SUBROL)	;SUBEXP ROLL
	JSB	(IASXLA)	;IF ARG STA XLATE
	JSB	(DISTES)	;DOUBLE IF STA TEST
	STO	(ASTFLA)	;ACTIVE STA FLAG
	FET	(SLBPNT)	;STA LBL PNTR
	JSB	(MLBGEN)	;MADE LBL GEN
LISXL1:
	POW	(D2)		;TWO
	STO	(SLBPNT)	;STA LBL PNTR
	JMPF	(ISTPAR)	;ILLEGAL STA PARSE
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	JMPT	(IIAEXI)	;ILLEGAL IF ARG EXIT
	JMP	(LIFEXI)	;LOGICAL IF EXIT
DODODI:					;DO OR DATA OR DIMENSION
	CSA	(O)		;LETTER O
	JMPF	(DORDIM)	;DATA OR DIMENSION
DSTXLA:					;DO STA XLATE
	JSB	(LBLSCA)	;LBL SCAN
	JSB	(IVASCA)	;INDUC VAR SCAN
	JSB	(DCOXLA)	;DO CONTROL XLATE
	MON	(DLOROL)	;LABEL OF DO CLOSE
	JMP	(DOEOEX)	;DO EOL EXIT
DCOXLA:					;DO CONTROL XLATE
	CSF	(EQUAL)	;EQUAL
	NOZ	(SAV15)		;SAVE REG 15 ONLY IF USED ;"21V"
	ISE	(GDMFIL)	;GLOBAL DEFINITION ?
	REGT	(DEFFIL)	;YES, REGISTER AS DEFINED
	JSB	(FESACO)	;FX EXP SCAN AND COLLAPSE
	JSB	(STATCK)	;"23S"
				;4 LINES DELETED "24-3"
	CSF	(COMMA)		;COMMA ;W0<-INDEX
				;10 LINES REMOVED ;"23S"
				; LINE DELETED ;"23S"
	JSB	(EXPSCA)	;EXP SCAN ;W0<-FINAL
	SMK	(ITYEM)	;INTEGER TYPE EM
	LCFF	(M12QT)		;NON-INTEGER ERR "20F"
	CSA	(COMMA)	;COMMA
	JSBT	(FESACO)
	FETF	(CONPNT)	;CONST ONE PNTR ;W0<-INCR
	W1	(SWT)		;W1
	JSB	(SUBCOL)	;SUBEXP COLLAPSE
	SMK	(SCAEM)		;6 LINES INSERTED ;"23S"
	SMKF	(CONEM)		;"23S"
	JMPT	(DCOXL2)	;"23S"
	JSB	(STATCK)	;"23S"
	JSB	(EIRGEN)	;"23S"
	JSB	(PTEMAK)	;"23S"
	BIK	(.MEM0)		;"23S"
	W1	(STO)		;"23S"
DCOXL2:				;FINAL<-SCALAR OR TEMP ;"23S"
	W1	(SWT)		;W1
	SMK	(SCAEM)		;7 LINES INSERTED ;"23S"
	SMKF	(CONEM)		;"23S"
	JMPT	(DCOXL3)	;"23S"
	JSB	(STATCK)	;"23S"
	JSB	(EIRGEN)	;"23S"
	JSB	(PTEMAK)	;"23S"
	BIK	(.MEM0)		;"23S"
	W1	(STO)		;"23S"
DCOXL3:				;INCR<-SCALAR OR TEMP ;"23S"
	W1	(SWT)		;W0<-FINAL;W1<-INCR;"24-3"
	W2	(SWT)		;W0<-INIT;W1<-INCR;W2<-FINAL ;"24-3"
	JSB	(GENRUN)	;GEN RUN ;"24-3"
	SMK	(MINEM)		;MINUS EM ;"24-3"
	BAIT	(.MN1)		;MOVN DO REG INST ;"24-3"
	BAIF	(.ME1)		;"24-3"
	W2	(FET)		;W0<-INDEX ;"23S"
	JSB	(LBLMAK)	;LBL MAKER ;10 LINES REPLACED ;"23S"
	JSB	(MLBGEN)	;MADE LBL GEN ;"23S"
	FET	(DREPNT)	;DO REG PNTR ;"23S"
	W1	(SWT)		;W1 ;"23S"
	BIK	(.MEM0)	;MOVEM INST ;"23S"
	W1	(STO)		;W1 ;"23S"
	STK	(IIVPNT)	;INSIDE INDUC VAR PNTR ;"23S"
	JSB	(LBLMAK)	;LBL MAKER ;"23S"
	JSB	(MLGAKE)	;W0<-MADE LBL ;"23S"
	RSV	(DLOROL)	;DO LOOPS OPEN ROLL ;10TH LINE REPLACED ;"23S"
	W3	(SWT)		;W3<-MADE LABEL;W0<-FINAL ;"23S"
	W2	(SWT)		;W2<-FINAL;W0<-INCR ;"23S"
	W1	(STO)		;PRUNE EXTRA INDEX ;"23S"
;'2 LINES DELETED	;"23S"
	MON	(DLOROL)	;INCREMENT EXP PNTR
	MON	(DLOROL)	;FINAL VALUE EXP PNTR
	MON	(DLOROL)	;MADE LABEL TO RETURN TO
	MON	(DLOROL)	;INDEX VAR PNTR
	FET	(JOUFLA)	;JUMP OUT FLAG
	MON	(DLOROL)	;DO LOOPS OPEN ROLL
	ZER	(JOUFLA)	;JUMP OUT FLAG
	NOZ	(SAV15)		;SAVE REG 15 ONLY IF DO OR IMPLIED DO ;"21V"
	XIT	(EXIML)	;EXIT

STATCK:				;"23S"
	SNZ	(IMDFLG)	;INSIDE IMPLIED DO? "23S"
	SMKT	(SUBEM)		;YES, PNTR TO SUBEXP?"23S"
	XITF	(EXIML)		;NO "23S"
	XW0.3	(FET)		;GET STATUS RUNG "23S"
	SME	(REGEM)		;EXP IN REG? "23S"
	XW0.3T	(ZER)		;YES SET STATUS ZERO "23S"
	XIT	(EXIML)		;"23S"
DORDIM:					;DATA OR DIMENSION
IFNDEF	$DATA,
<
	CSA	(I)		;I
	JMPF	(DASTXL)	;DATA STA XLATE
>
IFDEF	$DATA,
<
	CSF	(I)
>

DISTXL:					;DIMENSION STA XLATE
	QSF	(MENQT)	;MENSION QT
DISTX1:
	JSB	(IDSCAN)	;ID SCAN
	CCFT	(I2QT)	;ID CONFLICT QT
	CSF	(LPAREN)	;LEFT PAREN
	JSB	(DSEXLA)	;DIMENSION SEQ XLATE
	CSA	(COMMA)	;COMMA
	JMPT	(DISTX1)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
DSEXLA:					;DIMENSION SEQ XLATE
	FET	(SYMBOL)	;SYMBOL
	ISE	(ARRFIL)	;ARRAY FILE
	CCFT	(I2QT)	;ID CONFLICT QT
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	FTM	(DARFLA)	;DMY ARRAY FLAG
DSEXL1:
	JSB	(LPASCA)	;LIMIT PAIR SCAN
	JMPF	(DSEXL4)	;$4
	W1	(SUB)		;W1
	ADD	(ONE)		;ONE
	SLK	(ONE)		;ZERO
	LCFT	(A1QT)	;ALLOCATION QT
	MON	(LIMROL)	;LIMITS ROLL
	MON	(LIMROL)	;LIMITS ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(DSEXL1)	;$1
	FET	(ZERO)	;ZERO
	FET	(ONE)		;ONE
	FET	(ZERO)	;ZERO
	FLP	(LIMROL)	;LIMITS ROLL
DSEXL2:
	W1	(CLA)		;W1
	MON	(DIMROL)	;DIMENS ROLL
	MOA	(LIMROL)	;LIMITS ROLL
	MOA	(LIMROL)	;LIMITS ROLL
	W2	(MPY)		;W2
	W3	(ADD)		;W3
	W3	(STO)		;W3
	W0	(FET)		;W0
	W2	(MPY)		;W2
	W2	(STO)		;W2
	SRD	(LIMROL)	;LIMITS ROLL
	JMPF	(FNDXLA)	;FINISH NON-DMY DIMENS XLATE
	JMP	(DSEXL2)	;$2

DSEXL4:
	FLP	(LIMROL)	;LIMITS ROLL
DSEXL5:
	MOA	(LIMROL)	;LIMITS ROLL
	JMPF	(DSEXL6)	;$6
	SUB	(ONE)		;ONE
	MOA	(LIMROL)	;LIMITS ROLL
	W1	(SWT)		;W1
	W1	(ADD)		;W1
	JSB	(VDIREG)	;VAR DIMENS REGISTER
	SRD	(LIMROL)	;LIMITS ROLL
	MON	(DIMROL)	;DIMENS ROLL
	JMPT	(DSEXL5)	;$5
DSEXL6:
	JSB	(PTEMAK)	;PERM TEMP MAKER
	MON	(DIMROL)	;DIMENS ROLL
DSEXL7:
	MON	(DARROL)	;DIMENS ARG ROLL
	JSB	(SDIREG)	;SCALAR DIMEN REGISTER
DSEX10:
	CSA	(COMMA)	;COMMA
	JMPF	(DSEXL8)	;$8
	MON	(DIMROL)	;DIMENS ROLL
	JSB	(LPASCA)	;LIMIT PAIR SCAN
	JMPF	(DSEXL7)	;$7
	JSB	(VDIREG)	;VAR DIMENS REGISTER
	JMP	(DSEX10)	;$10

DSEXL8:
	FET	(ZERO)	;ZERO
	JSB	(PTEMAK)	;PERM TEMP MAKER
	JSB	(FDIXLA)	;FINISH DIMENS XLATE
	FET	(ZERO)	;ZERO
	JSB	(TYPSET)	;TYPE SET
	LSS	(ADJ.)	;ADJ.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(R16PNT)	;R16 PNTR
	FET	(CREPNT)	;CRRNT REG PNTR
	BIN	(.JSA0)	;JSA INST
	POW	(D1)		;ONE
	CNT	(DARROL)	;DIMENS ARG ROLL
	W1	(SWT)		;W1
	JSB	(MTYREG)	;MAKE TYPE REG
	W2	(CLA)		;W2
	DIV	(TWO)		;TWO
	POC	(ABSINS)	;ABS INST
	BAI	(.ARG0)	;ARG INST
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	BIN	(.ARG0)	;ARG INST
	POW	(D1)		;ONE
	FLP	(DARROL)	;DIMENS ARG ROLL
DSEX12:
	JOW	(EXIT)	;EXIT
	MOA	(DARROL)	;DIMENS ARG ROLL
	BAI	(.ARG0)	;ARG INST
	JMP	(DSEX12)	;$2
FNDXLA:					;FINISH NON-DMY DIMENS XLATE
	CLA	(ZERO)	;ZERO
FDIXLA:					;FINISH DIMENS XLATE
	CSF	(RPAREN)	;R PAREN
	EAW	(DIMROL)	;DIMENSION ROLL
	RPL	(ASTROL)	;ARRAY STAT ROLL
	REL	(DIMROL)
	STO	(DAT3)		;DATA 3 - ARRAY STATUS ROLL PNTR
	STO	(DAT4)		;DATA 4
	SMK	(LHZEM)		;ARRAY SIZE < 2**18 ?	;"21E"
	LCFF	(M6QT)		;ARRAY TOO LARGE ERROR	;"21E"
	STO	(DAT2)		;DATA 2 - ARRAY SIZE
	STO	(DAT1)		;DATA 1
	STO	(SYMBOL)	;SYMBOL 1 - ARRAY NAME
	AGF	(ARRFIL)	;ARRAY FILE
	XIT	(EXIML)	;EXIT
VDIREG:					;VAR DIMENS REGISTER
	JSB	(RWOCON)	;REGISTER WORK CONST
	MON	(DARROL)	;DIMENS ARG ROLL
	JSB	(RWOCON)	;REGISTER WORK CONST
SDIREG:					;SCALAR DIMEN REGISTER
	MON	(DARROL)	;DIMENS ARG ROLL
	JMP	(PTEMAK)	;PERM TEMP MAKER
LPASCA:					;LIMIT PAIR SCAN
	JSB	(LIMSCA)	;LIMIT SCAN
	JMPF	(LPASC2)	;$2
	CSA	(SLASH)	;SLASH
	CLAF	(ONE)		;ONE
	FETF	(DAT2)	;DATA 2
	XMLF	(ETRML)	;EXIT TRUE
	JSB	(LIMSCA)	;LIMIT SCAN
	XMLT	(ETRML)	;EXIT TRUE
	W1	(SWT)		;W1
	JMP	(LPASC3)	;$3
LPASC2:
	CSA	(SLASH)	;SLASH
	JMPT	(LPASC4)	;$4
	FET	(ONE)		;ONE
LPASC3:
	JSB	(RWOCON)	;REGISTER WORK CONST
	W1	(SWT)		;W1
	JMP	(EXIFAL)	;EXIT FALSE
LPASC4:
	JSB	(LIMSCA)	;LIMIT SCAN
	JSBT	(RWOCON)	;REGISTER WORK CONST
	JMP	(EXIFAL)	;EXIT FALSE
LIMSCA:					;LIMIT SCAN
	SNZ	(DARFLA)	;DMY ARRAY FLAG
	SCKT	(LETKEY)	;LETTER KEY
	JSBF	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	XMLF	(ETRML)	;EXIT TRUE
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)	;SCALAR EM
	ISET	(GDMFIL)	;GLOBAL DMY FILE
	LCFF	(A4QT)	;ALLOCATION QT
	AND	(RHAMAS)	;RIGHT HALF MASK
EXIFAL:
	XIT	(EFAML)

FEXFDG:					;FEX FUDGE
	JMP	(AOAXLA)
IFNDEF	$DATA,
<
DASTXL:					;DATA STA XLATE
	QSF	(ATAQT)	;ATA QT
DASTX1:
	ZER	(DDOCNT)	;DATA DO CNT
	JSB	(DLIXLA)	;DATA LIST XLATE
	STO	(DLICNT)	;DATA LIST CNT
	EAW	(DLIROL)	;DATA LIST ROLL
	CAR	(CODROL)	;CODE ROLL
	CSF	(SLASH)	;SLASH
IFNDEF	HALFWD,			;"23DD"
<	FEX	(ISTPAR)	;"23DD"
>				;"23DD"
	SNZ	(DDOCNT)	;STR795, IS DO COUNT ZERO ?
	LCFT	(S17QT)		;NO, TOO MANY PARENS
	JSB	(DITXLA)	;DATA ITEMS XLATE
	JSB	(DSVCHE)	;DATA SCRIPT VAR CHECK
	CSF	(SLASH)	;SLASH
	FET	(DITCNT)	;DATA ITEMS CNT
	SEQ	(DLICNT)
	LCFF	(M11QT)		;M-11 MORE DATA NEEDED 	;"23K"
	CSA	(COMMA)	;COMMA
	JMPT	(DASTX1)	;$1
	SCE	(CRR)
	CCFF	(S9QT)		;ILL DELIM ERROR	;"23M"
	SRD	(CODROL)	;CODE ROLL
	JSBT	(OUTCOD)	;OUTPUT CODE
	FET	(DENLOP)	;DATA END LOP
	MON	(DLIROL)	;DATA LIST ROLL
	CNT	(DLCROL)	;DATA LIST CONST ROLL
	CNT	(DITROL)	;DATA ITEMS ROLL
	CNT	(DLIROL)	;DATA LIST ROLL
	W2	(FET)		;W2
	W2	(ADD)		;W2
	W1	(ADD)		;W1
	ADDA	(D3)		;THREE
	IOR	(DSTLOP)	;DATA STA LOP
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(DLIROL)	;DATA LIST ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(DITROL)	;DATA ITEMS ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(DLCROL)	;DATA LIST CONST ROLL
	JSB	(PDASTA)	;PUNCH DATA STA
	ZER	(DSTFLA)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)
>
IFNDEF	$DATA,
<
DLIXLA:					;DATA LIST XLATE
	FET	(ZERO)	;ZERO
	RSV	(CODROL)	;CODE ROLL
DLIX12:
	CSA	(LPAREN)	;L PAREN
	JMPF	(DLIX13)	;STR795
	TLY	(DDOCNT)	;DATA DO CNT
	JSB	(DLIXLA)	;DATA LIST XLATE
	CSA	(RPAREN)	;R PAREN
	LCFF	(S17QT)		;PAREN MISSING
	JMP	(DLIXL5)	;$5
DLIX13:	JSB	(IDSCAN)	;ID SCAN
	JMPT	(DLIX14)	;CHECK FOR IMPLIED DO CONSTRUCT
	SCE	(EQUAL)	;EQUAL
	JMPT	(DLIXL6)	;$6
	JSB	(REGSCA)	;REGISTER SCALAR
DLIXL2:
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I11QT)	;ID CONFLICT QT
	JSB	(CELSIZ)	;CALC ELEMENT SIZE
	SMK	(SCAEM)	;SCALAR EM
	JMPT	(DLIXL3)	;$3
	SMK	(ARREM)	;ARRAY EM
	LCFF	(S15QT)	;ID CONFLICT QT
	CSA	(LPAREN)	;L PAREN
	JMPF	(DLIXL4)	;$4
	JSB	(DARXLA)	;DATA ARRAY XLATE
	FET	(ESIBOX)	;ELEMENT SIZE BOX
	W0	(FET)		
	IOR	(IMULOP)	;IMULI LOP
	MON	(CODROL)	;CODE ROLL
	XW1.1	(MPY)		
	STO	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	STO	(OARNCL)	;OBJECT ARRAY REF NAME CLUE
	REG	(OARFIL)	;OBJECT ARRAY REF FILE
	FET	(CREPNT)	;CRRNT REG PNTR
DLIXL3:
	FET	(ONE)		;ONE
	JMP	(DLIX11)	;$11
DLIX14:				;STR212
	SCE	(EQUAL)		;EQUAL SIGN?
	POWT	(D1)		;PRUNE EXCESS POINTER IF INDEX IS REALLY THERE ;"23W"
	JMPT	(DLIXL6)	;YES IMPLIED DO CONSTRUCT
	JMP	(DLIXL2)
DLIXL4:
	XW0.2	(FET)		;ARRAY SIZE RUNG
DLIX11:
	POC	(SASLOP)	;SET ARRAY SIZE LOP
	MPY	(ESIBOX)	;ELEMENT SIZE BOX
	W1	(SWT)		;W1
	W1	(FET)		;W1
	W1	(SWT)		;W1
	JSB	(BXWLOP)	;BIN XWD LOP
DLIXL5:
	W1	(AMY)		;W1
	CSA	(COMMA)	;COMMA
	JMPT	(DLIX12)	;$12
	XIT	(EXIML)	;EXIT
>
IFNDEF	$DATA,
<

DLIXL6:
	SRA	(DSVFIL)	;DATA SCRIPT VAR FILE
	LCFF	(S18QT)		;INVALID INDEX ;STR795
	JSB	(NEXCHA)	;NEXT CHAR
	FET	(ZERO)	;ZERO
	XW1.1	(STO)		;ONE RUNG
	SNZ	(DDOCNT)	;STR795
	LCFF	(S17QT)		;BAD PAREN COUNT
	JSB	(DINSWE)	;DATA INDEX SWEEP
	DIM	(DDOCNT)	;DATA DO CNT
	SNZ	(DDOCNT)	;DATA DO CNT
	JSBF	(DSVCHE)	;DATA SCRIPT VAR CHECK
	JSB	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	W0	(FET)		;W0
	POC	(DINLOP)	;DO INIT LOP
	MON	(CODROL)	;CODE ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(PCOROL)	;PROLOG CODE ROLL
	CSF	(COMMA)	;COMMA
	JSB	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	FET	(ONE)		;ONE
	CSA	(COMMA)	;COMMA
	JSBT	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	W1T	(STO)		;W1
	W2	(SWT)		;W2
	JSB	(CDOSIZ)	;COMPUTE DO SIZE
	W3	(MMY)		;W3
	POC	(DOENLO)	;DO END LOP
	JMP	(BXWLOP)	;BIN XWD LOP
>
IFNDEF	$DATA,
<

DITXLA:					;DATA ITEMS XLATE
	ZER	(DITCNT)	;DATA ITEMS CNT
DITXL6:
	FET	(ONE)		;ONE
	JSB	(DCOSCA)	;DATA CONST SCAN
	JMPF	(DITXL4)	;$4
	CSA	(ASTERI)	;ASTERISK
	JMPF	(DITXL1)	;$1
	POW	(D2)		;TWO
	CLA	(DAT1)	;DATA 1
	JSB	(DCOSCA)	;DATA CONST SCAN
	JMPF	(DITXL4)	;$4
DITXL1:
	SME	(HTYEM)	;HOLLERITH TYPE EM
	JMPF	(DITXL4)	;$4
	EAW	(ITEROL)	;ITEM TEMP ROLL
	CAR	(CTEROL)	;CONST TEMP ROLL
	CNT	(ITEROL)	;ITEM TEMP ROLL
	W1	(STO)		;W1
	JMP	(DITXL5)	;$5
DITXL4:
	FET	(DAT1)	;DATA 1
	MON	(ITEROL)	;ITEM TEMP ROLL
	SEK	(TWO)		;TWO
	FETT	(DAT2)	;DATA 2
	MONT	(ITEROL)	;ITEM TEMP ROLL
DITXL5:
	W1	(FET)		;W1
	W1	(MPY)		;W1
	ADD	(DITCNT)	;DATA ITEMS CNT
	SLK	(DLICNT)	;DATA LIST CNT
	SEKF	(DLICNT)
	LCFF	(M9QT)		;DATA CNT QT	;"23M"
	STO	(DITCNT)	;DATA ITEMS CNT
	W1	(SWH)		;W1
	W1	(IOR)		;W1
	MON	(DITROL)	;DATA ITEMS ROLL
	POW	(D1)		;ONE
	EAW	(DITROL)	;DATA ITEMS ROLL
	CAR	(ITEROL)	;ITEM TEMP ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(DITXL6)	;$6
	ZER	(MCOFLA)	;"23X"
	XIT	(EXIML)	;EXIT
>
IFNDEF	$DATA,
<

DARXLA:					;DATA ARRAY XLATE
	XW0.3	(FET)		;STAT PNTR RUNG
	CFP	(ATEROL)	;ARRAY TEMP ROLL
	CNT	(ATEROL)	;ARRAY TEMP ROLL
DARXL1:
	JSB	(DSCSCA)	;DATA SCRIPT SCAN
	SUB	(ONE)		;ONE
	CSA	(COMMA)	;COMMA
	JMPT	(DARXL1)	;$1
	FLP	(DSTROL)	;DATA SCRIPT TERM ROLL
	CSF	(RPAREN)	;R PAREN
	SEQ	(ZERO)	;IS COUNT ZERO
	LCFF	(M2QT)		;WRONG # OF SUBSCRIPTS	;STR795
DARXL2:
	JSB	(DSCMAK)	;DATA SCRIPT MAKER
	SRD	(ATEROL)	;ARRAY TEMP ROLL
	XMLF	(P1EML)	;PRUNE ONE EXIT
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	IOR	(MPYLOP)	;MPY LOP
	MON	(CODROL)	;CODE ROLL
DARXL3:
	JSB	(DSCMAK)	;DATA SCRIPT MAKER
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	IOR	(MPYLOP)	;MPY LOP
	MON	(CODROL)	;CODE ROLL
	POC	(AACLOP)	;ADD AC LOP
	SRD	(ATEROL)	;ARRAY TEMP ROLL
	JMPT	(DARXL3)	;$3
	XIT	(EXIML)	;EXIT
DINSWE:					;DATA INDEX SWEEP
	FLP	(CODROL)	;CODE ROLL
DINSW1:
	MOA	(CODROL)	;CODE ROLL
	RELF	(CODROL)	;CODE ROLL
	XMLF	(P1EML)	;PRUNE ONE EXIT
	SMK	(DSVEM)	;DATA SCRIPT VAR EM
	JMPF	(DINSW3)	;$3
	W0	(FET)		;W0
	AND	(RHAMAS)	;RIGHT HALF MASK
	W2	(FET)		;W2
	AND	(RHAMAS)	;RIGHT HALF MASK
	W1	(SEQ)		;W1
	POW	(D1)		;ONE
	IERT	(ZRHEM)	;ZERO RIGHT HALF EM
	IORT	(DDOCNT)	;DATA DO CNT
DINSW3:
	MON	(PCOROL)	;PROLOG CODE ROLL
	JMP	(DINSW1)	;$1
>
IFNDEF	$DATA,
<

DSCSCA:					;DATA SCRIPT SCAN
	FET	(ZERO)	;ZERO
	SCK	(LETKEY)	;LETTER KEY
	JMPT	(DSCSC2)	;$2
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(DSCSC6)	;$6
	JSB	(INTSCA)	;INTEGER SCAN
	CSA	(ASTERI)	;ASTERISK
	JMPF	(DSCSC4)	;$4
	CLA	(DAT2)	;DATA 2
DSCSC2:
	JSB	(SYMSCA)	;SYMBOL SCAN
	SRA	(DSVFIL)	;DATA SCRIPT VAR FILE
	JMPT	(DSCSC3)	;STR795
	FET	(LACCCN)	;LAST ACTIVE CCNS
	STO	(DAT1)	;DATA 1
	PNG	(DSVROL)	;DATA SCRIPT VAR ROLL
	AGF	(DSVACF)	;DATA SCRIPT VAR AND CCNS FILE
DSCSC3:	SCK	(POMKEY)	;PLUS OR MINUS KEY
	ZER	(DAT2)	;DATA 2
	JMPF	(DSCSC5)	;$5
	JSB	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	JMP	(DSCSC7)	;$7
DSCSC6:
	JSB	(SINSCA)	;SIGNED INTEGER SCAN
DSCSC4:
	FET	(ZERO)	;ZERO
DSCSC5:
	FET	(DAT2)	;DATA 2
DSCSC7:
	MON	(DSTROL)	;DATA SCRIPT TERM ROLL
	MON	(DSTROL)	;DATA SCRIPT TERM ROLL
	MON	(DSTROL)	;DATA SCRIPT TERM ROLL
	XIT	(EXIML)	;EXIT
DSVCHE:					;DATA SCRIPT VAR CHECK
	FLP	(DSVROL)	;DATA SCRIPT VAR ROLL
DSVCH1:
	LGA	(DSVROL)	;DATA SCRIPT VAR ROLL
	XITF	(EXIML)	;EXIT
	SNZ	(DAT1)	;DATA 1
	JMPF	(DSVCH1)	;$1
	FET	(DAT1)	;DATA 1
	STO	(LACCCN)	;LAST ACTIVE CCNS
	LCF	(S17QT)		;NCOMPLETE IMPLIED DO	;STR795
>
IFNDEF	$DATA,
<

DSCMAK:					;DATA SCRIPT MAKER
	MOA	(DSTROL)	;DATA SCRIPT TERM ROLL
	MOA	(DSTROL)	;DATA SCRIPT TERM ROLL
	MOA	(DSTROL)	;DATA SCRIPT TERM ROLL
	W0	(SNZ)		;W0
	JMPT	(DSCMA1)	;$1
	POW	(D1)		;ONE
	W0	(SNZ)		;W0
	POCT	(MACLOP)	;MOVE AC LOP
	IORT	(MOVLOP)	;MOVE LOP
	MONT	(CODROL)	;CODE ROLL
	JMPT	(DSCMA2)	;$2
	POW	(D1)		;ONE
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	POC	(MACLOP)	;MOVE AC LOP
	IOR	(MOVLOP)	;MOVE LOP
	MON	(CODROL)	;CODE ROLL
	JMP	(DSCMA4)	;$4
DSCMA1:
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	POC	(MACLOP)	;MOVE AC LOP
	IOR	(MOVLOP)	;MOVE LOP
	MON	(CODROL)	;CODE ROLL
	IOR	(MPYLOP)	;MPY LOP
	MON	(CODROL)	;CODE ROLL
DSCMA2:
	W0	(SNZ)		;W0
	POWF	(D1)		;ONE
	JMPF	(DSCMA4)	;$4
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	IOR	(ADDLOP)	;ADD LOP
	MON	(CODROL)	;CODE ROLL
DSCMA4:
	MOA	(ATEROL)	;ARRAY TEMP ROLL
	XIT	(EXIML)	;EXIT
RDLCON:					;REGISTER DATA LIST CONST
	STO	(DAT1)	;FX CONST BOX
	REG	(DLCFIL)	;DATA LIST CONST FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	XIT	(EXIML)	;EXIT
CELSIZ:					;CALC ELEMENT SIZE
	SMK	(DITEM)	;DOUBLE ITEM EM
	FET	(ONE)		;ONE
	CLAT	(TWO)		;TWO
	STO	(ESIBOX)	;ELEMENT SIZE BOX
	XIT	(EXIML)	;EXIT
>
IFNDEF	$DATA,
<

CDOSIZ:					;COMPUTE DO SIZE
	W1	(FET)		;W1
	W1	(SUB)		;W1
	W3	(ADD)		;W3
	W1	(STO)		;W1
	W2	(DIV)		;W2
	XIT	(EXIML)	;EXIT
BXWLOP:					;BIN XWD LOP
	W1	(FET)		;W1
	AND	(LHZMAS)	;LEFT HALF ZERO MASK
	W2	(STO)		;W2
	AND	(LHZMAS)	;LEFT HALF ZERO MASK
	W1	(SWH)		;W1
	W1	(IOM)		;W1
	JMP	(MOCOEX)	;MOVE ON CODE EXIT
>
IFNDEF	$DATA,
<

DCOSCA:					;DATA CONST SCAN
	FET	(ONE)		;ONE
	CSA	(DBLQT)	;DBL QT
	JMPT	(DCOSC6)	;$6
	SCK	(LETKEY)	;LETTER KEY
	JMPF	(DCOSC2)	;$2
	CSA	(O)		;O
	JMPT	(DCOSC6)	;$6
	CSA	(T)		;T
	CSFF	(F)		;F
	FTM	(DAT1)
	JMP	(EXIFAL)	;EXIT FALSE

DCOSC2:
	CSA	(MINUS)	;MINUS
	FTM	(MCOFLA)
	CSAF	(PLUS)	;PLUS
	JSB	(CONANA)	;CONST ANALYSIS
	SNZ	(MCOFLA)	;MINUS CONST FLAG
	JMPF	(DCOSC3)	;NEGATE NOT NEEDED
	SMKT	(CTYEM)	;COMPLEX CONST. ?
	XMLT	(PMNCML)	;YES,NEGATE BOTH WORDS
	JMPT	(DCOSC3)
	SNZ	(PDPSW)	;PDP-10 ?
	XMLT	(PMNML)	;YES,DFN
	XMLF	(PMN6ML)	;NO,DOUBLE PREC. NEGATE
DCOSC3:
	SMK	(DITEM)	;DOUBLE ITEM EM
	POWT	(D1)		;ONE
	CLAT	(TWO)		;TWO
	JMPT	(EXIFAL)	;EXIT FALSE
	SMK	(ITYEM)	;INTEGER TYPE EM
	SMKF	(HTYEM)	;HOLLERITH TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	XML	(P1EFML)	;PRUNE ONE EXIT FALSE
DCOSC6:
	CSA	(MINUS)	;MINUS
	FTM	(MCOFLA)	;MINUS CONST FLAG
	CSAF	(PLUS)	;PLUS
	XIT	(COCCON)	;CONV OCTAL CONST
>
GTOGRO:					;GO TO GROUP
	QSF	(OTOQT)	;OTO QT
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(COAGTO)	;COMPUTED OR ASSIGN GO TO
GTSEXI:					;GO TO STA EXIT
	JSB	(LBLSCA)	;LBL SCAN
	BAI	(.JRST0)	;JRST INST
GEXFIN:					;GOTO EXIT FIN
	NOZ	(JOUFLA)	;JUMP OUT FLAG
	JMP	(JEOEXI)	;JUMP EOL EXIT
COAGTO:					;COMPUTED OR ASSIGN GO TO
	CSA	(LPAREN)	;L PAREN
	JMPF	(AGTSXL)	;ASSIGN GO TO STA XLATE
CGTSXL:					;COMPUTED GO TO STA XLATE
	JSB	(LLIXLA)	;LBL LIST XLATE
	CSA	(COMMA)	;COMMA
	JSB	(FESACO)	;FX EXP SCAN AND COLLAPSE
	JSB	(GENRUN)	;GEN RUN
	FET	(RONPNT)	;REG ONE PNTR
	W1	(SWT)		;W1
	BIN	(.SKLE0)	;SKIPLE INST
	CNT	(ITEROL)	;ITEM TEMP ROLL
	JSB	(RWOCON)	;REGISTER WORK CONST
	BIN	(.CMLE0)	;CAMLE INST
	POC	(ABSINS)	;ABS INST
	POC	(.SKA0)	;SKIPA INST
	JSB	(LBLMAK)	;LBL MAKER
	JSB	(MLGAKE)	;MADE LBL GEN AND KEEP
	BAI	(.JRST2)	;JRST 0,@(1) INST
	ZER	(ITEPNT)	;ITEM TEMP PNTR
CGTSX1:
	DFA	(ITEROL)	;ITEM TEMP ROLL
	BAIT	(.ARG0)	;ARG INST
	JMPT	(CGTSX1)	;$1
	REL	(ITEROL)	;ITEM TEMP ROLL
	POW	(D1)		;ONE
	JMP	(GEXFIN)	;GOTO EXIT FIN
AGTSXL:					;ASSIGN GO TO STA XLATE
	JSB	(VARSCA)	;W0<-VARIABLE POINTER
	SCE	(CRR)		;GO TO I ? ;"23FF"
	JMPF	(AGTSX1)	;NO, PROCESS LIST ;"23FF"
	BAI	(.SKE1)		;SKIPE 1 INST
	POC	(ABSINS)	;ABS INST
	POC	(.JRST1)	;JRST 0.XR1 INST
				;4 LINES DELETED ;"23FF"
	JMP	(GEXFIN)	;GOTO EXIT FIN ;"23FF"
AGTSX1:
				;LINE DELETED ;"23FF"
	CSA	(COMMA)	;COMMA
				;LINE DELETED ;"23FF"
	CSF	(LPAREN)	;GO TO I,"(" ;"23FF"
	BAI	(.RRZ0)		;HRRZ 1,I ;PRUNE W0 ;"23FF"
AGTSX2:				;"23FF"
	JSB	(LBLSCA)	;GO TO I,( LABEL ;W0<-LABEL ;"23FF"
	BAK	(.CIN1)		;CAIN 1,LABEL ;"23FF"
	BAI	(.JRST0)	;JRST LABEL ;"23FF"
	CSA	(COMMA)		;GO TO I,( +LABEL ;"23FF"
	JMPT	(AGTSX2)	;GET SOME MORE LABELS ;"23FF"
	CSF	(RPAREN)	;R PAREN
	JMP	(GEXFIN)	;GOTO EXIT FIN
LLIXLA:					;LBL LIST XLATE
	RSV	(ITEROL)	;ITEM TEMP ROLL
LLIXL1:
	JSB	(LBLSCA)	;LBL SCAN
	MON	(ITEROL)	;ITEM TEMP ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(LLIXL1)	;$1
	CSF	(RPAREN)	;R PAREN
	XIT	(EXIML)	;EXIT
AOAXLA:					;ASSIGNMENT OR AFDS XLATE
	FEX	(FOSTXL)	;FORMAT STA XLATE
	JSB	(IDSCAN)	;ID SCAN
	JMPT	(ASTXLA)	;ASSIGNMENT STA XLATE
	SNZ	(ASTFLA)	;ACTIVE STA FLAG
	SCEF	(EQUAL)	;EQUAL
	JSBT	(REGSCA)	;REGISTER SCALAR
	JMPT	(ASXFIN)	;ASSIGNMENT STA XLATE FIN
	CSA	(LPAREN)
	XITF	(FAIML)		;FAIL	;"23A"
	JSB	(LBLMAK)	;MAKE LABEL AT END OF AFDS
	BAK	(.JRST0)	;JUMP AROUND THE AFDS, SAVE THE ADDRESS
	STO	(SINFLA)	;IN A HANDY UNUSED LOCATION - "20G"
	JSB	(LBLMAK)	;LBL MAKER
	JSB	(MLGAKE)	;MADE LBL GEN AND KEEP
	BAK	(.ARG0)	;ARG INST
	EAW	(D10)		;SAVE ALL REGS ;"21V"
	STO	(REGCNT)	;"21V"
	NOZ	(SAV16)		;INCLUDING REG 16 ;"21V"
	JSB	(BSRGEN)	;BLOCK SAVE REGS GEN
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	BAI	(.MEI0)
	STO	(DAT1)	;DATA 1
	PNG	(LSPROL)	;LOCAL SPROG ROLL
	AGF	(LSPFIL)	;APPEND SYMBOL & DAT1 TO LOCAL SPROG FILE
	JSB	(SETPOS)	;SET POSITION
	STK	(LSPDEF)	;INDICATE AFDS BEING DEFINED ;"23-AM"
	RSV	(APNROL)	;ARG PNTR ROLL
AOAXL1:
	JSB	(IDSCAN)	;ID SCAN
	PNGF	(LDMROL)	;LOCAL DMY ROLL
	JSBF	(TYPSET)	;TYPE SET
	SMKT	(LDMEM)
	XITT	(FAIML)		;FAIL	;"23A"
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSB	(PTEMAK)	;PERM TEMP MAKER
	TLYT	(TEMCNT)	;TEMP CNT
	STO	(DAT1)	;DATA 1
	AGF	(LDMFIL)	;LOCAL DMY FILE
	MON	(APNROL)	;ARG PNTR ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(AOAXL1)	;$1
	CSA	(RPAREN)	;R PAREN
	CSAT	(EQUAL)
	XITF	(FAIML)		;FAIL	;"23A"
	JSB	(ESACOL)	;EXP SCAN AND COLLAPSE
	JSB	(LSHGEN)	;LOCAL SPROG HEAD GEN
	JSB	(DPCHEC)	;DP CHECK
	JSB	(GENRUN)	;GEN RUN
	W1	(SWT)		;W1
	JSB	(ACCAGE)	;ASSIGNMENT CONV CHECK AND GEN
	STO	(EOPPNT)	;SAVE DEST OP PNTR
	JMPT	(AOAXL2)	;IS DEST DBL AND RESLT SNGL
	W0	(FET)		;COPY W0
	AND	(SANMAS)	;SIGN CHANGE OR COMPLEMENT ?
	SEQ	(ZERO)		;YES, IF NON ZERO
	SMKT	(RZEEM)		;NO,IS DEST REG 0
	JMPT	(AOAXL5)	;YES,SKIP ALL RE LOADS
AOAXL3:
	IER	(ETYEM)		;INSERT EXP TYPE EM IN RESULT
	FET	(RZEPNT)	;GET REG 0 PNTR
	IER	(ETYEM)	;SET TYPE FOR REG LOADS"21V"
	JSB	(RLOGEN)	;GO LOAD REGS
	SMK	(RZEEM)	;REG 0 PNTR STILL HERE? "21V"
	JSBT	(DPCHE1)	;YES CHECK FOR NEGATE "21V"
AOAXL4: POCT	(ABSINS)	;GENERATE INST TO CLEAR REG 1
	POCT	(.MEI1)		;MOVEI 1,0
AOAXL5: POW	(D1)		;PRUNE W0
	JSB	(BREACS)	;BIN RESTORE ACS
	JSB	(SEXGEN)	;SPROG EXIT GEN
	ZER	(LSPDEF)	;"23-AM"
	ZER	(FSTFLA)	;AN EXECUTABLE STATEMENT
	FET	(SINFLA)	;LABEL FOR JRST "20G"
	ZER	(REGCNT)	;RESTORED REGS DON'T COUNT ;"21V"
	ZER	(SAV16)		;DITTO ;"21V"
	JSB	(MLBGEN)	;MAKE:  LABEL	BLOCK 0
	FET	(LTEPNT)	;LOCAL TEMP PNTR
	STO	(AFDTPN)	;ARITH FUNC DEF TEMP PNTR
	JMP	(AEOEXI)	;AFDS EOL EXIT
AOAXL2:	
	SMK	(RZEEM)		;IS DEST REG 0
	JMPT	(AOAXL4)	;YES CLEAR REG 1
	SNZ	(ONE)		;NO SET FLAG T
	JMP	(AOAXL3)	;RESTORE REG 0 AND CLEAR REG1
DPCHEC:					;DP CHECK
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XNIT	(RONPNT)	;REG ONE PNTR
	NOZT	(ZERRUN)	;ZERO RUNG
	XIT	(EXIML)	;EXIT
DPCHE1:			;CHECK FOR DP NEG "21V"
	SMK	(DPNEM)	;DP? "21V"
	XITF	(EFAML)	;EXIT FALSE "21V"
	W0	(FET)		;COPY W0 "21V"
	JSB	(CSIGE1)	;NEGATE "21V"
	XIT	(EFAML)	;RETURN FALSE "21V"
ASTXLA:					;ASSIGNMENT STA XLATE
	SMK	(ARREM)	;ARRAY ID EM
	CSAT	(LPAREN)	;L PAREN
	JSBT	(AREXLA)	;ARRAY REF XLATE
	SMKF	(SCAEM)	;SCALAR EM
ASXFIN:					;ASSIGNMENT STA XLATE FIN
	CSAT	(EQUAL)
	XITF	(FAIML)		;FAIL	;"23A"
	ISE	(GDMFIL)	;GLOBAL DEFINITION ?
	REGT	(DEFFIL)	;YES, REGISTER AS DEFINED
	FET	(IIVPNT)	;INSIDE INDUCTION VAR PNTR
	STO	(DSTPNT)	;SAVE INSIDE INDUCTION VAR
	JSB	(ESACOL)	;EXP SCAN AND COLLAPSE
	JSB	(SACAGE)	;SPECIAL ASSIGNMENT CHECK AND GEN
	JMPT	(ACEOEX)	;ACTIVE EOL EXIT
	JSB	(DPCHEC)	;DP CHECK
	SMK	(SUBEM)	;SUBEXPRESSION ?
	JSBT	(EIRGEN)	;YES, EXP IN REG GEN
	W1	(SWT)		;W1
	SMK	(AREEM)	;ARRAY REF EM
	JMPF	(ASXFI1)	;NO ARRAY "20K"
	XW0.2	(FET)		;GET SUBSCR RUNG "20K"
	SMK	(SUBEM)		;SUBEXPRESSION? "20K"
	XW0.4T	(TLY)		;YES TALLY "20K"
	POW	(D1)		; "20K"
	JSB	(RDRCHE)	;RESTORE DO REG CHECK
	JSB	(SCRGEN)
	JMPF	(ASXFI1)	;"23R"
	XW1.2	(FET)		;GET SCRIPT EXP PNTR "23R"
	W1	(SWT)		;PUT REG PNTR ON TOP "23R"
	XW1.3	(STO)		;PUT IT IN EXP STATUS RUNG "23R"
	XW1.2	(STO)		;SCRIPT EXP RUNG
ASXFI1:			;"20K"
	SON	(TEMEM)	;TEMP EM
	FETT	(TYPMAS)	;TYPE MASK
	ANDT	(EOPPNT)	;EXP OP PNTR
	W2T	(IOM)		;W2
	JSB	(AMAFIN)	;ASSIGNMENT MAKER FIN
	SNZ	(DSTPNT)	;RESTORE DO INDEX ?
	JSBT	(RDOREG)	;YES,RESTORE IT
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
AMAFIN:					;ASSIGNMENT MAKER FIN
	JSB	(ACCAGE)	;ASSIGNMENT CONV CHECK AND GEN
	W1	(SWT)		;PUT RESULT ON TOP
	JSB	(REGGEN)	;INSURE RESULT IN REG & SAVE T/F FLAG STATE
	W1	(SWT)		;RETURN DESTINATION TO TOP
	JSB	(MPOGEN)	;MOVEM POSITIVE GEN
	EAWT	(.SEZM0)	;SETZM INST
	JSBT	(BSHREF)	;BUILD SECOND HALF REF
	XML	(P1EML)	;PRUNE ONE EXIT
REGGEN:
	SMK	(ITYEM)
	JSBT	(AIVCHE)
	JSBF	(GIRGEN)	;MAKE SURE ITS IN A REG
	XIT	(EXIML)
RDRCHE:					;RESTORE DO REG CHECK
	XW0.2	(FET)		;SCRIPT RUNG
	SME	(DREEM)	;DO REG EM
	XITF	(EXIML)	;EXIT
RDOREG:
	SNZ	(IIVPNT)	;INSIDE INDUCTION VAR PNTR
	FETF	(DSTPNT)	;SAVE INSIDE INDUCTION VAR
	STKF	(IIVPNT)	;RESTORE DO INDEX
	NOZF	(JOUFLA)	;DEFINE DO INDEX VARIABLE
	BAIF	(.ME1)	;MOVE DO REG INST
	XIT	(EXIML)	;EXIT
SACAGE:					;SPECIAL ASSIGNMENT CHECK AND GEN
	W1	(FET)		;W1
	STO	(PINATO)	;PNTR INSERT ATOM
	SMK	(SUBEM)	;SUBEXP EM
	JMPT	(SPACHE)	;SUBEXP PARTS CHECK
	SMK	(PINEM)	;PNTR INSERT EM
	JMPT	(SVACAG)	;SPECIAL VAR ASSIGNMENT CHECK AND GEN
	SMK	(COPEM)	;CONST ONE PNTR EM
	SMKT	(MINEM)	;MINUS EM
	SONT	(ITYEM)	;INTEGER TYPE EM
	SMKF	(CZPEM)	;CONST ZERO PNTR EM
	SMKF	(TCPEM)	;TRUE CONST PNTR EM
	SMKF	(FZPEM)	;FL ZERO PNTR EM
	JMPF	(CASCHE)	;CONST ASSIGNMENT CHECK
	SMK	(NOTEM)	;NOT EM
	EORT	(LCIMAS)	;LOGICAL CONST INVERT MASK
	SME	(DONEM)	;DISPL ONE EM
	BAKT	(.SEZM0)	;SETZM INST
	BAKF	(.SEOM0)	;SETOM INST
	SMK	(DITEM)	;DOUBLE ITEM EM
	EAWT	(.SEZM0)	;SETZM INST
	JSBT	(BSHREF)	;BUILD SECOND HALF REF
	XML	(P1ETML)	;PRUNE ONE EXIT TRUE
SVACAG:					;SPECIAL VAR ASSIGNMENT CHECK AND GEN
	SMK	(DPNEM)	;DOUBLE PREC NEG EM
	SMKF	(CTYEM)	;COMPLEX TYPE EM
	JMPT	(EXIFAL)	;EXIT FALSE
	SMK	(MINEM)	;MINUS EM
	JMPF	(SVACA1)	;$1
	SME	(NOTEM)	;NOT EM
	BAIT	(.AOS0)	;AOS INST
	BAIF	(.MNS0)	;MOVNS INST
	XML	(ETRML)	;EXIT TRUE
SVACA1:
	SME	(NOTEM)	;NOT EM
	BAKT	(.SEMM0)	;SETCMM INST
	XML	(P1ETML)	;PRUNE ONE EXIT TRUE
SPACHE:					;SUBEXP PARTS CHECK
	XW0.0	(FET)		;OP PNTR RUNG
	SPT	(AOPTRA)	;ARITH OP TRAIT
	JMPF	(EXIFAL)	;EXIT FALSE
IFDEF HARDFL,<						; *EJG* 06/23/76
	SON	(DPTEM)	;DOUBLE PREC TYPE EM		; *EJG* 06/23/76
	JMPT	(EXIFAL)	;EXIT FALSE		; *EJG* 06/23/76
>							; *EJG* 06/23/76
	SON	(ITYEM)	;INTEGER TYPE EM
	JMPF	(SPACH5)	;$5
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(EXIFAL)	;EXIT FALSE
SPACH5:
	XW0.2	(FET)		;B PART RUNG
	XW1.1	(FET)		;A PART RUNG
	SON	(PINEM)	;PNTR INSERT EM
	SMKF	(PINEM)	;PNTR INSERT EM
	XMLF	(P2EFML)	;PRUNE TWO EXIT FALSE
	XW2.0	(FET)		;OP PNTR RUNG
	SPK	(ADDTRA)	;ADDITIVR OP TRAIT
	JMPT	(SPACH1)	;$1
	SME	(MOPEM)	;MPY OP EM
	SONF	(PINEM)	;PNTR INSERT EM
	XMLF	(P2EFML)	;PRUNE TWO EXIT FALSE
	JSB	(OASCHE)	;ORDER AND SIGN CHECK
	JSB	(EIRGEN)	;EXP IN REG GEN
	W0	(FET)		;PUT SUB EXP PNTR INTO W3 ;"22D"
	JSB	(RFBGF4)	;ADJUST TYPES ;"22D"
	W1	(STO)		;REMOVE EXTRA REG PNTR ;"22D"
	W1	(SWT)		;W1
	JSB	(CCAGE3)	;"23AJ"
	XW2.0	(FET)		;OP PNTR RUNG
	SME	(MOPEM)	;MPY OP EM
	JSB	(SATREG)	;SAVE THIRD REG
	BTYT	(.IMUM0)	;MPYM INST
	BTYF	(.IDIM0)	;DIVM INST
	SME	(MINEM)	;MINUS EM
	JMP	(SPACH3)	;$3
SPACH1:
	POW	(D1)		;ONE
	JSB	(OASCHE)	;ORDER AND SIGN CHECK
	EORF	(MINMAS)	;MINUS MASK
	SMK	(COPEM)	;CONST ONE PNTR EM
	SONT	(ITYEM)	;INTEGER TYPE EM
	JMPF	(SPACH2)	;$2
	SME	(MINEM)	;MINUS EM
	BAIT	(.SOS0)	;SOS INST
	BAIF	(.AOS0)	;AOS INST
	JMP	(SPACH4)	;$4
SPACH2:
	JSB	(EIRGEN)	;EXP IN REG GEN
	W0	(FET)		;PUT SUB EXP PNTR INTO W3 ;"22D"
	JSB	(RFBGF4)	;ADJUST TYPES ;"22D"
	W1	(STO)		;REMOVE EXTRA REG PNTR ;"22D"
	W1	(SWT)		;W1
	JSB	(CCAGE3)	;"23AJ"
	SON	(MINEM)	;MINUS EM
	JSB	(SATREG)	;SAVE THIRD REG
	BTYF	(.ADDM0)	;ADDM INST
	BTYT	(.SUBM0)	;SUBM INST
	POW	(D1)		;ONE
SPACH3:
	EORT	(MINMAS)	;MINUS MASK
SPACH4:
	SME	(MINEM)	;MINUS EM
	XITF	(P1ETML)

	SMK	(DPTEM)

	SNZT	(PDPSW)	;TEST MACHINE TYPE

	JMPT	(SPACH6)

	BAK	(.MNS0)	;MOVNS INST
	SMK	(DITEM)	;DOUBLE ITEM EM
	EAWT	(.MNS0)	;MOVNS INST
	JSBT	(BSHREF)	;BUILD SECOND HALF REF

	SMKT	(DPTEM)	;DOUBLE PREC TYPE EM
	FETT	(RONPNT)	;REGISTER ONE POINTER
	FETT	(ABSCPN)	;ALL BUT SIGN CONST POINTER
	BINT	(.TDNE0)	;TDNE INSTRUCTION
	POWT	(D1)		;ONE
	BAKT	(.SOS0)	;SOS INST

	XIT	(P1ETML)	;PRUNE ONE EXIT TRUE

SPACH6:
	BAK	(.ME0)	;MOVE INST
	EAW	(.DFN0)	;DFN INST
	JSB	(BSHREF)
	MOA	(CODROL)
	SUB	(ACMASK)
	MON	(CODROL)
	BAK	(.MEM0)	;MOVEM
	XIT	(P1ETML)
OASCHE:					;ORDER AND SIGN CHECK
	SMK	(PINEM)	;PNTR INSERT EM
	W1T	(SWT)		;W1
	SON	(MINEM)	;MINUS EM
	XMLF	(ETRML)	;EXIT TRUE
	FET	(MINMAS)	;MINUS MASK
	W3	(EOM)		;W3
	XIT	(EFAML)		;EXIT FALSE
CASCHE:					;CONST ASSIGNMENT CHECK
	SMK	(CONEM)	;CONST PNTR EM
	XITF	(EFAML)		;EXIT FALSE
	SMK	(NOTEM)	;NOT EM
	XITT	(EFAML)		;EXIT FALSE
	SMK	(ITYEM)	;INTEGER TYPE EM
	SMKF	(RTYEM)	;REAL TYPE EM
	XITF	(EFAML)		;EXIT FALSE
	SMK	(ITYEM)		;RESULT INTEGER?
	JMPF	(CASCH1)	;NO CHECK DESTINATION
	SON	(RTYEM)		;DESTINATION REAL?
	SONF	(DITEM)		;OR DOUBLE
	XITF	(EFAML)		;NO EXIT FALSE
	JSB	(FACCFI)	;CONVERT INTEGER TO FLOATING
	STO	(DAT1)		;SAVE UPPER
	ZER	(DAT2)		;CLEAR LOWER
	W0	(FET)		;FINISH CONVERSION
	JSB	(CCOFIN)	;CONVT FINISH
	STK	(EOPPNT)	;SAVE EXP TYPE
	XIT	(EFAML)		;EXIT FALSE
CASCH1:
	SON	(DITEM)		;DESTINATION DOUBLE?
	SMKT	(RTYEM)		;AND RESULT REAL?
	IERT	(DPTEM)		;CHANGE RESULT TYPE TO DP
	XIT	(EFAML)		;EXIT FALSE
FOSTXL:					;FORMAT STA XLATE
	FEX	(CSTXLA)	;CALL STA XLATE
	QSF	(FORQT)	;FORMAT QT
	SCE	(LPAREN)	;L PAREN
	SCEF	(CRR)		;CAR RETURN
	JSBF	(NEXCHA)	;NEXT CHAR
	JSB	(LAPSAV)	;LOOK AHEAD POSITION SAVE
	CSF	(LPAREN)	;L PAREN
	JSB	(FLISCA)	;FORMAT LIST SCAN
	SCE	(CRR)
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	FET	(LACCCN)	;LAST ACTIVE CCNS
	JSB	(LAPRES)	;LOOK AHEAD POSITION RESET
	RSV	(CTEROL)	;CONST TEMP ROLL
	NOZ	(FORFLA)	;FORMAT STA FLAG
	JSB	(PHCSET)
FOSTX1:
	JSB	(PHCHAR)
	JSB	(NINCHA)
	SCE	(CRR)
	SLKF	(CARNUM)	;CARD-COL NUMBERS
	JMPF	(FOSTX1)	;$1
	POW	(D1)		;ONE
	JSB	(PHCEND)
	SCE	(CRR)
	JSBF	(NEXCHA)
	SCE	(CRR)
	JSB	(LBLMAK)	;LBL MAKER
	BAK	(.JRST0)	;JRST INST
	ZER	(FSTFLA)	;FIRST STA FLAG
	CNT	(CTEROL)	;CONST TEMP ROLL
	IER	(ABSEM)	;ABS EM
	MON	(CODROL)	;CODE ROLL
	REL	(ERRROL)	;ERROR ROLL
	JSB	(PRISTA)	;PRINT STATEMENT
	JSB	(OUTCOD)
	CCFF	(S22QT)		;SYNTAX QT	;"23N"
	EAW	(CODROL)	;CODE ROLL
	CAR	(CTEROL)	;CONST TEMP ROLL
	SNZ	(MACSW)	;PRINTING SUPRESSED ?
	JSBF	(PRIFOR)	;NO, PRINT FORMAT
	JSB	(PUNDAT)	;PUNCH DATA
	JSB	(MLBGEN)	;MADE LBL GEN
	JSB	(DCLGEN)	;DO CLOSE GEN
	JSB	(OUTCOD)	;OUTPUT CODE
	ZER	(ENDCOD)	;"23P"
	XML	(ETRML)	;EXIT TRUE
FLISCA:					;FORMAT LIST SCAN
FLISC1:
	CSA	(RPAREN)	;R PAREN
	XITT	(EXIML)	;EXIT
FLISC2:
	CSA	(SLASH)	;SLASH
	JMPT	(FLISC3)	;$3
	JSB	(FBASCA)	;FORMAT BASIC SCAN
	CSA	(SLASH)	;SLASH
	JMPF	(FLISC4)	;$4
FLISC3:
	CSA	(SLASH)	;SLASH
	JMPT	(FLISC3)	;$3
	CSA	(COMMA)	;COMMA
	JMPT	(FLISC2)	;$2
	JMP	(FLISC1)	;$1
FLISC4:
	CSA	(COMMA)	;COMMA
	JMPT	(FLISC2)	;$2
	CSF	(RPAREN)	;R PAREN
	XIT	(EXIML)	;EXIT
PRIFOR:					;PRINT FORMAT
	ZER	(CODPNT)	;CODE PNTR
PRIFO1:
	DFA	(CODROL)	;CODE ROLL
	XITF	(EXIML)	;EXIT
	PRQ	(ASCQT)	;ASCII QT
	XML	(ASCBCD)
	PRC	(CRR)		;CAR RETURN
	JMP	(PRIFO1)	;$1
FBASCA:					;FORMAT BASIC SCAN
	CSA	(SNGLQT)	;QT
	JMPT	(FBASC8)	;$8
	CSA	(MINUS)	;MINUS
	CSAF	(PLUS)	;PLUS
	JMPF	(FBASC2)	;$2
	JSB	(INTSCA)	;INTEGER SCAN
	CSF	(P)		;P
	JMP	(FBASC4)	;$4
FBASC2:
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(FBASC5)	;$5
	JSB	(INTSCA)	;INTEGER SCAN
	CSA	(P)		;P
	JMPF	(FBASC3)	;$3
FBASC4:
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(FBASC5)	;$5
	JSB	(INTSCA)	;INTEGER SCAN
FBASC3:
	CSA	(X)		;X
	JMPT	(FBAS11)	;$11
	SCE	(H)		;H
	JMPT	(FBASC9)	;$9
FBASC5:
	CSA	(DOLLAR)	;DOLLAR SIGN CHAR I
	JMPT	(FBAS11)	;$11
	CSA	(T)		;T
	JMPF	(FBAS16)	;$16
	LSS	(TFMT.)	;TFMT. 
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(INTSCA)	;INTEGER SCAN
FBAS16:
	CSA	(E)		;E
	CSAF	(F)		;F
	EAWT	(FLIRT.)	;FLIRT.
	EAWT	(FLOUT.)	;FLOUT.
	JMPT	(FBAS14)	;$14
	CSA	(D)		;D
	EAWT	(DIRT.)	;DIRT.
	EAWT	(DOUBT.)	;DOUBT.
FBAS14:
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS
	JMPT	(FBASC6)	;$6
	CSA	(G)		;G
	JSBT	(REGALL)	;REGISTER ALLIO.
	JMPT	(FBAS13)	;$13
	CSA	(O)		;O
	EAWT	(OCTI.)	;OCTI.
	EAWT	(OCTO.)	;OCTO.
	JMPT	(FBAS15)	;$15
	CSA	(I)		;I
	EAWT	(INTI.)	;INTI.
	EAWT	(INTO.)	;INTO.
	JMPT	(FBAS15)	;$15
	CSA	(A)		;A
	EAWT	(ALPHI.)	;ALPHI.
	EAWT	(ALPHO.)	;ALPHO.
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS
	JMPT	(INTSCA)	;INTEGER SCAN
	CSA	(L)		;L
	EAWT	(LINT.)	;LINT.
	EAWT	(LOUT.)	;LOUT.
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS	;"23I"
	JMPT	(INTSCA)	;INTEGER SCAN	;"23I"
FBAS15:
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS
	JMPT	(FBAS12)	;$12
	CSA	(LPAREN)	;L PAREN
	CCFF	(S3QT)	;SYNTAX QT
	JMP	(FLISCA)	;FORMAT LIST SCAN
FBASC6:
	SCK	(DIGKEY)	;DIGIT KEY
	XITF	(EXIML)	;EXIT
	JSB	(INTSCA)	;INTEGER SCAN
	CSF	(PERIOD)	;PERIOD
	JMP	(INTSCA)	;INTEGER SCAN
FBASC7:
	JSB	(NEXCHA)	;NEXT CHAR
	SCE	(CRR)		;CAR RETURN-EOF KEY
	CCFT	(M7QT)	;UNTERMINATED HOLLERITH STRING QT
FBASC8:
	CSA	(SNGLQT)	;QT
	JMPF	(FBASC7)	;$7
	SCE	(SNGLQT)	;QT
	JMPT	(FBASC7)	;$7
	JMP	(FBAS11)	;$11
FBASC9:
	JSB	(HCOSCA)	;HOL CONST SCAN
	REL	(CTEROL)	;CONST TEMP ROLL
	POW	(D1)		;ONE
FBAS11:
	SCK	(CPAKEY)	;COMMA-VIRGULE-R PAREN
	XITT	(EXIML)	;EXIT
	JMP	(FBASCA)	;FORMAT BASIC SCAN
FBAS13:
	SCK	(DIGKEY)	;DIGIT KEY
	XITF	(EXIML)	;EXIT
	JSB	(INTSCA)	;INTEGER SCAN
	CSA	(PERIOD)	;PERIOD
	JMPT	(INTSCA)	;INTEGER SCAN
	JMP	(FBAS11)	;$11
FBAS12:
	SCK	(DIGKEY)	;DIGIT KEY
	XITF	(EXIML)	;EXIT
	JMP	(INTSCA)	;INTEGER SCAN
RFOSPR:					;REGISTER FORMAT SPROGS
	XML	(LSSIML)
	REG	(GSPFIL)
	XML	(LSSIML)
	REG	(GSPFIL)
	XIT	(EXIML)
CSTXLA:					;CALL STA XLATE
	FEX	(COSTXL)	;CONTINUE STA XLATE
	QSF	(CALQT)	;CALL QT
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(RGLSPR)	;REGISTER GLOBAL SPROG
	SMK	(GSPEM)	;GLOBAL SPROG EM
	LCFF	(I10QT)	;ID CONFLICT QT
	ISE	(CNAFIL)
	LCFT	(I16QT)		;CONFLICT W/ COMMON DECLARATION	;"23A"
	FET	(NOPPNT)	;"21V"
	SME	(FSPEM)		;"21V"
	EAWT	(D12)		;"21V"
	STOT	(REGCNT)	;"21V"
	CSA	(LPAREN)	;L PAREN
	JSBT	(SASXLA)	;SPROG ARG SEQ XLATE
	XW0.0T	(FET)		;SPROG NAME PNTR RUNG
	STOT	(ETYATO)	;EXP TYPE ATOM
	NOZ	(JOUFLA)	;JUMP OUT FLAG (DO LOOP)
	JSBT	(FRPGEN)	;FUNC REF PNTR GEN
	JSBF	(SLGFIN)	;SPROG LINK GEN FIN
	POWT	(D2)		;TWO
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
COSTXL:					;CONTINUE STA XLATE
	FEX	(TSTXLA)	;TYPE STA XLATE
	QSF	(CONQT)	;CONTINUE QT
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
TSTXLA:					;TYPE STA XLATE
	FEX	(ACSTXL)	;ACCEPT STA XLATE
	QSF	(TYPQT)	;TYPE QT
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	EAW	(D0)		;MINUS ONE
	JMP	(FCIXLA)	;FORMAT COMMA IOL XLATE
ACSTXL:					;ACCEPT STA XLATE
	FEX	(RSTXLA)	;READ STA XLATE
	QSF	(ACCQT)	;ACCEPT QT
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..IN1)	;IN. INST
	EAW	(D3)		;MINUS FOUR
	JMP	(FCIXLA)	;FORMAT COMMA IOL XLATE
RSTXLA:					;READ STA XLATE
	FEX	(WSTXLA)	;WRITE STA XLATE
	QSF	(READQT)	;READ QT
GRSXLA:					;GENERAL READ STA XLATE
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	CSA	(LPAREN)	;L PAREN
	EAWI	(..IN1)	;IN. INST
	EAWF	(D4)		;MINUS FIVE
	JMPF	(FCIXLA)	;FORMAT COMMA IOL XLATE
	JSB	(IUNXLA)	;IO UNIT XLATE
	CSA	(LBSIGN)	;DIRECT ACCESS I/O ?
	CSAF	(SNGLQT)	;IBM COMPATIBLE	;"23G"
	JSBT	(DIOXLA)	;YES, GO XLATE THE RECORD #
	SCE	(COMMA)		;COMMA ;"22Q"
	JMPF	(GRSXL1)	;"22B"
	JSB	(EOEGEN)	;CHECK FOR END= OR ERR= "22B"
	JMPF	(GIOFIN)	;GENERAL IO FINISH
GRSXL1:
	CSF	(RPAREN)	;R PAREN
	LSS	(BINWR.)	;BINWR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	EAWI	(..RTB0)	;RTB. INST
BFIENT:					;BINARY FINISH ENTRY
	W2	(STO)		;W2
	JSB	(BTAENT)	;BINARY TAPE ENTRY
	CSA	(COMMA)	;OPTIONAL COMMA
	CSA	(CRR)		;AN I/O LIST FOLLOWS ? ;"21Y"
	JMPF	(CIXEND)	;YES, COMMA IOL XLATE END ;"21Y"
	JMP	(IOLEND)	;NO, FINISH UP ;"21Y"
WSTXLA:					;WRITE STA XLATE
	FEX	(PSTXLA)	;PUNCH STA XLATE
	QSF	(WRIQT)	;WRITE QT
	CSF	(LPAREN)	;L PAREN
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	JSB	(IUNXLA)	;IO UNIT XLATE
	CSA	(LBSIGN)	;DIRECT ACCESS I/O ?
	CSAF	(SNGLQT)	;IBM COMPATIBLE	;"23G"
	JSBT	(DIOXLA)	;YES, GO XLATE THE RECORD #
	SCE	(COMMA)		;COMMA ;"22Q"
	JMPF	(WSTXL1)	;BYPASS "22B"
	JSB	(EOEGEN)	;CHECK FOR END= OR ERR= "22B"
	JMPF	(GIOFIN)	;GENERAL IO FINISH "22B"
WSTXL1:
	CSF	(RPAREN)	;R PAREN
	LSS	(BINWR.)	;BINWR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	EAWI	(..WTB0)	;WTB. INST
	JMP	(BFIENT)	;BINARY FINISH ENTRY
GIOFIN:					;GENERAL IO FINISH
	JSB	(FRESCA)	;FORMAT REFERENCE SCAN
				;2 LINES DELETED ;"22Q"
	CSF	(RPAREN)	;R PAREN
	SCE	(CRR)		;CAR RETURN
	JMPT	(IOLEND)	;IOL END
	CSA	(COMMA)	;COMMA
	JMP	(CIXEND)	;COMMA IOL XLATE END
PSTXLA:					;PUNCH STA XLATE
	FEX	(PRSTXL)	;PRINT STA XLATE
	QSF	(PUNQT)	;PUNCH QT
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	EAW	(D1)		;MINUS TWO
	JMP	(FCIXLA)	;FORMAT COMMA IOL XLATE
PRSTXL:					;PRINT STA XLATE
	FEX	(RERXLA)	;REREAD STA XLATE
	QSF	(PRIQT)	;PRINT QT
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	EAW	(D2)		;MINUS THREE
FCIXLA:					;FORMAT COMMA IOL XLATE
	W0	(NOT)
	JSB	(FRESCA)	;FORMAT REFERENCE SCAN
	CSA	(COMMA)		;COMMA
	JMPF	(IOLEND)	;IOL END
CIXEND:					;COMMA IOL XLATE END
	RSV	(VARROL)	;SETUP VARIABLE POINTER ROLL
	RSV	(CODROL)	;SETUP CODE ROLL
	SNZ	(IIVPNT)	;DO INDEX TO SAVE ?
	FETT	(IIVPNT)	;SAVE NORMAL DO INDEX PNTR
	STOT	(DSTPNT)	;DO STATUS PNTR
	JSB	(IOLXLA)	;IOL XLATE
	JSB	(IOLSCA)	;RESCAN THE VARIABLES FOR OPTIMIZATION
	JSBT	(RDOREG)	;RESTORE DO INDEX IF NECESSARY
	REL	(VARROL)	;RESET THE VARIABLE ROLL
IOLEND:					;IOL END
	POC	(ABSINS)	;ABS INST
	POC	(..FIN0)
	SCE	(CRR)		;IS THIS THE END ?	;"23M"
	CCFF	(S21QT)		;NO, ERROR	;"23M"
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
FRESCA:					;FORMAT REFERENCE SCAN
	CSA	(COMMA)		;SCAN PAST COMMA ;"22Q"
	SCK	(DIGKEY)	;DIGIT KEY
	JSBT	(LBLSCA)	;LBL SCAN
	JMPT	(FRESC3)	;$3
	JSB	(IDSCAN)	;ID SCAN

IFNDEF	$NAME,
<
	JMPT	(FRESC2)	;$2
	ISE	(NNAFIL)	;NAMELIST NAME FILE
	JSBT	(REGNAM)	;REGISTER NAMELIST
	XNIT	(NNAPNT)	;NAMELIST NAME PNTR
	FETT	(ONERUN)	;ONE RUNG
	NOZT	(JOUFLA)	;SET JUMP OUT FLAG
	JMPT	(FRESC3)	;$3
>
FRESC2:
	SMK	(ARREM)	;ARRAY EM
	LCFF	(I4QT)	;ID CONFLICT QT
	JSB	(REGALL)	;REGISTER ALLIO.
	JMP	(IARSIZ)	;INSERT ARRAY SIZES
FRESC3:
	BAI	(.MEI1)	;MOVEI 1 INST
BTAENT:					;BINARY TAPE ENTRY
	SCE	(COMMA)		;FORMAT FOLLOWED BY COMMA ? ;"22Q"
	JSBT	(EOEGEN)	;YES, GO TO END/ERROR GENERATE ;"22Q"
	SMK	(MLBEM)	;MADE LBL EM
	JSBT	(MLGAKE)	;MADE LBL GEN AND KEEP
	CLAT	(ZERO)	;ZERO
	POC	(ABSINS)	;ABS INST
	AND	(RHAMAS)	;RIGHT HALF MASK
	W1	(IOM)		;W1
	JMP	(MOCOEX)	;MOVE ON CODE EXIT

RERXLA:					;REREAD STA XLATE
	FEX	(ESTXLA)	;ENCODE STA XLATE
	QSF	(REREQT)	;REREAD
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..IN1)	;IN.	1,
	EAW	(D5)		;-6 = .NOT. 5
	JMP	(FCIXLA)	;FORMAT COMMA I/O LIST XLATE

ESTXLA:					;ENCODE STA XLATE
	FEX	(DESTXL)	;DECODE STA XLATE
	QSF	(ENCQT)	;ENCODE
	CSF	(LPAREN)	;LEFT PARENTHESIS
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..ENC1)	;ENC.	1,
	JMP	(EDCFIN)	;ENCODE/DECODE FIN

DESTXL:					;DECODE STA XLATE
	FEX	(INSTXL)	;INTEGER STA XLATE
	QSF	(DECQT)	;DECODE
	CSF	(LPAREN)	;LEFT PARENTHESIS
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..DEC1)	;DEC.	1,
EDCFIN:					;ENCODE/DECODE FIN
	JSB	(IUNXLA)	;I/O UNIT XLATE
	CSF	(COMMA)	;COMMA
	SCK	(DIGKEY)	;IS FORMAT A DIGIT
	JSBT	(LBLSCA)	;GET A LABEL
	JMPT	(EDCFI3)	;NOW GEN V POINTER
	JSB	(IDSCAN)	;IS FORMAT NAME DEFINED
	SMK	(ARREM)		;AS AN ARRAY
	LCFF	(I4QT)		;NO,'FORMAT NAME NOT ARRAY'
	JSB	(REGALL)	;REG ALLIO ON ROLL
	FET	(ARRPNT)	;GET ARRAY PNTR
	W1	(SWT)		;SAVE IT IN A SAFE PLACE
EDCFI3:	CSF	(COMMA)		;COMMA TEST
	LSS	(VADDR.)	;LOAD NAME ON SYMTAB
	REG	(GSPFIL)	;REGISTER ON GSPFIL
	FET	(GSPPNT)	;GET POINTER
	JSB	(IDSCAN)	;IS VARIABLE DEFINED
	JSBF	(REGSCA)	;NO,MAKE SCALAR VARIABLE
	SMKT	(ARREM)	;IS VAR REF AN ARRAY
	JMPF	(EDCFI1)	;NO,TEST FOR SCALAR
	CSA	(LPAREN)	;YES,IS IT SUBSCRIPTED
	JSBT	(AREXLA)	;YES,ARRAY REF XLATE
	JMPT	(EDCFI2)	;"22I"
	ISE	(GDMFIL)	;GLOBAL DUMMY ARRAY? "22I"
	BAIT	(.ME0)		;MOVE INST "22I"
	JMPT	(EDCFI4)	;"22I"
EDCFI2:
	BAI	(.MEI0)	;MOVEI 0,ADDR 
EDCFI4:			;"22I"
	BAI	(.RRM0)	;HRRM 0,VADDR.
	CSF	(RPAREN)	;R PAREN? NO-FAIL
	SMK	(ARREM)		;IS FORMAT AN ARRAY
	W1T	(SWT)		;GET THE POINTER FROM ITS HIDEING PLACE
	STOT	(ARRPNT)	;RESTORE ARRAY PNTR
	JSBT	(IARSIZ)	;YES,SET SIZE AND FINISH
	JSBF	(FRESC3)	;NO,GEN INST AND FINISH
	CSA	(COMMA)	;ALLOW OPTIONAL COMMA
	JMP	(CIXEND)	;GO PROCESS LIST
EDCFI1:
	SMK	(SCAEM)	;IS VARIABLE A SCALAR
	CCFF	(I12QT)	;NO,ERR-VAR NOT SCALAR OR ARRAY
	CSA	(LPAREN)	;YES,IS IT SUBSCRIPTED
	LCFT	(S4QT)	;YES,ERR-MAY NOT BE SUBSCRIPTED
	SNZ	(DEFINE)	;ENCODE ? ;"23-AL"
	JMPT	(EDCFI2)	;NO, CONTINUE SCAN ;"23-AL
	ISE	(GDMFIL)	;GLOBAL DUMMY ? ;"23-AL"
	REGT	(DEFFIL)	;YES, DEFINE IT ;"23-AL"
	JMP	(EDCFI2)	;NO,OUTPUT INSTRUCTIONS


DIOXLA:						;DIRECT ACCESS I/O XLATE
	JSB	(FESACO)	;FIXED EXP SCAN & COLLAPSE
	JSB	(EIRGEN)	;EXP IN REG GEN
	LSS	(RECNO.)	;LOAD EXTERNAL LOCATION OF RECORD #
	REG	(GSPFIL)	;REGISTER AND MAKE A PNTR
	FET	(GSPPNT)	;GET THE POINTER
	BIN	(.MEM0)	;BUILD  MOVEM 00,RECNO.
	LSS	(RANAC.)	;LOAD EXT LOC OF RANDOM ACCESS FLAG
	REG	(GSPFIL)	;REGISTER AND MAKE A PNTR
	FET	(GSPPNT)	;GET THE POINTER
	BAI	(.SEOM0)	;BUILD SETOM 00,RANAC.
	XIT	(P1EML)	;EXIT, PRUNING THE REG PNTR
IARSIZ:					;INSERT ARRAY SIZES
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(TWORUN)	;TWO RUNG
	SON	(DITEM)		;IS ARRAY DOUBLE - "20H"
	MPYT	(TWO)		;YES DOUBLE SIZE - "20H"
	W1	(SWT)		;W1
	XW0.0	(FET)		;GET ARRAY NAME
	STO	(SYMBOL)	;STORE IT FOR THE ISE SEARCH
	ISE	(GDMFIL)	;GLOBAL DUMMY DIMENSIONED LOCALY
	BAIF	(.MEI1)	;MOVEI  1,  INST
;	BAIT	(.ME2)	;MOVE   1,  INST			; *EJG* 12/17/76
	BAIT	(.MEI3)	;MOVEI  1,@ INST			; *EJG* 12/17/76
	W0	(SNZ)
	POCT	(ABSINS)	;ABS INST
	ANDT	(RHAMAS)	;RIGHT HALF MASK
	IORT	(HRLI1I)	;HRLI 1 INST
	MONT	(CODROL)	;CODE ROLL
	XNIF	(ARRPNT)	;ARRAY PNTR
	CLAF	(CSIRUN)	;CALC SIZE RUNG
	BAIF	(.RL1)	;HRL 1 INST
	JMP	(BTAENT)	;BINARY TAPE ENTRY
IUNXLA:					;IO UNIT XLATE
	SCK	(DIGKEY)	;DIGIT KEY
	SCKF	(POMKEY)	;SIGNED CONSTANT ?
	JSBT	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	XITT	(EXIML)		;EXIT TO ML
	JSBF	(VARSCA)	;VARIABLE SCAN
	SMK	(ITYEM)		;IS VAR AN INTEGER TYPE
	LCFF	(M16QT)		;NO,NON-INTEGER ERROR
	JSB	(AIVREP)	;CHECK FOR DO LOOP INDEX
	BAI	(.ME0)		;MOVE 0 INST
	JSB	(LBLMAK)	;LBL MAKER
	BAK	(.RRM0)		;HRRM 0,LBL
	XIT	(EXIML)		;EXIT
IOLXLA:					;IOL XLATE
	CSA	(LPAREN)	;L PAREN
	JSBF	(IVAXLA)	;IO VAR XLATE
	JMPF	(IOLXL1)	;$1
	ZER	(IIVPNT)	;INSIDE INDUC VAR PNTR
	RSV	(CODROL)	;CODE ROLL
	JSB	(IOLXLA)	;IOL XLATE
	RSV	(PCOROL)	;PROLOG CODE ROLL
	EAW	(PCOROL)	;PROLOG CODE ROLL
	CAR	(CODROL)	;CODE ROLL
	CSA	(RPAREN)	;A REAL IMPLIED DO ?
	JMPT	(STNDRD)	;NO,SAVE INFO GENERATED
	JSB	(IVSFIN)	;INDUC VAR SCAN FIN
	NOZ	(IMDFLG)	;SET INSIDE IMPLIED DO FLG "22K"
	RSV	(SUBROL)	;SAV SUBROL "24-5"
	JSB	(DCOXLA)	;DO CONTROL XLATE
	REL	(SUBROL)	;RELEASE SUBROL "24-5"
	ZER	(IMDFLG)	;CLEAR FOR REGULAR DO'S ;"23S"
	FET	(IIVPNT)	;NEW INDEX
	IER	(IIVEM)	;NEW INDEX PNTR NEEDED FLAG
	MON	(CODROL)	;SAVE
	SNZ	(IOLFLA)	;ALREADY INSIDE A DO LOOP ?
	ZERT	(IIVPNT)	;YES,DEFINE THE DO INDEX VARIABLE
	EAW	(CODROL)	;CODE ROLL
	CAR	(PCOROL)	;PROLOG CODE ROLL
	NOZ	(IOLFLA)	;IOL FLAG
	JSB	(LCGFIN)	;LOOP CLOSE GEN FIN
	CSF	(RPAREN)	;R PAREN
IOLXL1:
	CSA	(COMMA)	;COMMA
	JMPT	(IOLXLA)	;IOL XLATE
	XIT	(EXIML)	;EXIT

IOLSCA:
	CSF	(CRR)		;REALLY THE END
	FLP	(VARROL)	;INVERT VARIABLE ROLL ORDER
	RSV	(PCOROL)	;SETUP PROLOG CODE ROLL
	EAW	(PCOROL)	;ROLL ADDRESS TO W0
	CAR	(CODROL)	;COPY & RELEASE CODE ROLL TO PCOROL
	FLP	(PCOROL)	;INVERT ORDER OF PCOROL
IOLSC1:
	MOA	(PCOROL)	;GET BOTTOM OF PCOROL
	XITF	(EXIML)	;NO MORE ENTRIES, EXIT
	SMK	(IIVEM)	;NEW INDEX PNTR NEEDED ?
	STOT	(IIVPNT)	;YES,RESTORE IT
	NOZT	(REGSAV)	;DISABLE SUBSCRIPT OPTIMIZATION
	JMPT	(IOLSC1)	;ITERATE
	SMKF	(VAREM)	;DOES VARIABLE GO HERE?
	MONF	(CODROL)	;NO, PUT ON CODROL
	ZERF	(IIVPNT)	;CLEAR INDEX FOR NEXT IMPLIED DO
	ZERF	(REGSAV)	;ENABLE SUBSCRIPT OPTIMIZATION
	JMPF	(IOLSC1)	;GET NEXT ENTRY
	POWT	(D1)		;REMOVE VARIABLE INDICATOR
	MOA	(VARROL)	;GET VARIABLE POINTER
	SMK	(ARREM)	;ARRAY W/O SUBSCRIPTS?
	JSBT	(SLIST)	;YES, MAKE SLIST
	JMPT	(IOLSC1)	;GET NEXT ENTRY
	JSB	(AIVCHE)	;CHECK FOR ACTIVE DO LOOP
	JSB	(MTYREG)	;MAKE AC ACCORDING TO VAR. TYPE
	BIN	(..DAT0)	;MAKE DATA UUO
	POW	(D1)		;REMOVE EXTRA WORD
	JMP	(IOLSC1)	;GET NEXT ENTRY

EOEGEN:						;END/ERROR GEN
	QSA	(ENDEQT)	;END=
	JMPF	(EOEGE3)	;$3
	NOZ	(JOUFLA)	;SET JUMP OUT FLG "22F"
	NOZ	(ENDFLG)	;SET FLG ON "22B"
	LSS	(END.)	;GET NAME OF GLOBAL ADDRESS REG
EOEGE1:
	REG	(GSPFIL)	;REGISTER & MAKE A POINTER
	FET	(GSPPNT)	;GET THE POINTER
	SCK	(DIGKEY)	;DIGIT ?
	JSBT	(LBLSCA)	;YES,GET A LABEL
	BAIT	(.MEI0)	;BUILD MOVEI 00,PROGREM LOC
	JMPT	(EOEGE4)	;$2
	JSB	(IDSCAN)	;GET A VARIABLE
	JSBF	(REGSCA)	;REGISTER A SCALAR IF NOT FOUND
	SMK	(SCAEM)
	ERMF	(S8QT)		;NO, ILLEGAL CHARACTER IN LABEL	;"23L"
	XITF	(FAIML)		;AND FAIL	;"23A"
	BAIT	(.ME0)	;BUILD MOVE 00,VARIABLE CONTAINING PROGRAM LOC
EOEGE4:
	BAIT	(.RRM0)	;BUILD HRRM 00,END./ERR.
EOEGE2:
	SCET	(COMMA)		;ANOTHER ONE ? ;"22Q"
	JMPT	(EOEGEN)	;YES,TRY AGAIN
	SNZ	(ENDFLG)	;IS FLG ON? "22B"
	ZERT	(ENDFLG)	;YES CLEAR IT "22B"
	XIT	(EXEQML)	;EXIT WITH FLAG AS SET "22B"
EOEGE3:
	QSA	(ERREQT)	;ERR
	JMPF	(EOEGE2)	;$2
	NOZ	(ENDFLG)	;SET FLG ON "22B"
	NOZ	(JOUFLA)	;SET JUMP OUT FLG "22F"
	LSS	(ERR.)	;GET NAME OF GLOBAL ADDRESS REG
	JMP	(EOEGE1)	;MAKE THE INSTRUCTION
IVAXLA:					;IO VAR XLATE
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)		;SCALAR? - "20D"
	SMKF	(ARREM)		;ARRAY?  - "20D"
	LCFF	(I15QT)		;NOT A SCALAR OR ARRAY - "20D"
	SNZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	ISET	(GDMFIL)	;GLOBAL DEFINITION ? ;"21U"
	REGT	(DEFFIL)	;REGISTER AS DEFINED
	SCE	(EQUAL)	;EQUAL
	XITT	(EXIML)	;EXIT
	SMK	(ARREM)	;ARRAY ID EM
	JMPF	(IVAXL1)	;$1
	CSA	(LPAREN)	;L PAREN
	JSBT	(AREXLA)	;ARRAY REF XLATE
IVAXL1:
	MON	(VARROL)	;PUT POINTER ON VARIABLE ROLL
	FET	(VARPNT)	;GET VARIABLE INDICATOR
	MON	(CODROL)	;PUT ON CODROL
	XIT	(EXIML)	;EXIT

SLIST:
	XW0.4	(FET)		;CALC SIZE RUNG
	SEK	(ZERO)	;ZERO
	BAIF	(.ME0)	;MOVE 0 INST
	JSBF	(LBLMAK)	;LBL MAKER
	BAKF	(.RRM0)	;HRRM INST
	XW1.2T	(CLA)		;ARRAY SIZE RUNG
	IERF	(CVAEM)	;CALC VALUE EM
	W1	(SWT)		;W1
	JSB	(MTYREG)	;MAKE TYPE REG
	XW0.0	(FET)		;LOOK FOR THE RIGHT SYMBOL
	STO	(SYMBOL)
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	BINT	(..SLI1)	;SLIST.* INST
	BINF	(..SLI0)	;SLIST. INST
	POW	(D1)		;ONE
	SMK	(CVAEM)	;CALC VALUE EM
	JSBT	(MLGAKE)	;MADE LBL GEN AND KEEP
	CLAT	(ZERO)	;ZERO
	POC	(ABSINS)	;ABS INST
	EAWI	(.ARG0)		;ARG INSTRUCTION	;"21E"
	W1	(IOM)		;COMBINE WITH ARRAY SIZE	;"21E"
	MON	(CODROL)	;AND PUT ON THE CODE ROLL	;"21E"
	XIT	(EXIML)	;EXIT
MTYREG:					;MAKE TYPE REG
	W0	(FET)		;W0
	XML	(ITIDFM)	;ISOLATE TYPE IN DISPL FIELD
	ADD	(ONE)		;ONE
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT

STNDRD:					;MAKE I/O LISTS CONFORM TO THE STANDARDS
	EAW	(CODROL)
	CAR	(PCOROL)
	JMP	(IOLXL1)
INSTXL:					;INTEGER STA XLATE
	FEX	(RESTXL)	;REAL STA XLATE
	QSF	(INTQT)	;INTEGER QT
	CSA	(ASTERI)	;IBM COMPATIBLE	;"23G"
	CSAT	(N2)		;"23G"
	NOZT	(SINFLA)	;"23G"
	JMPT	(SINENT)	;"23G"
	CSA	(N4)		;"23G"
	ZER	(SINFLA)	;SUBSCRIPT INTEGER FLAG
SINENT:					;SUBSCRIPT INTEGER ENTRY
	FET	(ZERO)	;ZERO
SINEN1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPT	(SINEN2)	;$2
	AGF	(IIDFIL)	;INTEGER ID FILE
	SNZ	(SINFLA)	;SUBSCRIPT INTEGER FLAG
	AGFT	(SIIFIL)	;SUBSCRIPT INTEGER ID FILE
	JMP	(SINEN3)	;$3
SINEN2:
	SMK	(ITYEM)	;INTEGER TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
SINEN3:
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(SINEN1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
RESTXL:					;REAL STA XLATE
	FEX	(DPSXLA)	;DOUBLE PRECISION STA XLATE
	QSF	(REAQT)	;REAL QT
	FET	(ZERO)	;ZERO
	CSA	(ASTERI)	;IBM COMPATIBLE	;"23G"
	CSAT	(N8)		;"23G"
	JMPT	(DPSXL1)	;"23G"
	CSA	(N4)		;"23G"
RESTX1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPT	(RESTX2)	;$2
	AGF	(RIDFIL)	;REAL ID FILE
	JMP	(RESTX3)	;$3
RESTX2:
	SMK	(RTYEM)	;REAL TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
RESTX3:
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(RESTX1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
DPSXLA:					;DOUBLE PRECISION STA XLATE
	FEX	(CXSTXL)	;COMPLEX STA XLATE
	QSF	(DPRQT)	;DOUBLE PRECISION QT
	FET	(ZERO)	;ZERO
DPSXL1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPF	(DPSXL2)	;$2
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
DPSXL2:
	AGFF	(DPIFIL)	;DOUBLE PREC ID FILE
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(DPSXL1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
CXSTXL:					;COMPLEX STA XLATE
	FEX	(LSTXLA)	;LOGICAL STA XLATE
	QSF	(COMPQT)	;COMPLEX QT
	CSA	(ASTERI)	;COMPLEX= (IBM COMPATIBLE)	;"23G"
	SCET	(N1)		;"23G"
	CSAT	(N6)		;COMPLEX*16 ?	;"23G"
	CCFT	(S5QT)		;YES, ILLEGAL TYPE SPECIFICATION	;"23G"
	CSA	(N8)		;COMPLEX*8	;"23G"
	FET	(ZERO)	;ZERO
COSTX1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPF	(COSTX2)	;$2
	SMK	(CTYEM)	;CPLX TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
COSTX2:
	AGFF	(CIDFIL)	;COMPLEX ID FILE
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(COSTX1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
LSTXLA:					;LOGICAL STA XLATE
	FEX	(SISXLA)	;SUBSCRIPT INTEGER STA XLATE
	QSF	(LOGQT)	;LOGICAL QT
	CSA	(ASTERI)	;IBM COMPATIBLE	;"23G"
	CSA	(N1)		;"23G"
	CSAF	(N4)		;"23G"
	FET	(ZERO)	;ZERO
LSTXL1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPF	(LSTXL2)	;$2
	SMK	(LTYEM)	;LOGICAL TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
LSTXL2:
	AGFF	(LIDFIL)	;LOGICAL ID FILE
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(LSTXL1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
TDIXLA:					;TYPE DIMENSION XLATE
	CSA	(LPAREN)	;L PAREN
	JMPF	(TDIXL1)	;$1
	JSB	(IDCLAS)	;ID CLASSIFY
	LCFT	(I2QT)	;ID CONFLICT QT
	JSB	(DSEXLA)	;DIMENSION SEQ XLATE
TDIXL1:
	CSA	(COMMA)	;COMMA
	XIT	(EXEQML)	;EXIT EQUAL ML
SISXLA:					;SUBSCRIPT INTEGER STA XLATE
IFNDEF	$NAME,
<
	FEX	(NSTXLA)	;NAMELIST STA XLATE
>
IFDEF	$NAME,	<IFNDEF	$IMPL,
<
	FEX	(IMSTXL)
>>
IFDEF	$NAME,	<IFDEF	$IMPL,
<
	FEX	(CMSTXL)
>>
	QSF	(SUBSQT)	;SUBSCRIPT QT
	QSF	(INTQT)	;INTEGER QT
	NOZ	(SINFLA)	;SUBSCRIPT INTEGER FLAG
	JMP	(SINENT)	;SUBSCRIPT INTEGER ENTRY
IFNDEF	$NAME,
<
NSTXLA:					;NAMELIST STA XLATE
	FEX	(IMSTXL)	;IMPLICIT STA XLATE
	QSF	(NAMQT)	;NAMELIST QT
NSTXL1:
	CSA	(SLASH)	;SLASH
	LCFF	(S7QT)	;SYNTAX QT
	JSB	(IDSCAN)	;ID SCAN
	ISEF	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I6QT)	;ID CONFLICT QT
	CSF	(SLASH)	;SLASH
	REG	(NNAFIL)	;NAMELIST NAME FILE
	LCFT	(I5QT)	;ID CONFLICT QT
	JSB	(LBLMAK)	;LBL MAKER
	XNI	(NNAPNT)	;NAMELIST NAME PNTR
	STO	(ONERUN)	;ONE RUNG
NSTXL2:
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)	;SCALAR EM
	SMKF	(ARREM)	;ARRAY EM
	LCFF	(I15QT)	;ID CONFLICT QT
	ISE	(NNAFIL)	;NAMELIST NAME FILE
	ISEF	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I6QT)	;ID CONFLICT QT
	CLA	(SYMBOL)	;SYMBOL
	MON	(NITROL)	;NAMELIST ITEMS ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(NSTXL2)	;$2
	LSS	(BLANKS)	;BLANKS
	AGF	(NITFIL)	;NAMELIST ITEMS FILE
	SCE	(SLASH)	;SLASH
	JMPT	(NSTXL1)	;$1
	JSB	(REGALL)
				;LINE DELETED	;"23M"
	JMPF	(CEEEXI)	;COMMON EQUIV EOL EXIT
>
REGALL:					;REGISTER ALLIO.
	LSS	(ALLIO.)	;ALLIO.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	XIT	(EXIML)	;EXIT

IFNDEF	$NAME,
<
REGNAM:					;REGISTER NAMELIST
	LSS	(NMLST.)	;NMLST.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CTBCON)	;CONVERT TO BIN CONST
	W2	(AMY)		;W2
	XIT	(EXIML)	;EXIT
>
IFNDEF	$IMPL,
<
IMSTXL:					;IMPLICIT STA XLATE
	FEX	(CMSTXL)	;COMMON STA XLATE
	QSF	(IMPQT)	;IMPLICIT QT
ITYENT:
	SCK	(LETKEY)	;"IMPLICIT" FOLLOWED BY LETTER ?
	CCFF	(S5QT)		;NO, ILLEGAL TYPE SPECIFICATION
	FET	(ZERO)		;GET BLANK PNTR TO HOLD TYPE
	QSA	(INTQT)		;INTEGER ?
	JMPF	(ITYEN1)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;"23G"
	CSAT	(N2)		;INTEGER*2 ?	;"23G"
	IERF	(ITYEM)		;NO, INTEGER	;"23G"
	IERT	(SINEM)		;YES, SUBSCRIPT INTEGER	;"23G"
	CSA	(N4)		;INTEGER=INTEGER*4	;"23G"
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN1:			;"23G"
	QSA	(REAQT)		;REAL ?
	JMPF	(ITYEN2)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;"23G"
	CSAT	(N8)		;REAL*8 ?	;"23G"
	IERF	(RTYEM)		;NO, REAL	;"23G"
	IERT	(DPTEM)		;YES, DOUBLE PRECISION	;"23G"
	CSA	(N4)		;REAL=REAL*4
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN2:				;"23G"
	QSA	(LOGQT)		;LOGICAL ?
	JMPF	(ITYEN3)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;LOGICAL=	;"23G"
	CSA	(N1)		;LOGICAL*1	;"23G"
	CSA	(N4)		;OR LOGICAL*4	;"23G"
	IER	(LTYEM)		;MAKE ALL OF THE ABOVE LOGICAL	;"23G"
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN3:				;"23G"
	QSA	(COMPQT)	;COMPLEX ?
	JMPF	(ITYEN4)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;COMPLEX=
	CSAT	(N1)		;"23G"
	SCET	(N6)		;COMPLEX*16 ?	;"23G"
	CCFT	(S5QT)		;YES, ILLEGAL TYPE SPECIFICATION	;"23G"
	CSA	(N8)		;COMPLEX*8	;"23G"
	IER	(CTYEM)		;MAKE BOTH OF THE ABOVE COMPLEX 	;"23G"
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN4:				;"23G"
	QSA	(DPRQT)	;DOUBLE PRECISION QT
	IERT	(DPTEM)	;DOUBLE PREC TYPE EM
	JMPT	(IPASCA)	;IMP PAREN SCAN
	QSA	(SUBSQT)	;SUBSCRIPT QT
	QSAT	(INTQT)	;INTEGER QT
	IERT	(SINEM)	;SUBSCRIPT INTEGER EM
	CCFF	(S5QT)	;SYNTAX QT
IPASCA:					;IMP PAREN SCAN
	CSF	(LPAREN)	;L PAREN
IPASC2:
	JSB	(IELSCA)	;IMP ELEMENT SCAN
	CSA	(COMMA)	;COMMA
	JMPT	(IPASC2)	;$2
	CSF	(RPAREN)	;R PAREN
	POW	(D1)		;ONE
	CSA	(COMMA)	;COMMA
	JMPT	(ITYENT)
	NOZ	(IIAFLA)	;"23M"
	SNZ	(GSTFLA)	;EXECUTABLE STATEMENTS PRECEED ?	;"23M"
	CCFT	(O3QT)		;YES, ORDER ERROR	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
>
IFNDEF	$IMPL,
<

IELSCA:					;IMP ELEMENT SCAN
	SCK	(LETKEY)	;LETTER KEY
	CCFF	(S6QT)	;SYNTAX QT
	XML	(ICFCCS)	;IMPLICIT CLUE FROM CURRNT CHAR SET
	ISE	(IMPFIL)	;IMPLICIT FILE
	CCFT	(I3QT)	;SYNTAX QT
	FET	(IMPCLU)	;IMPLICIT CLUE
	W1	(IOR)		;W1
	MON	(IMPROL)	;IMPLICIT ROLL
	JSB	(NEXCHA)	;NEXT CHAR
	CSA	(MINUS)	;MINUS
	XITF	(EXIML)	;EXIT
	SCK	(LETKEY)	;LETTER KEY
	CCFF	(S6QT)	;SYNTAX QT
	FET	(IMPCLU)	;IMPLICIT CLUE
	XML	(ICFCCS)	;IMPLICIT CLUE FROM CURRNT CHAR SET
	FET	(IMPCLU)	;IMPLICIT CLUE
	JSB	(NEXCHA)	;NEXT CHAR
	W1	(SWT)		;W1
IELSC1:
	W1	(SLK)		;W1
	XITF	(P2EML)
	ADD	(ONE)
	STO	(IMPCLU)	;IMPLICIT CLUE
	W1	(SWT)		;W1
	ISE	(IMPFIL)
	CCFT	(S12QT)		;SYNTAX QT	;"23N"
	FET	(IMPCLU)	;IMPLICIT CLUE
	W1	(IOR)		;W1
	MON	(IMPROL)	;IMPLICIT ROLL
	W1	(SWT)		;W1
	FET	(IMPCLU)	;IMPLICIT CLUE
	JMP	(IELSC1)	;$1
>
CMSTXL:					;COMMON STA XLATE
	FEX	(EQSTXL)	;EQUIVALENCE STA XLATE
	QSF	(COMQT)	;COMMON QT
	LSS	(COMM)	;COMM
	CSA	(SLASH)	;SLASH
	JMPF	(CMSTX2)	;$2
CMSTX1:
	CSA	(SLASH)	;SLASH
	JMPT	(CMSTX2)	;$2
	JSB	(SYMSCA)	;SYMBOL SCAN
	CSF	(SLASH)	;SLASH
CMSTX2:
	AGF	(CNAFIL)	;COMMON NAMES FILE
CMSTX3:
	JSB	(SYMSCA)	;SYMBOL SCAN
	ISE	(CDAFIL)	;COMMON DATA FILE
	ISEF	(GDMFIL)	;GLOBAL DMY FILE
	ISEF	(GSPFIL)	;GLOBAL SPROG FILE
	LCFT	(A2QT)	;ALLOCATION QT
	AGF	(CDAFIL)	;COMMON DATA FILE
	CSA	(LPAREN)	;L PAREN
	JSBT	(DSEXLA)	;DIMENSION SEQ XLATE
	CSA	(COMMA)	;COMMA
	JMPT	(CMSTX3)	;$3
	LSS	(BLANKS)	;BLANKS
	AGF	(CDAFIL)	;COMMON DATA FILE
	LSS	(COMM)	;COMM
	CSA	(SLASH)	;SLASH
	JMPT	(CMSTX1)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
EQSTXL:					;EQUIVALENCE STA XLATE
	FEX	(EXSTXL)	;EXTERNAL STA XLATE
	QSF	(EQUQT)	;EQUIVALENCE QT
ESTXL1:
	CSF	(LPAREN)	;L PAREN
	ZER	(TEMP)		;SET FOR 2 ELEMENTS IN EQUIV
	JSB	(ESEXLA)	;EQUIV SEG XLATE
	SNZ	(TEMP)		;AT LEAST 2 ITEMS IN EQUIV?
	LCFF	(S19QT)		;NO ERROR
	CSF	(RPAREN)	;R PAREN
	LSS	(BLANKS)	;BLANKS
	AGF	(EDAFIL)	;EQUIV DATA FILE
	CSA	(COMMA)	;COMMA
	JMPT	(ESTXL1)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
ESEXLA:					;EQUIV SEG XLATE
	JSB	(SYMSCA)	;SYMBOL SCAN
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(A3QT)	;ALLOCATION QT
	ISE	(ARRFIL)	;ARRAY FILE
	CSAT	(LPAREN)	;L PAREN
	ZERF	(DAT1)	;DATA 1
	JMPF	(ESEXL3)	;$3
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(OFFRUN)	;OFFSET RUNG
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(SPNRUN)	;STAT PNTR RUNG
	STK	(ASTPNT)	;ARRAY STAT PNTR
	XW0.0	(CLA)		;ZERO RUNG
ESEXL1:
	JOW	(ESEXL2)	;$2
	DFA	(ASTROL)	;ARRAY STAT ROLL
	JSB	(SINSCA)	;SIGNED INTEGER SCAN
	MPY	(DAT2)	;DATA 2
	W2	(SMY)		;W2
	CSA	(COMMA)	;COMMA
	JMPT	(ESEXL1)	;$1
	JOW	(ESEXL2)	;$2
	ADD	(TWO)		;TWO
	XNI	(ARRPNT)	;ARRAY PNTR
	XNI	(SPNRUN)	;STAT PNTR RUNG
	SEQ	(ZERRUN)	;ZERO RUNG
	LCFF	(M2QT)	;TOO FEW SCRIPTS QT
	W0	(TLY)		;W0
	XNI	(ARRPNT)	;ARRAY PNTR
	SUB	(OFFRUN)	;OFFSET RUNG
ESEXL2:
	STO	(DAT1)	;DATA 1
	CSA	(RPAREN)	;R PAREN
	CCFF	(M1QT)	;TOO MANY SCRIPTS QT
ESEXL3:
	AGF	(EDAFIL)	;EQUIV DATA FILE
	CSA	(COMMA)	;COMMA
	TLYT	(TEMP)		;NOW THERE IS AT LEAST 2
	JMPT	(ESEXLA)	;EQUIV SEG XLATE
	XIT	(EXIML)	;EXIT
EXSTXL:					;EXTERNAL STA XLATE
	FEX	(RTSTXL)	;RETURN STA XLATE
	QSF	(EXTQT)	;EXTERNAL QT
EXSTX1:
	JSB	(IDSCAN)	;ID SCAN
	JMPT	(EXSTX2)	;$2
	ISEF	(CDAFIL)	;COMMON DATA FILE
			;LINE DELETED HERE "22G"
	FPCT	(ZERO)	;ZERO
EXSTX2:
	ERMT	(I7QT)	;ID CONFLICT QT
	AGFF	(GSPFIL)	;GLOBAL SPROG FILE
	CSA	(COMMA)	;COMMA
	JMPT	(EXSTX1)	;$1
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
RTSTXL:					;RETURN STA XLATE
	FEX	(ASSTXL)	;ASSIGN STA XLATE
	QSF	(RETQT)	;RETURN QT
	XNI	(NOPPNT)	;NAME OF PROG PNTR
	FET	(ZERRUN)	;ZERO RUNG
	SEK	(MAITES)	;MAIN. TEST
	JMPT	(STSTX1)	;MAKE JSA	16,EXIT	;"21F"
	NOZ	(JOUFLA)	;SET JUMP OUT FLG "22F"
	SEQ	(DATTES)	;DATA. TEST
	JMPT	(ACEOEX)	;ACTIVE EOL EXIT
	SCE	(CRR)		;CAR RET "22A"
	JMPT	(RTSTX3)	;YES "22A
	SNZ	(MULRET)	;MULT RETURN? "22A"
	CCEF	(S16QT)		;NO ERR "22A"
	JMPF	(RTSTX4)	;"22A"
	SCK	(DIGKEY)	;DIGITS? "22A"
	JMPF	(RTSTX2)	;NO "22A"
	JSB	(INTSCA)	;CHECK INTEGERS "22A"
	FET	(DAT2)		;GET THE NUMBER "22A"
	POC	(ABSINS)	;SET FOR ABSOLUTE "22A"
	BAI	(.MEI1)		;MOVE "22A"
	JMP	(RTSTX4)	;"22A"
RTSTX2:
	JSB	(IVASCA)	;INDUCED VAR SCA "22A"
	BAI	(.ME2)		;MOVE "22A"
	JMP	(RTSTX4)	;"22A"
RTSTX3:
	SNZ	(MULRET)	;MULT RETURN? "22A"
	JMPF	(RTSTX4)	;"22A"
	POC	(ABSINS)	;ABSOLUTE "22A"
	FET	(ZERO)		;ZERO "22A"
	BAI	(.MEI1)		;MOVE "22A"
RTSTX4:			;"22A"
	SNZ	(RETPNT)	;RETURN PNTR
	JSBF	(LBLMAK)	;LBL MAKER
	STKF	(RETPNT)	;RETURN PNTR
	FETT	(RETPNT)	;RETURN PNTR
	BAI	(.JRST0)
	JMP	(RETEXI)	;RETURN EOL EXIT	;"23P"
ASSTXL:					;ASSIGN STA XLATE
	FEX	(PASTXL)	;PAUSE STA XLATE
	QSF	(ASSQT)	;ASSIGN QT
	JSB	(LBLSCA)	;LBL SCAN
	BAI	(.MEI0)	;MOVEI INST
	QSF	(TOQT)	;TO QT
	JSB	(VARSCA)	;VAR SCAN
	BAI	(.MEM0)	;MOVEM INST
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
PASTXL:					;PAUSE STA XLATE
	FEX	(STSTXL)	;STOP STA XLATE
	QSF	(PAUQT)	;PAUSE QT
	SCE	(CRR)		;CAR RETURN
	POCT	(ABSINS)	;ABS INST
	POCT	(.MEI1)	;MOVEI 1 INST
	JMPT	(PASTX1)	;$1
	SCK	(DIGKEY)	;DIGIT KEY
	JSBT	(ODISCA)	;OCTAL DIGIT SCAN
	JSBT	(RINCON)	;REGISTER INTEGER CONST
	JSBF	(CONSCA)	;CONST SCAN
	SMK	(HCOEM)	;HOLLERITH CONST EM
	BAIF	(.RROI1)	;HRROI 1 INST
	XW0.0T	(FET)		;ZERO RUNG
	W1T	(SWT)		;W1
	BAIT	(.MEI1)	;MOVEI 1 INST
	IORT	(HRLI1I)	;HRLI 1 INST
	POCT	(ABSINS)	;ABS INST
	MONT	(CODROL)	;CODE ROLL
PASTX1:
	LSS	(PAUSE.)	;PAUSE.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	BAI	(.PSHJ1)	;PUSHJ 17 INST
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
STSTXL:					;STOP STA XLATE
	FEX	(RWSTXL)	;REWIND STA XLATE
	QSF	(STOQT)	;STOP QT
	SCE	(CRR)		;A NORMAL STOP ?
	JMPT	(STSTX1)	;YES,FINISH UP
	SCK	(DIGKEY)	;FOLLOWED BY A NUMBER ?
	JSBT	(ODISCA)	;GET AN OCTAL NUMBER
	JSBT	(RINCON)	;REGISTER THE CONSTANT
	BAIT	(.ARG0)	;PASS IT ON TO FORSE.
STSTX1:
	LSS	(EXIT.)	;EXIT.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	BAI	(.JSA1)
	JMP	(STOEXI)	;STOP EOL EXIT	;"23P"
RWSTXL:					;REWIND STA XLATE
	FEX	(BASTXL)	;BACKSPACE STA XLATE
	QSF	(REWQT)	;REWIND QT
	FET	(ZERO)	;ZERO
TFIXLA:					;TAPE FINISH XLATE
	LSS	(TPFCN.)	;TPFCN.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
BSTFXL:					;BACKSP.,SKIP TAPE FIN XLATE
	ADD	(BREPNT)	;BLANK REG PNTR
	JSB	(FESACO)	;FX EXP SCAN AND COLLAPSE
	SMK	(CONEM)	;CONST EM
	JMPF	(TFIXL1)	;$1
	XW0.0	(CLA)		;ZERO RUNG
	AND	(DISMAS)	;DISPL MASK
	ADD	(BREPNT)	;BLANK REG PNTR
	JMP	(TFIXL2)	;$2
TFIXL1:
	JSB	(EIR0GE)	;EXP IN REG 0 GEN
	JSB	(LBLMAK)	;LBL MAKER
	BAK	(.RRM0)	;HRRM 0 INST
	JSB	(LBLGEN)	;LBL GEN
TFIXL2:
	BIN	(..MTO0)	;MTOP INST
	POW	(D1)		;ONE
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
BASTXL:					;BACKSPACE STA XLATE
	FEX	(USTXLA)	;UNLOAD STA XLATE
	QSF	(BACQT)	;BACKSPACE QT
	FET	(TWO)		;TWO
	LSS	(MBSR.)	;MBSR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(BSTFXL)	;BACKSP.,SKIP TAPE FIN XLATE
USTXLA:					;UNLOAD STA XLATE
	FEX	(SKIXLA)	;SKIP XLATE
	QSF	(UNLQT)	;UNLOAD QT
	FET	(ONE)		;ONE
	JMP	(TFIXLA)	;TAPE FINISH XLATE
SKIXLA:					;SKIP XLATE
	FEX	(ENDXLA)	;END XLATE
	QSF	(SKIQT)	;SKIP QT
	QSF	(RECQT)	;RECORD QT
	FET	(FIVE)	;FIVE
	LSS	(MSPR.)	;MSPR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(BSTFXL)	;BACKSP,SKIP TAPE FIN XLATE
ENDXLA:					;END XLATE
	FEX	(ERSTXL)	;ERASE STA XLATE
	QSF	(ENDQT)	;END QT
	SCE	(CRR)		;CAR RET CHAR I
ENSTXL:					;END STA XLATE
	NOZT	(ESTFLA)	;END STA FLAG
	XITT	(ETRML)	;EXIT TRUE EOL
ENSTX1:
	QSF	(FILQT)	;FILE QT
	EAW	(D4)		;FOUR
	JMP	(TFIXLA)	;TAPE FINISH XLATE
ERSTXL:					;ERASE STA XLATE
	FEX	(ISTPAR)	;ILLEGAL STATEMENT PARSE
	QSF	(ERAQT)	;ERASE QT
	EAW	(D6)		;SIX
	JMP	(TFIXLA)	;TAPE FINISH XLATE
ISTPAR:					;ILLEGAL STA PARSE
	SRD	(ERRROL)	;ERROR ROLL
	JMPT	(ISTPA1)	;$1
	SNZ	(FAICAR)
	CCEF	(S2QT)		;SYNTAX QT	;"23N"
	FET	(FMSBOX)	;FAIL MSG BOX
	MON	(ERRROL)	;ERROR ROLL
ISTPA1:
	XML	(OERML0)	;ORDER ERROR ROLL
	ZER	(JSTFLA)	;JUMP STA FLAG
	JSB	(DCLGEN)	;DO CLOSE GEN
	BLK	(.EXER1)	;EXER1. LINK
	JMP	(EXIFAL)	;EXIT FALSE

CDEEXI:				;INTEGER,SUBSCRIPT INTEGER,REAL,LOGICAL,
				;DOUBLE PRECISION & COMPLEX TYPE STATEMENT
				;END OF LINE EXIT
	POW	(D1)		;ONE
CEEEXI:				;COMMON,EQUIVALENCE,EXTERNAL,IMPLICIT,NAMELIST,
				;DATA & DIMENSION END OF LINE EXIT
	ZER	(ENDCOD)	;"23P"
	NOZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	SCE	(CRR)		;CAR RETURN
	CCFF	(S9QT)		;SYNTAX QT	;"23M"
				;2 LINES DELETED	;"23M"
	XIT	(ETRML)	;EXIT TRUE EOL

AEOEXI:				;AFDS EOL EXIT
	ZER	(ENDCOD)	;"23P"
	SCE	(CRR)		;CAR RETURN
	JMPT	(JAFEXI)	;JUMP AFDS EXIT
	CCF	(S20QT)		;SYNTAX QT	;"23M"
LIFEXI:				;LOGICAL IF EXIT
	NOZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
ACEOEX:				;ACTIVE (ASSIGNMENT,CALL,CONTINUE,I/O,
				;RETURN(BLOCK DATA),ASSIGN,PAUSE,REWIND,
				;BACKSPACE,UNLOAD,SKIP RECORD,END FILE &
				;ERASE) END OF LINE EXIT
	SCE	(CRR)		;CAR RETURN
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	ZER	(JSTFLA)	;JUMP STA FLAG
	ZER	(ENDCOD)	;"23P"
	JMP	(JUMEXI)	;JUMP-ACTIVE EXIT

STOEXI:				;STOP STATEMENT END OF LINE EXIT	;"23P"
	XNI	(NOPPNT)	;GET PROGRAM NAME	;"23P"
	FET	(ZERRUN)	;"23P"
	SEQ	(MAITES)	;MAIN PROGRAM ?	;"23P"
	JMPF	(JEOEXI)	;NO, STOP & END GEN DIFFERENT CODE	;"23P"
RETEXI:				;RETURN STATEMENT END OF LINE EXIT	;"23P"
	NOZ	(ENDCOD)	;INDICATE END STA CODE ALREADY GENNED	;"23P"
	JMP	(JEOEX1)	;"23P"
DOEOEX:				;DO STATEMENT END OF LINE EXIT
	NOZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
JEOEXI:				;GO TO END OF LINE EXIT
	ZER	(ENDCOD)	;"23P"
JEOEX1:				;"23P"
	SCE	(CRR)		;CAR RETURN
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	NOZ	(JSTFLA)	;JUMP STA FLAG
JUMEXI:					;JUMP-ACTIVE EXIT
	NOZ	(ASTFLA)	;ACTIVE STA FLAG
	JSB	(DCLGEN)	;DO CLOSE GEN
JAFEXI:					;JUMP AFDS EXIT

IFNDEF	$DATA,
<
	SNZ	(BDPFLA)
	CCFT	(O4QT)		;BLOCK QT	;"23N"
>
	NOZ	(GSTFLA)	;GEN STA FLAG
	XML	(ETRML)	;EXIT TRUE
AEXSCA:					;ARG EXP SCAN
	NOZ	(FELFLA)	;FIRST ELEM FLAG
EXPSCA:					;EXP SCAN
	ZER	(OPCPNT)	;OP PNTR
	JMP	(SUSCAN)	;SUBEXP SCAN
SSUSCA:					;SIGNED SUBEXP SCAN
	CSA	(MINUS)	;MINUS
	JSBT	(SUSCAN)	;SUBEXP SCAN
	EORT	(MINMAS)	;MINUS MASK
	XITT	(EXIML)	;EXIT
	CSA	(PLUS)	;PLUS
SUSCAN:					;SUBEXP SCAN
	RSV	(SUDROL)	;SUBORDS ROLL
	JSB	(DESCEN)	;DESCEND
	JSB	(SUBSCA)	;SUBORD SCAN
SUSCFI:					;SUBEXP SCAN FIN
	XML	(OPSCAN)	;OP SCAN
	JSBF	(COLSUB)	;COLLAPSE SUBORDS
	RELF	(SUDROL)	;SUBORDS ROLL
	XITF	(ASCML)	;ASCEND
	FPC	(OPCPNT)	;OP PNTR
	W1	(SWT)		;W1
	MON	(SUDROL)	;SUBORDS ROLL
	SPK	(NEGTRA)	;NEG OP TRAIT
	EORT	(NOFMAS)	;NEG OP FLIP MASK
	JSB	(SUBSCA)	;SUBORD SCAN
	EORT	(MINMAS)	;MINUS MASK
	W1	(FET)		;W1
	SPT	(COMTRA)	;COMMUTATIVE TRAIT
	JSBF	(COLSUB)	;COLLAPSE SUBORDS
	XMLT	(OSRML)	;ORDER SUBORDS ROLL
	JMP	(SUSCFI)	;SUBEXP SCAN FIN
LUNSCA:					;LOGICAL UNARY SCAN
	QSA	(NOQT)	;.NOT. QT
	JMPF	(SUSCAN)	;SUBEXP SCAN
	FPC	(NOTMAS)	;NOT MASK
	JSB	(LUNSCA)	;LOGICAL UNARY SCAN
	AND	(ABCCMA)	;ALL BUT CHAR CNT MASK
	W1	(EOM)		;W1
	XIT	(EXIML)	;EXIT
COLSUB:					;COLLAPSE SUBORDS
COLSU1:
	MOA	(SUDROL)	;SUBORDS ROLL
	XITF	(EXIML)	;EXIT
	W2	(FET)		;W2
	SPT	(LOPTRA)	;LOGICAL OP TRAIT
	JSBT	(CLOIDE)	;COLLAPSE LOGICAL IDEMPOT
	JMPT	(COLSU2)	;RESULT IS ALWAYS LOGICAL IF COLLAPSED ;"21I"
	PNG	(NESROL)	;NEST ROLL
	W3	(SWT)		;W3
	JSB	(NESMOV)	;NEST MOVE
	JMP	(COLSU1)	;$1
COLSU2:
	IER	(LTYEM)		;MAKE THE PNTR LOGICAL ;"21I"
	SMK	(SUBEM)		;IS THIS A SUBEXPRESSION ;"21I"
	JMPF	(COLSU1)	;NO, CONTINUE ITERATION ;"21I"
	SPKT	(OTAEM)		;OR A FUNCTION POINTER ? ;"21I"
	XW0.0F	(FET)		;YES, CHANGE THE FUNCTION PNTR ;"21I"
	IERF	(LTYEM)		;OR OTHER PNTR TO TYPE LOGICAL ;"21I"
	XW1.0F	(STO)		;RESTORE THE FUNCTION PNTR ;"21I"
	JMP	(COLSU1)	;AND CONTINUE ITERATION ;"21I"
IFNDEF	$CCONS,
<

CCOSUB:					;COLLAPSE CONST SUBEXP
	FET	(EOPPNT)
	SME	(DITEM)
	SONF	(DITEM)	;DOUBLE ITEM EM
	SMKF	(DITEM)	;DOUBLE ITEM EM
	SONF	(HTYEM)	;HOLLERITH TYPE EM
	SMKF	(HTYEM)	;HOLLERITH TYPE EM
	XITT	(EFAML)	;EXIT FALSE
	FET	(OPNCLU)	;OP PNTR CLUE
	AND	(DISMAS)	;DISPL MASK
	SGK	(TWEONE)	;TWENTY ONE
	SLKF	(SIXTEE)	;SIXTEEN
	XMLT	(P1EFML)	;PRUNE ONE EXIT FALSE
	SGK	(SEVENT)	;SEVENTEEN
	SUBT	(ONE)		;ONE
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(ITYEM)		;INTEGER TYPE EM
	SMKF	(LTYEM)		;STR524
	POW	(D1)
	EAWT	(D16)		;SIXTEEN
	EAWF	(D12)		;TWELVE
	W1	(SMY)		;W1
	JSBT	(FETCON)	;FETCH CONST
	JSBF	(FACCON)	;FETCH AND CONV CONST
	JSBT	(FETCON)	;FETCH CONST
	JSBF	(FACCON)	;FETCH AND CONV CONST
	XML	(CARML)	;PERFORM AND CHECK CONST ARITHMETIC
	STO	(DAT1)	;DATA 1
	ZER	(DAT2)		;CLEAR LOWER
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(ITYEM)	;INTEGER TYPE EM
	JMPT	(CCOSU1)	;$1
	REG	(RCOFIL)	;REAL CONST FILE
	JMP	(CCOSU2)	;$2
CCOSU1:
	REG	(ICOFIL)	;INTEGER CONST FILE
CCOSU2:
	FET	(CREPNT)	;CRRNT REG PNTR
	SMK	(TCPEM)		;TR1080
	CLAT	(CONPNT)	;-1 <- .TRUE.
	IERT	(MINEM)
	XIT	(ETRML)		;EXIT TRUE
>
IFNDEF	$CCONS,
<
FACCON:					;FETCH AND CONV CONST
	W2	(FET)		;W2
>

FACCFI:					;FETCH AND CONV CONST FIN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMP	(FCOFIN)	;FETCH CONST FIN

IFNDEF	$CCONS,
<
FETCON:					;FETCH CONST
	W2	(FET)		;W2
>

GETCON:					;GET CONSTANT
	SNZ	(ZERO)	;ZERO
FCOFIN:					;FETCH CONST FIN
	XW0.0	(FET)		;ZERO RUNG
CCAASI:					;CONVERT CONST AND ADJUST SIGN
	XMLT	(FINML)	;CONVERT INTEGER TO FL
CSIADJ:					;CONST SIGN ADJUST
	SON	(MINEM)	;MINUS EM
	W1	(ZER)		;W1
	W1T	(SMY)		;W1
	W1F	(AMY)		;W1
	XIT	(EXIML)	;EXIT
ATNAMO:					;ADD TO NEST AND MOVE
	PNG	(NESROL)	;NEST ROLL
	W2	(SWT)		;W2
	FET	(IADPNT)	;INTEGER ADD PNTR
NESMOV:					;NEST MOVE
	SPK	(LOPTRA)	;LOGICAL OP TRAIT
	IERT	(LTYEM)	;LOGICAL TYPE EM
	FETT	(LTYSTA)	;LOGICAL TYPE STAMP
	XMLF	(BTSML)	;BINARY TYPE SELECT
	W1	(FET)		;W1
	ERKF	(M5QT)	;ILLEGAL CONVERSION IMPLIED
	SPT	(ROPTRA)	;REL OP TRAIT
	CLAT	(LTYSTA)	;LOGICAL TYPE STAMP
	W4	(IOM)		;W4
	MON	(NESROL)	;NEST ROLL
	MON	(NESROL)	;NEST ROLL
	MON	(NESROL)	;NEST ROLL
	XIT	(EXIML)	;EXIT

ESACOL:					;EXP SCAN AND COLLAPSE
	JSB	(EXPSCA)
SUBCOL:					;SUBEXP COLLAPSE
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(SCOFIN)	;SUBEXP COLLAPSE FIN
	REL	(NESROL)	;NEST ROLL
	W0	(FET)		;W0
	JMP	(SUSTLY)	;SUBEXP USE TLY
SCOFIN:					;SUBEXP COLLAPSE FIN
	SMK	(NESEM)	;NEST EM
	XITF	(EXIML)	;EXIT
	SMK	(LTYEM)	;LOGICAL TYPE EM
	JMPF	(SCOFI1)	;$1
	XW0.0	(FET)		;OP PNTR RUNG
	SPK	(ROPTRA)	;REL OP TRAIT
	STOT	(EOPPNT)	;EXP OP PNTR
	POWF	(D1)		;ONE
SCOFI1:
	XW0.1	(FET)		;A PART RUNG
	JSB	(SCOFIN)	;SUBEXP COLLAPSE FIN
	XW1.2	(FET)		;B PART RUNG
	JSB	(SCOFIN)	;SUBEXP COLLAPSE FIN
	XW2.0	(FET)		;OP PNTR RUNG
	STK	(EOPPNT)	;SET TO CURRENT TYPE "22D"
	JSB	(SUBREG)	;SUBEXP REGISTER
	FETT	(LTYSTA)	;LOGICAL TYPE STAMP
	STOT	(EOPPNT)	;EXP OP PNTR
	IER	(ETYEM)	;EXP TYPE EM
	XIT	(EXIML)	;EXIT
SUBREG:					;SUBEXP REGISTER
	STO	(OPNCLU)	;OP PNTR CLUE
	STK	(BPACLU)	;B PART CLUE

IFNDEF	$CCONS,
<
	SMK	(CONEM)	;CONST EM
>
	W1	(SWT)		;W1
	STK	(APACLU)	;A PART CLUE
IFNDEF	$CCONS,
<
	SMKT	(CONEM)	;CONST EM
	JSBT	(CCOSUB)	;COLLAPSE CONST SUBEXP
	JMPT	(SUBRE1)	;$1
>
	REG	(SUBFIL)	;SUBEXP FILE
	FET	(SUBPNT)	;SUBEXP PNTR
	FET	(OPNCLU)	;GET THE CURRENT OP CODE
	SMK	(ITYEM)		;IS IT AN INTEGER OPERATION ?
	POWF	(D1)		;NO, PRUNE
	JMPF	(SUBRE1)
	SPT	(COMTRA)	;IS IT COMMUTATIVE ?
	W1T	(FET)		;YES,GET B PART
	JSBT	(SUSTLY)	;ORDER OF USE MAY REQUIRE SAVEING
	SNZT	(ZERO)	;CHANGE FLAG TO PREVENT COLLAPSED CONSTANT EXIT
SUBRE1:
	W3	(SWT)		;W3
	AND	(SANMAS)	;SIGN AND NOT MASK
	W3	(IOM)		;W3
	XMLT	(P2EML)	;PRUNE TWO EXIT
	JSB	(SUSTLY)	;SUBEXP USE TLY
SUSTLY:					;SUBEXP USE TLY
	SMK	(SUBEM)	;SUBEXP EM
	XW0.4T	(TLY)		;USE CNT RUNG
	XML	(P1EML)	;PRUNE ONE EXIT
ELESCA:					;ELEMENT SCAN
	CSA	(MINUS)	;MINUS
	JSBT	(PELSCA)	;POSITIVE ELEM SCAN
	EORT	(MINMAS)	;MINUS MASK
	XITT	(EXIML)	;EXIT
	CSA	(PLUS)	;PLUS
PELSCA:					;POSITIVE ELEM SCAN
	CSA	(LPAREN)	;L PAREN
	JMPF	(OELSCA)	;OPEN ELEM SCAN
	FET	(OPCPNT)	;OP PNTR
	JSB	(EXPSCA)	;EXP SCAN
	W1	(SWT)		;W1
	STO	(OPCPNT)	;OP PNTR
	SMK	(CCRPEM)	;COMPLEX CONST REAL PART EM
	SCET	(COMMA)	;COMMA
	CSFF	(RPAREN)	;R PAREN
	XITF	(EXIML)	;EXIT
	XW0.0	(FET)		;ZERO RUNG
	STO	(DAT1)	;DATA 1
	JSB	(CCSFIN)	;COMPLEX CONST SCAN FIN
	JMP	(RCOCON)	;REGISTER COMPLEX CONST
OELSCA:					;OPEN ELEM SCAN
	SCK	(LETKEY)	;LETTER KEY
	JMPF	(CONSCA)	;CONST SCAN
	JSB	(IDSCAN)	;ID SCAN
	JMPF	(OELSC1)	;$1
	CSA	(LPAREN)	;L PAREN
	JMPT	(AELSCA)	;APPENDED ELEM SCAN
	SMK	(LSPEM)	;LOCAL SPROG EM
	CCFT	(S15QT)	;SYNTAX QT
	SMK	(ARREM)	;ARRAY ID EM
	SMKF	(GSPEM)	;GLOBAL SPROG EM
	JMPF	(FEREXI)	;$2
	SNZ	(FELFLA)	;FIRST ELEM FLAG
	SNZT	(SARFLA)	;SPROG ARG FLAG
	JMPF	(SFAW0)	;SYNTAX FAIL W0
	ISE	(GDMFIL)	;GLOBAL DUMMY FILE
	IERT	(DMYEM)	;DUMMY EM
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT

OELSC1:
	CSA	(LPAREN)	;L PAREN
	JMPF	(REGSCA)	;REGISTER SCALAR
	ISET	(CNAFIL)	;COMMON BLOCK NAME ?
	LCFT	(I10QT)	;YES, SPROG NAME ALREADY IN USE ERR MSG
	JSB	(RGLSPR)	;REGISTER GLOBAL SPROG
	JMP	(SASXLA)	;SPROG ARG SEQ XLATE
AELSCA:					;APPENDED ELEM SCAN
	SMK	(LDMEM)	;LOCAL DMY EM
	LCFT	(I13QT)	;ID CONFLICT QT ;"21J"
			;LINE DELETED ;"21J"
	SMK	(ARREM)	;ARRAY ID EM
	JMPT	(AREXLA)	;ARRAY REF XLATE
	SMK	(SCAEM)	;SCALAR FOLLOWED BY LPAREN ?
	LCFT	(I10QT)	;SUB NAME ALREADY IN USE ;"21J"
			;LINE DELETED ;"21J"
SASXLA:					;SPROG ARG SEQ XLATE
	FET	(OPCPNT)	;"23AG"
	W1	(SWT)		;"23AG"
	ISE	(LFUFIL)	;LIB FUNC FILE
	FETF	(ZERO)		;"23AG"
	JMPF	(SASXL3)	;"23AG"
	XML	(ITSML)		;RE-TYPE LIB FUNCT ;"23AG"
	XNI	(CREPNT)	;"23AG"
	FET	(ONERUN)	;"23AG"
SASXL3:				;"23AG"
	W1	(SWT)		;"23AG"
	JSB	(TYPEVA)	;RE TYPE IF EXPLICIT - "20B"
	W1T	(ZER)		;"23AG"
				;2 LINES DELETED ;"23AG"
	RSV	(APNROL)	;ARG PNTR ROLL
SASXL1:
	RSV	(NESROL)	;NEST ROLL
	NOZ	(SARFLA)	;SPROG ARG FLAG
	CSA	(DOLLAR)	;$? "22A"
	CSAF	(AMPSND)	;&? "23G"
	CSAF	(ASTERI)	;*? "22A"
	JSBT	(LBLSCA)	;FIND A LABEL "22A"
	JSBF	(AEXSCA)	;ARG EXP SCAN "22A"
	JSBF	(SUBCOL)	;COLLAPSE SUBEXP "22A"
	SMK	(SCAEM)	;SCALAR ?
	SMKF	(ARREM)	;OR ARRAY NAME ?
	JMPF	(SASXL2)	;NO, SKIP THE EXTRA CHECKS
	XW0.0	(FET)		;YES,GET THE NAME
	STO	(SYMBOL)	;STORE IT FOR SEARCH
	ISE	(GDMFIL)	;GLOBAL DUMMY ?
	REGT	(DEFFIL)	;YES, REGISTER AS DEFINED
SASXL2:	W2	(SNZ)		;"23GG"
	JMPF	(SASXL4)	;"23GG"
	W2	(FET)		;"23AG"
	SMK	(LTYEM)		;"24-6"
	JMPT	(SASXL6)	;"24-6"
	STK	(LFUATO)	;"23AG" -"24-6"
	SON	(LFUTEM)	;"23GG" - "24-6"
	CCFF	(I8QT)		;"23GG"
SASXL6:			;"24-6"
	POW	(D1)		;"24-6"
SASXL4:				;"23GG"
	MON	(APNROL)	;ARG PNTR ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(SASXL1)	;$1
	CSF	(RPAREN)	;R PAREN
	W1	(SWT)		;"23AG"
	W0	(SNZ)		;"23GG"
	JMPF	(SASXL5)	;"23GG"
	AND	(RHAMAS)	;"23GG"
	CNT	(APNROL)	;"23GG"
	W1	(SLT)		;"23GG"
	CCFT	(I9QT)		;"23GG"
SASXL5:				;"23GG"
	POW	(D1)		;"23GG"
	STK	(FRNCLU)	;FUNC REF NAME CLUE
	EAW	(APNROL)	;ARG PNTR ROLL
	RPL	(APLROL)	;ARG PLEX ROLL
	REL	(APNROL)
	STO	(FRAPCL)	;FUNC REF ARG PLEX CLUE
	ZER	(BPACLU)	;B PART CLUE
	REG	(FREFIL)	;FUNC REF FILE
	AND	(TYPMAS)	;TYPE MASK
	IOM	(FREPNT)	;FUNC REF PNTR
	STO	(OPCPNT)	;OP PNTR
	ZER	(SARFLA)	;SPROG ARG FLAG
	NOZ	(JOUFLA)	;JUMP OUT FLAG (DO LOOP)
	FET	(FREPNT)	;FUNC REF PNTR
	IER	(FREEM)	;FUNC REF EM
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT
AREXLA:					;ARRAY REF XLATE
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	IERT	(DMYEM)	;DMY EM
	XW0.3	(FET)		;MULT PLEX PNTR RUNG
	RSV	(NESROL)	;NEST ROLL
	RSV	(APNROL)	;ARG PNTR ROLL
	CFP	(APNROL)	;ARG PNTR ROLL
	FET	(OPCPNT)	;OP PNTR
	FET	(ZERO)	;ZERO
	FET	(ZERO)	;ZERO
AREXL1:
	MOA	(APNROL)	;ARG PNTR ROLL
	CCFF	(M1QT)	;TOO MANY SCRIPTS QT
	JSB	(EXPSCA)	;EXP SCAN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPT	(AREXL8)
	IOR	(ABCCMA)	;ISOLATE CARD-COLUMN
	SEK	(ABCCMA)	;CARD-COLUMN POINTER PRESENT?
	CCFT	(M13QT)	;YES, FAIL
	ERM	(M13QT)	;NO, FAIL
	JMP	(SUBFAI)	;SUBEXP FAIL
AREXL8:
	SMK	(ICOEM)	;INTEGER CONST EM
	SONT	(CMUEM)	;CONST MULTIPLIER EM
	JMPF	(AREXL2)	;$2
	JSB	(GETCON)	;GET CONSTANT
	W1	(MMY)		;W1
	W2	(AMY)		;W2
	JMP	(AREXL3)	;$3
AREXL2:
	W1	(SWT)		;W1
	SMK	(CMUEM)	;CONST. MULTIPLIER EM
	SONT	(NESEM)	;NEST EM
	XW1.0T	(FET)		;ZERO RUNG
	SPTT	(ADDTRA)	;ADDITIVE TRAIT
	JMPF	(AREXL9)	;$9
	SON	(MINEM)	;MINUS EM
	XW1.2	(FET)		;B PART RUNG
	EORT	(MINMAS)	;MINUS MASK
	SMK	(ICOEM)	;INTEGER CONST EM
	POWF	(D1)		;ONE
	JMPF	(AREXL9)	;$9
	JSB	(GETCON)	;GET CONSTANT
	W1	(MPY)		;W1
	W4	(AMY)		;W4
	SON	(MINEM)	;MINUS EM
	XW1.1	(FET)		;A PART RUNG
	EORT	(MINMAS)	;MINUS MASK
	W2	(STO)		;W2
AREXL9:
	SEK	(ONE)		;ONE
	POWT	(D1)		;ONE
	JMPT	(AREXL7)	;$7
	SMK	(CMUEM)	;CONST MULTIPLIER EM
	JSBT	(RWOCON)	;REG WORK CONST
	PNG	(NESROL)	;NEST ROLL
	W2	(SWT)		;W2
	FET	(INPPNT)	;INTEGER MPY PNTR
	JSB	(NESMOV)	;NEST MOVE
AREXL7:
	W1	(SNZ)		;W1
	JSBT	(ATNAMO)	;ADD TO NEST AND MOVE
	W1F	(STO)		;W1
AREXL3:
	CSA	(COMMA)	;COMMA
	JMPT	(AREXL1)	;$1
	CSF	(RPAREN)	;R PAREN
	SRD	(APNROL)	;ARG PNTR ROLL
	LCFT	(M2QT)	;TOO FEW SCRIPTS QT
	W3	(FET)		;W3
	SME	(DITEM)	;DOUBLE ITEM EM
	W0T	(SNZ)		;W0
	PNGT	(NESROL)	;NEST ROLL
	W1T	(SWT)		;W1
	FETT	(CTWPNT)	;CONST TWO PNTR
	FETT	(INPPNT)	;INTEGER MPY PNTR
	JSBT	(NESMOV)	;NEST MOVE
	W3	(FET)		;W3
	SMK	(DMYEM)	;DMY EM
	POWF	(D1)		;ONE
	JMPF	(AREXL4)	;$4
	IER	(ITYEM)	;INTEGER TYPE EM
	W1	(SNZ)		;W1
	W1F	(STO)		;W1
	JSBT	(ATNAMO)	;ADD TO NEST AND MOVE
	W3	(XNI)		;W3
	SNZ	(ASIRUN)	;ARRAY SIZE RUNG
	JMPT	(AREXL4)	;$8
	W3	(XNI)		;W3
	FET	(OFFRUN)	;OFFSET RUNG
	IER	(MINEM)	;MINUS EM
	JSB	(ATNAMO)	;ADD TO NEST AND MOVE
	JSB	(SUBCOL)	;SUBEXP COLLAPSE
	STO	(SEXCLU)	;SCRIPT EXP CLUE
	JMP	(AREXL6)	;$6
AREXL4:
	SEK	(ZERO)	;ZERO
	RELT	(NESROL)	;NEST ROLL
	JMPT	(AREXL5)	;$5
	SMK	(NESEM)	;NEST EM
	JSBF	(AIVCHE)	;ACTIVE INDUC VAR CHECK
	FETF	(ZERO)	;ZERO
	JSBF	(ATNAMO)	;ADD TO NEST AND MOVE
	JSB	(SUBCOL)	;SUBEXP COLLAPSE
AREXL5:
	STO	(SEXCLU)	;SCRIPT EXP CLUE
	W2	(XNI)		;W2
	SUB	(OFFRUN)	;OFFSET RUNG
AREXL6:
	W2	(FET)		;W2
	SME	(DITEM)	;DOUBLE ITEM EM
	W0T	(ADD)		;W0
	ZER	(AROCLU)	;ARRAY REF OFFSET CLUE
	SMY	(AROCLU)	;ARRAY REF OFFSET CLUE
	STO	(OPCPNT)	;OP PNTR
	W0	(FET)		;W0
	AND	(ABCCMA)	;ALL BUT CHAR CNT MASK
	STO	(ARNCLU)	;ARRAY REF NAME CLUE
	REG	(AREFIL)	;ARRAY REF FILE
	AND	(LHAMAS)	;LEFT HALF MASK
	IOR	(AREPNT)	;ARRAY REF PNTR
	REL	(APNROL)	;ARG PNTR ROLL
FEREXI:					;FIRST ELEM RESET EXIT
	ZER	(FELFLA)	;FIRST ELEM FLAG
	XIT	(EXIML)	;EXIT

CLOIDE:					;COLLAPSE LOGICAL IDEMPOT
	SON	(CONEM)	;SECOND ITEM A CONSTANT?
	W1F	(SWT)		;NO, SWITCH
	SONF	(CONEM)	;TEST THE OTHER
	XITF	(EFAML)	;NEITHER A CONSTANT, EXIT FALSE
	SON	(NOTEM)	;SAVE .NOT. BIT
	XW1.0	(FET)		;FETCH ACTUAL VALUE
	W0T	(NOT)		;COMPLEMENT IF BIT SET
	SEK	(ZERO)	;IF RESULT IS NOT ZERO
	SEKF	(MINONE)	;OR MINUS ONE,
	XITF	(P1EFML)	;NOT A SPECIAL CASE, EXIT FALSE
	W3	(FET)		;FETCH OP POINTER
	SPT	(TIDTRA)	;TEST TRUE ID TRAIT (SET FOR .AND. & .EQV.)
	W0T	(NOT)		;COMPLEMENT IF SET
	SEQ	(ZERO)	;TEST RESULTANT FOR ZERO
	W2T	(STO)		;YES,.AND.(T),.OR.(F),.XOR.(F),OR .EQV.(T)
	XITT	(P1ETML)	;THE OTHER VALUE IS THE RESULT
	W2	(FET)		;NO, GET OP POINTER
	SPT	(UCOTRA)	;TEST USE COMP. TRAIT (SET FOR .XOR. & .EQV.)
	POWF	(D1)		;NO, .AND. (F) OR .OR. (T),
	W1F	(STO)		;RESULT IS F OR T, RESPECITIVELY
	XITF	(ETRML)	;RETURN TRUE, TWO ITEMS PRUNED
	EOR	(NOTMAS)	;.XOR.(T) OR .EQV.(F)
	W2	(STO)		;RESULTANT IS COMPLEMENT OF OTHER VALUE
	XIT	(P1ETML)	;EXIT TRUE
ACCAGE:					;ASSIGNMENT CONV CHECK AND GEN
	SMK	(LTYEM)	;LOGICAL TYPE EM
	XITT	(EFAML)		;EXIT FALSE
	SON	(DITEM)	;DOUBLE ITEM EM
	JMPT	(ACCAG1)	;$1
	SON	(RTYEM)		;"23Y"
	SONF	(LTYEM)		;"23Y"
	SONF	(OCTEM)		;"23Y"
	SMKT	(DITEM)		;DOUBLE ITEM EM ;"23Y"
				;LINE DELETED ;"23Y"
	JMPT	(ACCAG2)	;"22H"
	JSB	(CCAGEN)	;CONV CHECK AND GEN
	SMK	(CTYEM)		;COMPLEX DEST "22H"
ACCAG2:			;"22H"
	IERT	(ITYEM)		;SET TO SINGLE "22H"
	XIT	(EXEQML)	;EXIT EQUAL ML
ACCAG1:
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSBF	(CCAGEN)	;CONV CHECK AND GEN
	XITF	(EFAML)		;EXIT FALSE
	STK	(EOPPNT)	;EXP OP PNTR
	SON	(ETYEM)	;EXP TYPE EM
	XITT	(EFAML)		;YES EXIT FALSE "22H"
	IER	(ITYEM)		;NO SET TO SINGLE "22H"
	XML	(ETRML)		;EXIT TRUE "22H"
CCAGEN:					;CONV CHECK AND GEN
	SMK	(RTYEM)	;REAL TYPE EM
	SMKF	(DITEM)	;DOUBLE ITEM EM
	JMPT	(CCAGE1)	;$1
	SON	(RTYEM)	;REAL TYPE EM
	SONF	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	W1	(FET)		;W1
	JSB	(CTFGEN)	;CONV TO FX GEN
	JMP	(CCAGE2)	;$2
CCAGE1:
	SON	(ITYEM)	;INTEGER TYPE EM
	JMPF	(CCAGE3)	;GEN CALL TO SNGL
	W1	(FET)		;W1
				;LINE REPLACED HERE "20A"
	JSB	(CPNGE4)	;CHECK FOR ARRAY AND FLOAT "20A"
CCAGE2:
	W2	(STO)		;W2
	XIT	(EXIML)	;EXIT

CCAGE3:
	SON	(DPTEM)	;IS RESULT D.P.
	SMKT	(RTYEM)	;AND DESTINATION REAL ?
	XITF	(EXIML)	;NO, RETURN
			;LINE DELETED HERE "20A"
	W1	(FET)		;YES, GET RESULT POINTER
IFNDEF HARDFL,<							; *EJG* 06/23/76
				;10 LINES DELETED ;"23BB"
	JSB	(GIRGEN)	;"23BB"
	W0	(FET)		;"23BB"
	W0	(TLY)		;"23BB"
	BIN	(.FAR0)		;"23BB"
>								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	SMK	(RZEEM)	;REG ZERO EM				; *EJG* 06/23/76
	FETT	(RZEPNT);REG ZERO PNTR				; *EJG* 06/23/76
	JSBF	(GR0AGE);GRNTEE REG 0 AVAIL GEN			; *EJG* 06/23/76
	SON	(MINEM)	;MINUS EM				; *EJG* 06/23/76
	IERT	(MINEM)	;SET MINUS FOR ASSIGNMENT		; *EJG* 06/23/76
	IER	(RTYEM)	;MAKE SURE REG 0 IS REAL		; *EJG* 06/23/76
	W1	(SWT)						; *EJG* 06/23/76
	SMK	(RZEEM)	;REG ZERO ?				; *EJG* 06/23/76
	JSBT	(SITGEN)					; *EJG* 06/23/76
	JSB	(AIVREP)					; *EJG* 06/23/76
	SMK	(AREEM)						; *EJG* 06/23/76
	JSBT	(GIRGEN)					; *EJG* 06/23/76
	BLK	(.SNGL)						; *EJG* 06/23/76
	BAI	(.ARG0)						; *EJG* 06/23/76
>								; *EJG* 06/23/76
	IER	(RTYEM)	;MAKE RESULT TYPE REAL - "20A"
	STK	(EOPPNT)	;SET EXP TYPE TO REAL "22D"
				;LINE DELETED ;"23BB"
	JMP	(CCAGE2)	;CHANGE DESTINATION POINTER
EIRGAS:					;EXP IN REG GEN AND SAVE
	W0	(FET)		;W0
	XW0.4	(TLY)		;USE CNT RUNG
	JSB	(GENRUN)	;GEN RUN
	JSB	(GPRGEN)	;GRNTEE POS REG GEN
	XML	(P1EML)	;PRUNE ONE EXIT
EIERGE:					;EXP IN EVEN REG GEN
	JSB	(GENRUN)	;GEN RUN
	SMK	(REGEM)	;REG EM
	SMKT	(EREEM)	;EVEN REG EM
	JMPT	(GPRGEN)	;GRNTEE POS REG GEN
	FET	(DPTSTA)	;DBL PREC TYPE STAMP
	SWT	(EOPPNT)	;EXP OP PNTR
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
	W1	(SWT)		;W1
	STO	(EOPPNT)	;EXP OP PNTR
	IER	(ETYEM)	;EXP TYPE EM
	JMP	(RLOGEN)	;REG LOAD GEN
EIR0GE:					;EXP IN REG 0 GEN
	SMK	(RZEEM)	;REG ZERO EM
	JMPT	(GPRGEN)	;GRNTEE POS REG GEN
	JSB	(GR0AGE)	;GRNTEE REG 0 AVAILABLE GEN
	XW0.0	(ZER)		;ZERO RUNG
	POW	(D1)		;ONE
	SMK	(SUBEM)		;SUBEXPRESSION? "22M"
	JMPF	(EIR0G1)	;BYPASS EIRGEN "22M"
				;LINE DELETED "22M"
	JSB	(EIRGEN)	;EXP IN REG GEN
				;2 LINES DELETED "22M"
	SMK	(RZEEM)		;DID IT MAKE IT INTO AC0?
EIR0G1:			;"22M"
	W0F	(FET)		;NO, PUT IT THERE
	ANDF	(LHAMAS)	;TRANSFER THE INFO
	IORF	(RZEPNT)	;POINT TO REG 0
	W1F	(SWT)		;EXCHANGE
	BTYF	(.ME0)	;MOVE INTO AC0
GPRGEN:					;GRNTEE POS REG GEN
	SMK	(MINEM)	;MINUS EM
	XITF	(EXIML)	;EXIT
	JMP	(CSIGEN)	;CHANGE SIGN GEN
SUBGEN:					;SUBEXP GEN
	XW0.4	(DIM)		;USE CNT RUNG
	XW0.3	(FET)		;STATUS PNTR RUNG
	SMK	(IIVEM)	;INDUCTION VARIABLE ACTIVE ?
	XW0.0T	(ZER)		;YES,CLEAR REGROL
	CLAT	(ZERO)	;GENERATE FRESH EXPRESSION
	SEK	(ZERO)	;ZERO
	STKF	(EOPPNT)	;EXP OP PNTR
	JMPF	(SNOEXI)	;SIGN NOTE EXIT
	SON	(FREEM)	;FUNC REF EM
	POWT	(D1)		;ONE
	JSBT	(FRPGEN)	;FUNC REF PNTR GEN
	JMPT	(SUGEFI)	;SUBEXP GEN FIN
	XW1.1	(CLA)		;A PART RUNG
	XW1.2	(FET)		;B PART RUNG
	XW2.0	(FET)		;OP PNTR RUNG
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(OGERUN)	;OP GEN RUN
SUGEFI:					;SUBEXP GEN FIN
	SMK	(REGEM)	;REG EM
	JMPF	(SNOEXI)	;SIGN NOTE EXIT
	STK	(RSIATO)	;RESULTANT SIGN ATOM
	SNZ	(IOLFLA)	;INSIDE AN I/O LIST ?
	SNZT	(REGSAV)	;AND THE DO REG IS IN USE ?
	IERT	(IIVEM)	;YES,PASS THIS INFO THRU THE EXP
	XW1.3	(STK)		;NO,UPDATE THE STATUS PNTR RUNG
	W1	(FET)		;W1
	XW0.0	(FET)		;GET CURRENT EXP TYPE "22D"
	STO	(EOPPNT)	;SET EXP TYPE "22D"
	IER	(ETYEM)	;EXP TYPE EM
	XW1.0	(STO)		;ZERO RUNG
	IPK	(RSITRA)	;RESULTANT SIGN TRAIT
SNOEXI:					;SIGN NOTE EXIT
	W1	(SWT)		;W1
	AND	(SANMAS)	;SIGN AND NOT MASK
	W1	(EOM)		;W1
	XIT	(EXIML)	;EXIT
EQVGEN:					;EQV GEN
	FET	(NOTMAS)	;NOT MASK
	W3	(EOM)		;W3
XORGEN:					;XOR GEN
	JSB	(RFBGEN)
	JSB	(MINTST)	;"23U"CHECK FOR MINUS
	EAW	(.XOR0)	;SIXTEEN
	JMP	(LOPGEN)	;LOGICAL OP GEN
ANDGEN:					;AND GEN
	JSB	(RFBGEN)
	JSB	(MINTST)	;"23U" CHECK FOR MINUS
	EAW	(.AN0)	;EIGHT
	JMP	(LOPGEN)	;LOGICAL OP GEN
ORGEN:					;OR GEN
	JSB	(RFBGEN)
	JSB	(MINTST)	;"23U" CHECK FOR MINUS
	EAW	(.OR0)	;ZERO
LOPGEN:					;LOGICAL OP GEN
	W3	(FET)		;W3
	SMK	(NOTEM)	;NOT EM
	AND	(NOTMAS)	;NOT MASK
	W4	(EOM)		;W4
	ADDAT	(D4)		;FOUR
	W2	(FET)		;W2
	SMK	(NOTEM)	;NOT EM
	AND	(NOTMAS)	;NOT MASK
	W3	(EOM)		;W3
	ADDAT	(D2)		;TWO
	SON	(NOTEM)	;NOT EM
	ADDAT	(D1)		;ONE
	XML	(BIKIML)
	JMP	(RREEXI)	;REG RESET EXIT
MINTST:				;"23U"
	W1	(SWT)		;"23U"
	JSB	(MINTS1)	;"23U" NOW CHECK
	W1	(SWT)		;"23U"
MINTS1:				;"23U"
	SMK	(MINEM)		;"23U" MINUS?
	XITF	(EXIML)		;"23U"
	SMK	(REGEM)		;"23U" REGISTER POINTER?
	JSBT	(CSIGEN)	;"23U" YES CHANGE SIGN
	JSBF	(GIRGEN)	;"23U" NO CHANGE SIGN ANYWAY
	XIT	(EXIML)		;"23U"
GTLTGE:					;GT LT GEN
	EAW	(D0)		;ZERO
	JMP	(RGECHE)	;REL GEN CHECK
GELEGE:					;GE LE GEN
	EAW	(D6)		;SIX
RGECHE:					;REL GEN CHECK
	W2	(SWT)		;W2
	SMK	(CTYEM)	;COMPLEX TYPE EM
	SONF	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(RELGEN)	;REL GEN
	FET	(EOPPNT)	;GET OP PNT	"20C"
	ERM	(M14QT)		;ERROR
	W3	(FET)		;W3
	JMP	(SUBFAI)	;SUBEXP FAIL
EQNEGE:					;EQ NE GEN
	EAW	(D3)		;THREE
	W2	(SWT)		;W2
RELGEN:					;REL GEN
	FET	(EOPPNT)	;EXP OP PNTR
	SPT	(NOPTRA)	;NOT OP TRAIT
	W2T	(TLY)
	EAW	(D0)		;ZERO
	W2	(SWT)		;W2
	SON	(CZPEM)	;CONST ZERO PNTR EM
	SONF	(FZPEM)	;FLOATING ZERO PNTR EM
	W2T	(NOT)		;W2
	JMPT	(RELGE3)	;$3
	SMK	(CZPEM)	;CONST ZERO PNTR EM
	SMKF	(FZPEM)	;FLOATING ZERO PNTR EM
	W1T	(SWT)		;W1
RELGE3:
	JSBT	(EIRGEN)	;EXP IN REG GEN
	JSBF	(RFBGFI)	;READY FOR BINARY GEN FIN
	W1F	(SWT)		;W1
	SON	(PLUEM)	;PLUS EM
	W2F	(NOT)		;W2
	SON	(NOTEM)	;NOT EM
	EAWT	(D7)		;SEVEN
	W4T	(EOM)		;W4
	STK	(RSIATO)	;RESULTANT SIGN ATOM
	SON	(RSIEM)	;RESULTANT SIGN EM
	JSBF	(CSIGEN)	;CHANGE SIGN GEN
	W4	(FET)		;W4
	SMK	(NOTEM)	;NOT EM
	EAWT	(D7)		;SEVEN
	W5T	(EOM)		;W5
	AND	(NOTMAS)	;NOT MASK
	W5	(EOM)		;W5
	W2	(SNZ)		;W2
	EAWT	(D1)		;ONE
	W4T	(EOM)		;W4
	W1	(SWT)		;W1
	SON	(CTYEM)	;COMPLEX TYPE EM
	EAW	(D0)		;ZERO
	XITT	(EXIML)	;EXIT
	SON	(CZPEM)	;CONST ZERO PNTR EM
	SONF	(FZPEM)	;FLOATING ZERO PNTR EM
	CLAT	(SEVEN)	;SEVEN
	XIT	(EXIML)	;EXIT
RELGE8:
	SEQ	(ZERO)	;ZERO
RELGE5:
	W3F	(FET)		;W3
	JMPF	(RELGE1)	;$1
RELGE9:
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	JMPF	(RELGE5)	;$5
	SMK	(AREEM)		;ARRAY ? ;"21K"
	XW0.2T	(FET)		;INDICATE EXTRA USE OF SUBSCRIPT ;"21K"
	JSBT	(SUSTLY)	;BY INCREMENTING USE COUNT ;"21K"
	BIK	(.CMN0)	;CAMN INST
	FET	(SEVEN)	;SEVEN
	W4	(EOM)		;W4
	W3	(FET)		;W3
	SEK	(FOUR)	;FOUR
	SEKF	(FIVE)	;FIVE
	SUBT	(TWO)		;TWO
	JSB	(BRESKI)	;BUILD REL EQ SKIPS
	XITT	(EXIML)	;EXIT
	W3	(FET)		;W3
	SEK	(TWO)		;TWO
	SEKF	(THREE)	;THREE
	POCT	(ABSINS)	;ABS INST
	POCT	(.SKA0)	;SKIPA INST
	XMLT	(P1EML)	;PRUNE ONE EXIT
	EOR	(ONE)		;ONE
	IOR	(SIX)		;SIX
RELGE1:
	ADDA	(.CMG0)	;CAMG INST ADR
	W3	(STK)		;W3
	XML	(BIKIML)
	XIT	(EXIML)	;EXIT
RGFNLI:					;REL GEN FOR NOT LOG IF
	FET	(EOPPNT)	;EXP OP PNTR
	JSB	(RELDIS)	;RELATIONAL OP DISPATCH
	JSB	(RELGE8)	;REL GEN $8
	W1	(SWT)		;W1
	W0	(FET)		;W0
	BIN	(.TDZA0)	;TDZA INST
	BRI	(.SEO0)	;SETO INST
	IER	(PLOEM)	;POSITIVE LOGICAL EM
	STK	(EOPPNT)	;EXP OP PNTR
	W3	(STO)		;W3
	W1	(STO)		;W1
	JMP	(RREEXI)	;REG RESET EXIT
BRESKI:					;BUILD REL EQ SKIPS
	ADDA	(.CMG0)	;CAMG INST ADR
	SON	(DITEM)	;DOUBLE ITEM
	JMPT	(BSHREF)	;BUILD SECOND HALF REF
	W2	(FET)		;W2
	W0	(TLY)		;W0
	FET	(CZEPNT)	;CONST ZERO PNTR
	W2	(FET)		;W2
	XML	(BINIML)
	XML	(P2EML)	;PRUNE TWO EXIT
ICLGEN:					;IF CLOSE GEN
	SNZ	(ISAFLA)	;IF STA ACTIVE FLAG
	JSBT	(ICGFIN)	;IF CLOSE GEN FIN
	FET	(SLBPNT)	;STA LBL PNTR
	SEK	(ZERO)	;ZERO
	JSBF	(LGAKEE)	;LBL GEN AND KEEP
	XML	(P1ETML)	;PRUNE ONE EXIT TRUE

DISTES:					;DOUBLE IF STA TEST
	SNZ	(ISAFLA)	;IF STA ACTIVE FLAG
	XITF	(EXIML)
	ZER	(ISAFLA)	;IF STA ACTIVE FLAG
ICGFIN:					;IF CLOSE GEN FIN
	W2	(SEK)		;W2
	JMPF	(GLECHE)	;GE LE CHECK
	POW	(D1)		;ONE
	W1	(SEK)		;W1
	POWT	(D1)		;ONE
	JMPT	(AJUGEN)	;ABS JUMP GEN
	FET	(THREE)	;THREE
FTHGEN:					;FALL THROUGH GEN
	STO	(TEMP)	;TEMP
	SMK	(SLPEM)	;STA LBL PNTR EM
	W2F	(FET)		;W2
	W1F	(SWT)		;W1
	CLAT	(SEVEN)	;SEVEN
	EOMT	(TEMP)	;TEMP
	EAW	(.JUG0)	;JUMPG INST
	ADD	(TEMP)	;TEMP
	XML	(BINIML)
	POW	(D1)		;ONE
	XITT	(EXIML)	;EXIT
AJUGEN:					;ABS JUMP GEN
	SMK	(SLPEM)	;STA LBL PNTR EM
	BAKF	(.JRST0)	;JRST INST
	XML	(P2EML)	;PRUNE TWO EXIT
GLECHE:					;GE LE CHECK
	W1	(SEK)		;W1
	CLAT	(SIX)		;SIX
	JMPT	(FTHGEN)	;FALL THROUGH GEN
	W2	(SWT)		;W2
	W1	(SEK)		;W1
	CLAT	(SEVEN)	;SEVEN
	JMPT	(FTHGEN)	;FALL THROUGH GEN
	W3	(FET)		;W3
	ZER	(HITCNT)	;HITS CNTR
	W1	(SWT)		;W1
	SMK	(SLPEM)	;STA LBL PNTR EM
	BIKF	(.JUL0)	;JUMPL INST
	TLYT	(HITCNT)	;HITS CNTR
	POW	(D1)		;ONE
	W1	(SWT)		;W1
	SMK	(SLPEM)	;STA LBL PNTR EM
	BIKF	(.JUE0)	;JUMPE INST
	TLYT	(HITCNT)	;HITS CNTR
	POW	(D2)		;TWO
	SNZ	(HITCNT)	;HITS CNTR
	JMPF	(AJUGEN)	;ABS JUMP GEN
	BIN	(.JUG0)	;JUMPG INST
	XML	(P1EML)	;PRUNE ONE EXIT
CSIGEN:					;CHANGE SIGN GEN
	SPK	(SUBEM)	;SUBEXP EM
	XW0.0T	(FET)		;ZERO RUNG
	FETT	(SIGMAS)
	XW1.3T	(EOM)
	EORT	(SIGMAS)	;SIGN MASK
	XW1.0T	(STO)
	EOR	(SIGMAS)	;SIGN MASK
	W0	(FET)		;W0
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	BTYF	(.MN0)	;MOVN INST
	XITF	(EXIML)	;EXIT
CSIGE1:			;"21V" CALLED FROM AOAXLA
	SNZ	(PDPSW)	;TEST MACHINE TYPE
IFNDEF HARDFL,<							; *EJG* 06/23/76
	W0T	(TLY)
	BINT	(.DFN0)	;DFN INST
>								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	BINT	(.DMVN0)	;DMOVN INST			; *EJG* 06/23/76
>								; *EJG* 06/23/76
	XITT	(EXIML)	;EXIT
	W1	(TLY)		;W1
	BRI	(.SEA0)	;SETCA INST
	W1	(SWT)		;W1
	W0	(FET)		;W0
	BIN	(.MN0)	;MOVN INST
	FET	(ABSCPN)	;ALL BUT SIGN CONST PNTR
	BIN	(.TDNN0)	;TDNN INST
	CLA	(CONPNT)	;CONST ONE PNTR
	BIN	(.ADD0)
	XIT	(EXIML)
DCLGEN:					;DO CLOSE GEN
DCLGE1:
	MOA	(DLOROL)	;LABEL OF DO CLOSE
	XITF	(EXIML)	;EXIT
	SMK	(SLPEM)	;STA LBL EM
	MONF	(DLOROL)	;DO LOOPS OPEN ROLL
	XITF	(EXIML)	;EXIT
	POW	(D1)		;PRUNE LABEL OF DO CLOSE
	JSB	(LCLGEN)	;LOOP CLOSE GEN
	JMP	(DCLGE1)	;$1
LCLGEN:					;LOOP CLOSE GEN
	SNZ	(JSTFLA)	;JUMP STA FLAG
	EAWT	(C6PNTR)	;COL 6 PNTR
	W0T	(SWH)
	ERMT	(M10QT)	;ILLEGAL DO CLOSE QT
	ZER	(IOLFLA)	;IOL FLAG
LCGFIN:					;LOOP CLOSE GEN FIN
	ZER	(EOPPNT)	;EXP OP PNTR
	MOA	(DLOROL)	;JOUFLA
	MOA	(DLOROL)	;INDEX VAR PNTR
	JSB	(AIVCHE)	;INDEX STILL IN REG 15 ?
	BAKF	(.ME1)	;NO, BIN MOVE DO REG INST
	NOZF	(IOLFLA)	;NO, SET IOL FLAG
	MOA	(DLOROL)	;LABEL TO RETURN TO
	SNZ	(JOUFLA)	;JUMP OUT FLAG SET ?
	SNZF	(IOLFLA)	;NO, IOL FLAG SET ?
	W0T	(DIM)		;YES, POINT TO CODE TO UPDATE INDEX VAR
	MOA	(DLOROL)	;FINAL VALUE EXP PNTR
	MOA	(DLOROL)	;INCREMENT EXP PNTR
	RSV	(SUBROL)	;SUBEXP ROLL
	EAW	(SUBROL)	;SUBEXP ROLL
	CAR	(DLOROL)	;INCREMENT & FINAL SUBEXP SAVED
	SMK	(CONEM)	;CONST PNTR EM
	JMPT	(CILCGE)	;CONST INCR LOOP CLOSE GEN
	W0	(FET)		;MAKE TEMPORARY COPY OF INCREMENT
	SMK	(AREEM)		;AN ARRAY ? ;"21L"
	XW0.2T	(CLA)		;YES, THEN SAVE THE SUBSCRIPT ;"21L"
	JSB	(SUSTLY)	;SAVE INCREMENT FOR SIGN TEST
	JSB	(GENRUN)	;GEN RUN
	FET	(DREPNT)	;DO REG PNTR
	W1	(FET)		;W1
	JSB	(AGEFIN)	;ADD GEN FIN
	W2	(FET)		;W2
	JSB	(EIRGEN)	;EXP IN REG GEN
	SMK	(MINEM)	;MINUS EM
	BIKT	(.ADDM0)	;ADDM INST
	BIKF	(.SUBM0)	;SUBM INST
	W2	(SWT)		;W2
	SMK	(MINEM)	;MINUS EM
	BAKT	(.SKLE0)	;SKIPLE INST
	BAKF	(.SKGE0)	;SKIPGE INST
	JSB	(RREEXI)	;REG RESET EXIT
	W1	(CLA)		;W1
	BIN	(.MN0)	;MOVN INST
	W1	(STO)		;W1
	W1	(SWT)		;W1
	BIN	(.JULE0)	;JUMPLE INST
	JMP	(LGEEXI)	;LOOP GEN EXIT
CILCGE:					;CONST INCR LOOP CLOSE GEN
	SMK	(COPEM)	;CONST ONE PNTR EM
	JMPT	(CILCG1)	;$1
	SMK	(MINEM)	;MINUS EM
	BAIT	(.SUB1)	;SUB DO REG INST
	BAIF	(.ADD1)	;ADD DO REG INST
	JSB	(LIMGEN)	;LIMIT GEN
	BINT	(.CML0)	;CAML INST
	BINF	(.CMG0)	;CAMG INST
	W1	(SWT)		;W1
	BAI	(.JRST0)	;JRST INST
	JMP	(LGEEXI)	;LOOP GEN EXIT
CILCG1:
	SME	(MINEM)	;MINUS EM
	JSB	(LIMGEN)	;LIMIT GEN
	BINT	(.CMLE0)	;CAMLE INST
	BINF	(.CMGE0)	;CAMGE INST
	W1	(SWT)		;W1
	BINT	(.SOJA0)	;SOJA INST
	BINF	(.AOJA0)	;AOJA INST
LGEEXI:					;LOOP GEN EXIT
	POW	(D2)		;TWO
	SNZ	(JOUFLA)	;JUMP OUT FLAG
	STO	(JOUFLA)	;JUMP OUT FLAG
	NOZT	(JOUFLA)	;JUMP OUT FLAG
	ZER	(IIVPNT)	;INSIDE INDUC VAR PNTR
	REL	(SUBROL)	;SUBEXP ROLL
	XIT	(EXIML)	;EXIT
LIMGEN:					;LIMIT GEN
	JSB	(GENRUN)	;GEN RUN
	JSB	(GPOGEN)	;GRNTEE POSITIVE GEN
	FET	(DREPNT)	;DO REG PNTR
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT
GPOGEN:					;GRNTEE POSITIVE GEN
	SMK	(MINEM)	;MINUS EM
	XITF	(EXIML)		;OPTIMIZE CODE
	JSB	(GIRGEN)	;GRNTEE IN REG GEN
	SMK	(MINEM)	;MINUS EM
	W0T	(FET)		;W0
	BINT	(.MN0)	;MOVN INST
	XIT	(EXIML)	;EXIT
LSHGEN:					;LOCAL SPROG HEAD GEN
	FET	(RZEPNT)	;REG ZERO PNTR
	ZER	(APNPNT)	;ARG PNTR PNTR
LSHGE1:
	DFA	(APNROL)	;ARG PNTR ROLL
	XMLF	(P1EML)	;PRUNE ONE EXIT
	SME	(DITEM)	;DOUBLE ITEM EM
	BAK	(.PSH2)
	BAKT	(.RRZ1)	;HRRZ 1 XR16 INST
	POCT	(ABSINS)	;ABS INST
	POCT	(.PSH3)	;PUSH 0 1 XR1 INST
	W0	(TLY)		;W0
	JMP	(LSHGE1)
				;23 LINES DELETED	;"23C"
BSRGEN:				;BLOCK SAVE REGS GEN ;"21V"
	JSB	(PTEMAK)	;GET A PERM TEMP PNTR ;"21V"
	STK	(ABLPNT)	;DEFINE AS START OF BLOCK ;"21V"
	SNZ	(SINFLA)	;FUNCTION ? ;"21V"
	JMPF	(BSRGE1)	;NO, SAVE AC 15/16 ONLY ;"21V"
	FET	(REGCNT)	;GET # OF CONTIGUOUS REGS TO BE SAVED ;"21V"
	SGK	(THREE)		;BLT OVERHEAD REQUIRED ? ;"21V"
	AMY	(TEMCNT)	;INDICATE BLOCK LENGTH ;"21V"
	JMPF	(BSRGE3)	;NO, GEN MOVEM'S ;"21V"
	BAK	(.MEI0)		;GEN MOVEI 0,BLOCK
	FET	(RZEPNT)	;FAKE AN IMMEDIATE ;"21V"
	ADDA	(D2)		;MODE 2 ;"21V"
	BAI	(.RLI0)		;GEN HRLI 0,2 ;"21V"
	ADD	(REGCNT)	;MAKE END OF BLOCK ;"21V"
	BAK	(.BLT0)		;GEN BLT 0,BLOCK END ;"21V"
	W0	(TLY)		;BLOCK END +1
BSRGE1:				;$1, TRY TO SAVE AC 15/16 ;"21V"
	TLY	(TEMCNT)	;UPDATE COUNT "24A"
				;2 LINES DELETED "24-2"
	BAK	(.MEM1)		;GEN MOVEM 15,TEMP. ;"21V"
	W0	(TLY)		;ADDRESS FREE TEMP LOC ;"21V"
BSRGE2:				;$2, TRY TO SAVE AC16 ;"21V"
	TLY	(TEMCNT)	;UPDATE COUNT "24A"
				;3 LINES DELETED "24-2"
	FET	(R16PNT)	;GET REG 16 PNTR ;"21V"
	W1	(SWT)		;PUT IN PROPER ORDER ;"21V"
	BIN	(.MEM0)		;GEN MOVEM 16,TEMP. ;"21V"
	XIT	(P1EML)		;EXIT PRUNING REG PNTR ;"21V"
BSRGE3:				;$3, SAVE WITH MOVEM'S ;"21V"
	SNZ	(REGCNT)	;ANY REGS TO SAVE ? ;"21V"
	JMPF	(BSRGE1)	;NO, TRY AC15/16 ;"21V"
	FET	(RONPNT)	;GET REG 1 PNTR ;"21V"
	FET	(REGCNT)	;GET # OF REGS TO BE SAVED ;"21V"
	W2	(SWT)		;PUT IN PROPER ORDER ;"21V"
BSRGE4:				;$4, ITERATION POINT ;"21V"
	W2	(DIM)		;DECREMENT REG CNT ;"21V"
	W1	(TLY)		;INCREMENT REG CNT ;"21V"
	BIK	(.MEM0)		;GEN MOVEM 2/3/4,BLOCK/+1/+2 ;"21V"
	W0	(TLY)		;INCREMENT TEMP PNTR ;"21V"
	W2	(SNZ)		;MORE REGS TO SAVE ? ;"21V"
	JMPT	(BSRGE4)	;YES, SAVE THEM ;"21V"
	W2	(SWT)		;PUT COUNT ON TOP ;"21V"
	POW	(D2)		;PRUNE COUNT AND REG PNTR ;"21V"
	JMP	(BSRGE1)	;TRY TO SAVE AC15/16 ;"21V"
				;LINE DELETED	;"23C"
SEXGEN:					;SPROG EXIT GEN
	CNT	(APNROL)	;ARG PNTR ROLL
	ADD	(BREPNT)	;BLANK REG PNTR
	BAI	(.JRA1)	;JRA 16 XR16 INST
	REL	(APNROL)	;ARG PNTR ROLL
	REL	(LDMROL)	;LOCAL DMY ROLL
	XIT	(EXIML)	;EXIT
ASUGEN:				;ADD SUB GEN
	SEK	(ZERO)	;ZERO
	POWT	(D1)		;ONE
	JMPT	(EIRGEN)	;EXP IN REG GEN
	JSB	(RFBGEN)	;READY FOR BINARY GEN
			;LINE DELETED HERE "20J"
			;LINE RETURNED "22E"
	JSB	(SATREG)	;CHECK FOR SAVE OF XTRA REG
	JSB	(R0SACK)	;"22N"
	SON	(MINEM)	;MINUS EM
	JMPF	(AGEFIN)	;ADD GEN FIN
	SMK	(MINEM)	;MINUS EM
	BTKT	(.ADD0)	;ADD INST
	BTKF	(.SUB0)	;SUB INST
	JMP	(RREEXI)	;REG RESET EXIT
AGEFIN:					;ADD GEN FIN
	SMK	(MINEM)	;MINUS EM
	BTKT	(.SUB0)	;SUB INST
	BTKF	(.ADD0)	;ADD INST
RREEXI:					;REG RESET EXIT
	SMK	(REGEM)	;REG EM
	XMLF	(P1EML)	;PRUNE ONE EXIT
	JSB	(RSATES)	;REG SAVE TEST
	XW0.0F	(ZER)		;ZERO RUNG
	XML	(P1EML)	;PRUNE ONE EXIT
MPYGEN:					;MPY GEN
	JSB	(RFBGEN)	;READY FOR BINARY GEN
	JSB	(MBPO2G)	;MPY BY POWER OF 2 GEN
	JSB	(SATREG)	;SAVE THIRD REG IF D.P. ;"21S"
	JSB	(R0SACK)	;"22N"
	BTKF	(.IMU0)	;MPY INST
MDGFIN:					;MPY DIV GEN FIN
	W0	(FET)		;W0
	AND	(SIGMAS)	;SIGN MASK
	W2	(EOM)		;W2
	JMP	(RREEXI)	;REG RESET EXIT
R0SACK:			;CHECK FOR SAV OF REGS 0,1
	SMK	(DITEM)		;DOUBLE ITEM? "22N"
	XITF	(EXIML)		;NO EXIT"22N"
	SON	(RZEEM)		;REG 0 EM? "22N"
	XITT	(EXIML)		;"22N"
	FET	(RZEPNT)	;"22N"
	IER	(DITEM)		;"22N"
	JSB	(GABTGE)	;"22N"
	POW	(D1)		;"22N"
	XIT	(EXIML)	;"22N"
DIVGEN:					;DIV GEN
	SMK	(SUBEM)	;SUBEXP EM
	XW0.4T	(TLY)		;USE CNT RUNG
	JSB	(GENRUN)	;GEN RUN
	JSB	(DIVCCK)	;CHECK TYPES "22D"
	W1	(SWT)		;W1
	JSB	(EIRGEN)	;EXP IN REG GEN
	JSB	(DIVCCK)	;CHECK TYPES "22D"
	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
	W1	(SWT)		;W1
	SMK	(REGEM)	;REG EM
	JMPF	(DIVGE1)	;$1
	XW0.0	(FET)		;ZERO RUNG
	SMK	(SUBEM)
	XW0.4T	(DIM)		;USE CNT RUNG
	IERT	(ETYEM)		;"23V" SET TO SUBEXP TYPE
	XW1.0	(STO)		;"23V" RESTORE POINTER TO REG
DIVGE1:
	JSB	(DBPO2G)	;DIVIDE BY POWER OF 2 GEN
	JMPT	(MDGFIN)	;FINISH UP IF DIVIDE GENED
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(ITYEM)	;INTEGER TYPE EM
	JMPF	(DIVGE2)	;SAV TIME
	W1	(FET)		;W1
	ADDA	(D1)
	AND	(RHAMAS)	;PROPER TYPE AND SIGN MUST ALSO
	XW0.0	(FET)		;BE ATTACHED
	AND	(TASMAS)
	W1	(IOM)
	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
	XW0.0T	(NOZ)		;ZERO RUNG
	POWT	(D1)		;ONE
DIVGE2:
	JSBF	(SATREG)	;TEST FOR SAV NEXT REG
	JSB	(R0SACK)	;"22N"
	BTK	(.IDI0)	;DIV INST
	XW1.0T	(ZER)
	JMP	(MDGFIN)	;MPY DIV GEN FIN
DIVCCK:			;CHECK FOR UNEQUAL TYPES "22D"
	XW2.0	(FET)		;GET EXP OP PNTR "22D"
	STO	(EOPPNT)	;SAVE TYPE "22D"
	SMK	(ETYEM)		;ARE TYPES THE SAME? "22D"
	JSBF	(GENRUN)	;NO CONVERT TO DOMINATING TYPE "22D"
	XIT	(EXIML)		;EXIT "22D"
RFBGEN:					;READY FOR BINARY GEN
	FET	(ZERO)	;ZERO
	W2	(SWT)		;W2
	JSB	(RFBGFI)	;READY FOR BINARY GEN FIN
	W2	(STO)		;W2
	FET	(EOPPNT)	;GET OP PNTR ;"21I"
	SMK	(OTAEM)		;IF AN OPERATOR IS IT A ;"21I"
	SPKT	(LOPTRA)	;LOGICAL OPERATOR ? ;"21I"
	POW	(D1)		;PRUNE THE NOW SUPERFULOUS OP PNTR ;"21I"
	IERT	(LTYEM)		;LOG OPS GIVE LOG RESULTS ;"21I"
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT
RFBGFI:					;READY FOR BINARY GEN FIN
	XML	(BOSML)	;BINARY ORDER SELECT
	W1	(ART)		;W1
	JMPT	(RFBGF2)	;$2
	W1	(SWT)		;W1
	JSB	(MPO2CK)	;MULT POWER OF 2 CK
	POWT	(D1)		;ONE
	W2T	(NOT)		;W2
	W1F	(SWT)		;W1
RFBGF2:
	JSB	(GENRUN)	;GEN RUN
	JSB	(RFBGF4)	;CHECK FOR UNEQUAL TYPES "22D"
	W0	(ART)		;W0
	JMPF	(RFBGF1)	;$1
	JSB	(RSATES)	;REG SAVE TEST
	JMPT	(RFBGF1)	;$1
	W1	(SWT)		;W1
	JSB	(GENRUN)	;GEN RUN
	JSB	(RFBGF4)	;CHECK FOR UNEQUAL TYPES "22D"
	W1	(ART)		;W1
	JMPF	(RFBGF3)	;$3
	W2	(NOT)		;W2
	W0	(ART)		;W0
	XITF	(EXIML)	;EXIT
	JSB	(RSATES)	;REG SAVE TEST
	XMLF	(BOSML)	;BINARY ORDER SELECT
	XIT	(EXIML)	;EXIT
RFBGF1:
	W1	(SWT)		;W1
RFBGF3:
	JSB	(EIRGEN)	;EXP IN REG GEN
	JSB	(RFBGF4)	;"22D"
	SMK	(IIVEM)	;INSIDE AN IMPLIED DO LOOP ?
	JSBF	(SRITGE)	;NO, OPTIMIZE (SAVE REG IN TEMP GEN)
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT
RFBGF4:			;CHECK FOR TYPES OF OPERANDS IN EXP
	SMK	(REGEM)		;IS EXP IN REG "22D"
	XITF	(EXIML)		;NO "22D"
	W3	(FET)		;GET EXP PNTR "22D"
	SMK	(LBLEM)		;REL OPS HAVE OFFSET IN W3 (ROLL #=0) ;"22D"
	W5T	(CLA)		;SO GET THE REAL EXP PNTR ;"22D"
	XW0.0	(CLA)		;GET OP PNTR "22D"
	STO	(EOPPNT)	;SET NEW EXP TYPE "22D"
	SMK	(ETYEM)		;IS EXP IN REG SAME AS NEXT LEVEL EXP? "22D"
	JSBF	(GENRUN)	;NO CONVERT IT "22D"
	XW0.0F	(FET)		;"23-AO"
	IERF	(ETYEM)		;"23-AO"
	XW1.0F	(STO)		;"23-AO"
	XIT	(EXIML)		;EXIT "22D"
DBPO2G:					;DIV BY POWER OF 2 GEN
	JSB	(PO2CHE)	;POWER OF 2 CHECK
	XITF	(EFAML)		;NOT A CONSTANT POWER OF 2
	W0	(NOT)		;MAKE ONE'S COMPLEMENT NEGATIVE ;"22J"
	W0	(TLY)		;MAKE TWO'S COMPLEMENT NEGATIVE ;"22J"
	SON	(ITYEM)		;DIVIDE BY ASH ? ;"22J"
	SONF	(OCTEM)		;"23-AN"
	JMPF	(SGEFIN)	;NO, TAKE THE NORMAL PATH ;"22J"
	SEK	(ZERO)		;IF N=0, 2**N=1 ;"22J"
	XMLT	(P1ETML)	;OPERATION IS IDENTITY, IGNORE ;"22J"
	W2	(FET)		;GET AC PNTR ;"22J"
	BAK	(.SKGE0)	;GEN SKIPGE 00,AC ;"22J"
	FET	(DAT1)		; GET DIVIDEND (CONSTANT POWER OF 2) ;"22J"
	SUB	(ONE)		;MAKE 2**N-1 ;"22J"
	STO	(DAT1)		;STORE IN CONSTANT FILE CLUE ;"22J"
	REG	(ICOFIL)	;REGISTER AS INTEGER CONSTANT ;"22J"
	FET	(CREPNT)	;AND GET PNTR ;"22J"
	BIN	(.ADD0)		;GEN ADD/ADDI AC,2**(N-1) ;"22J"
	POW	(D1)		;PRUNE EXTRA REG PNTR ;"22J"
	EAWI	(.ASH0)		;LOAD INSTRUCTION TO BE GENED ;"22J"
	JMP	(SGEFI2)	;AND CONTINUE AS IF NOTHING HAD HAPPENED	;"22J"
MBPO2G:					;MPY BY POWER OF 2 GEN
	JSB	(PO2CHE)	;POWER OF 2 CHECK
	JMPF	(EXIFAL)	;EXIT FALSE
SGEFIN:					;SHIFT GEN FIN
	SEK	(ZERO)	;ZERO
	XMLT	(P1ETML)	;PRUNE ONE EXIT TRUE
	AND	(RHAMAS)	;RIGHT HALF MASK
	SON	(DITEM)	;DOUBLE ITEM EM
	SONF	(RTYEM)	;REAL TYPE EM
	EAWIT	(.FSC0)	;FSC INST
				;3 LINES DELETED ;"23-AN"
	EAWIF	(.ASH0)		;ASH INST ;"23-AN"
SGEFI2:
	JSB	(SCAGEN)	;SCALE GEN
IFNDEF HARDFL,<							; *EJG* 07/05/76
	SNZ	(PDPSW)	;CHECK FOR PDP-10
	SMKT	(DITEM)	;YES ,TREAT D.P.&CMPL SAME
	JMPT	(SGEFI1)	;$1
>								; *EJG* 07/05/76
	SMK	(CTYEM)	;COMPLEX TYPE EM
	XITF	(ETRML)	;EXIT TRUE
SGEFI1:
	EAWT	(.FSC0)	;FSC INST
	JSBT	(BSHREF)	;BUILD SECOND HALF REF
	MOA	(CODROL)	;CODE ROLL
	SUB	(ONE)		;ONE
	MON	(CODROL)	;CODE ROLL
IFNDEF HARDFL,<							; *EJG* 07/05/76
	SNZ	(PDPSW)	;CHECK FOR PDP-10
	SONT	(DPTEM)	;D.P. TYPE?
	XMLF	(ETRML)		;LSH
	W1	(FET)		;GET H.O.AC
	W0	(FET)		;COPY
	W0	(TLY)		;MAKE L.O.AC
	BIN	(.FAL0)	;FADL H.O.AC,L.O.AC
	POW	(D1)		;PRUNE
>								; *EJG* 07/05/76
	XML	(ETRML)	;EXIT TRUE
MPO2CK:					;MULT POWER OF 2 CK
	FET	(EOPPNT)	;EXP OP PNTR
	SPT	(MODOTR)	;MULT OR DIV OP TRAIT
	JMPF	(EXIFAL)	;EXIT FALSE
PO2CHE:					;POWER OF 2 CHECK
	SMK	(CONEM)	;CONST PNTR EM
	XITF	(EFAML)		;EXIT FALSE
	SMK	(HCOEM)		;HOLLERITH CONST EM	;LSH
	XITT	(EFAML)		;EXIT FALSE
	XW0.0	(FET)		;ZERO RUNG
	STO	(DAT1)	;DATA 1
	SMK	(DITEM)	;DOUBLE ITEM EM
	XW0.1T	(FET)		;ONE RUNG
	STOT	(DAT2)	;DATA 2
	ZERF	(DAT2)	;DATA 2
	SMKF	(RTYEM)	;REAL TYPE EM
	XMLF	(FPO2CM)	;FX POWER OF 2 CHECK ML
	SNZ	(DAT2)	;DATA 2
	JMPT	(EXIFAL)	;EXIT FALSE
	FET	(DAT1)	;DATA 1
	SMK	(FPO2EM)	;FL POWER OF 2 EM
	XMLF	(P1EFML)	;PRUNE ONE EXIT FALSE
	XIT	(MFPML)	;MAKE FL POWER ML
EXPGEN:					;EXPON GEN
	SMK	(ICOEM)	;INTEGER CONST EM
	JMPF	(EBSGEN)	;EXPON BY SR GEN
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XW0.0	(FET)		;ZERO RUNG
	JMPF	(EXPGE1)	;$1
	SLK	(THREE)	;THREE
	JMP	(EXPGE2)	;$2
EXPGE1:
	XML	(ECHML)	;EXPON BY MPY CHECK
EXPGE2:
	POWF	(D1)		;ONE
	JMPF	(EBSGEN)	;EXPON BY SR GEN
	SEK	(ZERO)	;ZERO
	POWT	(D3)		;THREE
	FETT	(CONPNT)	;CONST ONE PNTR
	JMPT	(GENRUN)	;GEN RUN
	W1	(SWT)		;W1
	W1	(EOR)		;W1
	SME	(MINEM)	;MINUS EM
	JMPF	(EBMGEN)	;EXPON BY MPY GEN
	JSB	(EBMGEN)	;EXPON BY MPY GEN
	FET	(CONPNT)	;CONST ONE PNTR
	W1	(SWT)		;W1
	JMP	(DIVGEN)	;DIV GEN
EBMGEN:					;EXPON BY MPY GEN
	SLK	(ZERO)	;ZERO
	W0T	(NOT)
	W0T	(TLY)
	SMK	(EVEEM)	;EVEN EM
	W1	(SWT)		;W1
	JSB	(GENRUN)	;GEN RUN
	ANDT	(ABSMAS)
	W1	(SWT)		;W1
	SEK	(ONE)		;ONE
	XMLT	(P1EML)	;PRUNE ONE EXIT
	XML	(IEAML)	;INTEGER EXPON ABSTRACT
	W0	(FET)		;W0
	SMK	(REGEM)	;REG EM
	JMPF	(EBMGE1)	;$1
	JSB	(RSATES)	;REG SAVE TEST
	SNZF	(ISCBOX)	;INTEGER SCANER BOX
	JMPF	(EBMGE1)	;$1
	STO	(REGTEM)	;REG TEMP
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSBT	(DSITGE)	;DOUBLE STORE IN TEMP GEN
	JSBF	(SITGEN)	;STORE IN TEMP GEN
	FET	(REGTEM)	;REG TEMP
	W1	(SWT)		;W1
	AND	(ABSMAS)	;CLEAR OUT SIGN BIT "23AN"
EBMGE1:
	STO	(VPNBOX)	;VAR PNTR BOX
	JSB	(GIRGEN)	;GRNTEE IN REG GEN
	AND	(ABSMAS)
	W0	(FET)		;W0
EBMGE2:
	FET	(ISCBOX)	;INTEGER SCANER BOX
	SLK	(ZERO)	;ZERO
	AMY	(ISCBOX)	;INTEGER SCANER BOX
	JMPF	(EBMGE3)	;NO ODD MULTIPLY
	FET	(VPNBOX)	;VAR PNTR BOX
	SMK	(AREEM)	;ARRAY ?
	JMPF	(EBMGE4)	;NOT AN ARRAY
	XW0.2	(FET)		;YES,GET SCRIPT PNTR
	SMK	(SUBEM)	;IS IT A SUB EXP ?
	XW0.4T	(TLY)		;YES, INCREMENT SCRIPT USE COUNT
	POW	(D1)		;REMOVE SCRIPT PNTR
EBMGE4:
			;LINE DELTED HERE "22D"
	BTY	(.IMU0)	;MPY INST
EBMGE3:
	SNZ	(IBICNT)	;INTEGER BITS CNTR
	DIMT	(IBICNT)	;INTEGER BITS CNTR
	JSBT	(SATREG)	;SAVE THIRD REG
	JSBT	(R0SACK)	;"23-AQ"
	BTKT	(.IMU0)	;MPY INST
	JMPT	(EBMGE2)	;$2
	FET	(VPNBOX)
	SME	(MINEM)
	BAKT	(.MNS0)
	XML	(P1EML)	;PRUNE ONE EXIT
EBSGEN:					;EXPON BY SR GEN
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(DITEM)		;DOUBLE ITEM EM ;"23-AM"
	JMPF	(ESIGEN)	;EXPON SINGLE GEN
	W1	(SWT)		;W0<-EXPONENT,W1<-EOPPNT ;"23-AM"
	SMK	(ITYEM)		;EXPONENT=INTEGER OR DITEM ;"23-AM"
	STKT	(EOPPNT)	;EOPPNT<-INTEGER ;"23-AM"
	JSB	(GENRUN)	;"23-AM"
	JSBT	(SAEXGE)	;"23-AM"
	W1	(SWT)		;W0<-EOPPNT,W1<-EXPONENT ;"23-AM"
	STO	(EOPPNT)	;EOPPNT<-RESTORED TO DITEM ;"23-AM"
	JSBF	(SAEXGE)	;"23-AM"
	W1	(SWT)		;W1
	SMK	(DITEM)		;"24-7"
	SMKF	(SUBEM)		;NOT DOUBLE OR COMPLEX "24-7"
	JSBF	(GENRUN)	;AND NOT A SUBEXP "24-7"
	JSB	(EIR0GE)	;EXP IN REG 0 GEN
	SMK	(DITEM)		;"24-7"
	JSBF	(GENRUN)	;"24-7" CONVERT TO DOUBLE
	W1	(SWT)		;W1
	SMK	(MLBEM)		;MADE LABEL ? (ARRAY ELEMENT ADDRESS STORE)
	JSBT	(MLGAKE)	;YES, GEN THE LABEL
	NOZ	(SAV16)		;SAVE REG 16 ONLY IF USED ;"21V"
	BAK	(.MEI2)	;MOVEI 16 INST
	SME	(ITYEM)	;INTEGER TYPE EM
	JMPT	(EBSGE1)	;$1
	FET	(EOPPNT)	;CHECK TYPE "24-7"
	SME	(CTYEM)		;COMPLEX? "24-7"
	BLKT	(.CEXP3)	;CEXP.3 LINK
	BLKF	(.DEXP3)	;DEXP.3 LINK
	XIT	(EXIML)	;EXIT
EBSGE1:
	SMK	(CTYEM)	;COMPLEX TYPE EM
	BLKT	(.CEXP2)	;CEXP.2 LINK
	BLKF	(.DEXP2)	;DEXP.2 LINK
	XIT	(EXIML)	;EXIT
CTFLGE:					;CONV TO FL GEN
	JSB	(CTFCK)	;CONVERT TO FLO OR FIX CK
	IERT	(MINEM)
	W1	(SWT)
	SMK	(RZEEM)	;REG ZERO ?
	JSBT	(SITGEN)	;YES, STORE IT IN TEMP
	JSB	(AIVREP)	;REPLACE WITH DO REG IF INDEX
	BLK	(.FLOAT)	;FLOAT. LINK
	BAK	(.ARG0)	;ARG INST
	IER	(RTYEM)	;REAL TYPE EM
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(DITEM)	;DOUBLE ITEM EM
	POWF	(D1)		;ONE
	JMPF	(CTFLG1)	;$1
	SME	(DPTEM)	;DOUBLE PRECISION TYPE EM
	IERT	(DPTEM)		;SET NEXT OPERAND DP "22D"
	JMPT	(CTFLG1)	;"22D"
	IER	(CTYEM)	;COMPLEX TYPE EM "22D"
	W1	(SWT)		;W1
	XW0.1	(NOZ)		;NEXT HIGHER REG
;DELETED "22X"	JSB	(DRGFIN)	;DOUBLE REG GEN FIN
	W0	(TLY)		;"22X"
	BRI	(.MEI0)		;"22X"
	W0	(DIM)		;"22X"
	W1	(SWT)		;W1
	IERT	(DPTEM)	;DOUBLE PRECISION TYPE EM
CTFLG1:
	SMK	(TEMEM)		;DOES W0 HAVE A TEMP EM
	JMPF	(CTFLG2)	;NO, RETURN
	FET	(RZEPNT)	;GET REG 0 PNTR
	XML	(TSAML)		;SET EMOF REG 0 IN ALL ENTRIES = W1
	POW	(D1)		;REMOVE EXTRA REG 0 PNTR
CTFLG2:
	XW1.0	(STO)		;ZERO RUNG
	XIT	(EXIML)	;EXIT
CTFGEN:					;CONV TO FX GEN
	JSB	(CTFCK)	;CONVERT TO FLO OR FIX CK
	IERT	(MINEM)		;SET MINUS FOR ASSIGNMENT "22L"
	IER	(ITYEM)		;MAKE SURE REG0 IS INTEGER ;"23T"
	W1	(SWT)
			;2 LINES DELETED HERE "22L"
	SMK	(RZEEM)	;REG ZERO ?
	JSBT	(SITGEN)
	JSB	(AIVREP)	;GET ACTIVE INDUCED VAR - "20A"
	SMK	(AREEM)		;IS IT ARRAY REF? - "20A"
	JSBT	(GIRGEN)	;YES GEN IN A REG - "20A"
	SMK	(DPTEM)		;"23T" DOUBLE ITEM?
	BLKF	(.IFIX)		;"23T" NO IFIX
	BLKT	(.DFIX)		;"23T" YES DFIX
	BAK	(.ARG0)	;ARG INST
	IER	(ITYEM)	;INTEGER TYPE EM
	STK	(EOPPNT)	;"22D"
	JMP	(CTFLG1)	;$1
CTFCK:					;CONVERT TO FLO OR FIX CK
	SMK	(RZEEM)	;REG ZERO EM
	FETT	(RZEPNT)	;REG ZERO PNTR
	JSBF	(GR0AGE)	;GRNTEE REG 0 AVAIL GEN
	SON	(MINEM)	;MINUS EM 
	XIT	(EXEQML)
ESIGEN:					;EXPON SINGLE GEN
	POW	(D1)		;PRUNE EOPPNT ;"23-AM"
	JSB	(GR0AGE)	;MAKE SURE REG 0 IS NOT IN USE "22N"
	POW	(D1)		;PRUNE XTRA PNTR "22N"
	SMK	(SUBEM)	;SUBEXP EM
	STKT	(EOPPNT)	;"23-AM"
	JSBT	(EIRGAS)	;EXP IN REG GEN AND SAVE
	JSBF	(AIVREP)	;ACTIVE IND VAR REPLACE
	XW2.0T	(FET)		;GET NEXT OP PNTR "22D"
	STOT	(EOPPNT)	;SET NEW EXP TYPE "22D"
	W1	(SWT)		;W1
	JSB	(EIERGE)	;EXP IN EVEN REG GEN
	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
	W1	(SWT)		;W1
	XW0.4T	(DIM)		;USE CNT RUNG
	XW0.3T	(FET)		;STATUS PNTR RUNG
	JSBT	(SNOEXI)	;SIGN NOTE EXIT
	STK	(PINATO)	;PNTR INSERT ATOM
	W1	(FET)		;W1
	W0	(TLY)		;W0
	SMK	(PINEM)	;PNTR INSERT EM
	JSBT	(GPRGEN)	;GRNTEE POS REG GEN
	JSBF	(GAVGEN)	;GRNTEE AVAIL GEN
	W1	(SWT)		;W1
	W0	(FET)		;W0
	W2F	(FET)		;W2
	JSBF	(RLOGEN)	;REG LOAD GEN
	JSBF	(RREEXI)	;REG RESET EXIT
	W0F	(FET)		;W0
	JSB	(RREEXI)	;REG RESET EXIT
	W2	(FET)		;GET BASE REG ;"21W"
	SME	(RZEEM)		;IS IT REG 0 ? ;"21W"
	JMPT	(ESIGE1)	;YES, DON'T BOTHER SAVING IT ;"21W"
	FET	(RZEPNT)	;MAKE REG 0 ;"21W"
	IER	(DITEM)		;AND REG 1 AVAILABLE ;"21W"
	JSB	(GABTGE)	;SO THE SUBROUTINES CAN USE THEM ;"21W"
	POW	(D1)		;PRUNE REG PNTR ;"21W"
ESIGE1:	SME	(RTYEM)		;REAL TYPE EM ;"23-AM"
	W1	(CLA)		;W1
	LSST	(EXP3.0)	;"23-AM"
	JMPT	(ESIGE2)	;$2 ;"23-AM"
	SMK	(RTYEM)		;REAL TYPE EM ;"23-AM"
	LSSF	(EXP1.0)	;"23-AM"
	LSST	(EXP2.0)	;"23-AM"
ESIGE2:
	W0	(DIM)		;W0
	AND	(DISMAS)	;DISPL MASK
	IOM	(SYMBOL)	;SYMBOL
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(GSPPNT)	;GLOBAL SPROG PNTR
	BAI	(.PSHJ1)	;PUSHJ 17 INST
	XIT	(EXIML)	;EXIT
FRPGEN:					;FUNC REF PNTR GEN
	JSB	(GR0AGE)	;GRNTEE REG 0 AVAIL GEN
	XW1.0T	(FET)		;SPROG NAME PNTR RUNG
	W1	(SWT)		;W1
	SON	(DITEM)	;DOUBLE ITEM EM
	JMPT	(FRGFIN)	;FUNC REF GEN FIN
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSB	(FRGFIN)	;FUNC REF GEN FIN
	XIT	(EXIML)	;EXIT
DFRGEN:					;DBL FUNC REF GEN
	SMK	(DITEM)	;DOUBLE ITEM EM
	FET	(RONPNT)	;REG ONE PNTR
	JSBT	(GAVGEN)	;GRNTEE AVAIL GEN
	XML	(P1EML)	;PRUNE ONE EXIT
FRGFIN:					;FUNC REF GEN FIN
	W2	(XNI)		;W2
	CLA	(APPRUN)	;ARG PLEX PNTR RUNG
	JSB	(APPGEN)	;ARG PLEX PNTR GEN
	JSB	(GR0AGE)	;GRNTEE REG 0 AVAIL GEN
	POW	(D1)		;ONE
	JSB	(DFRGEN)	;DBL FUNC REF GEN
	JSB	(SLIGEN)	;SPROG LINK GEN
	JSBT	(SREGEN)	;SPROG REF GEN
	XW0.0	(FET)		;SPROG NAME PNTR RUNG
	AND	(TYPMAS)	;TYPE MASK
	IOR	(RZEPNT)	;REG ZERO PNTR
	SON	(NOTEM)	;NOT EM
	POCT	(ABSINS)
	POCT	(.SEA0)
	FETT	(NOTMAS)	;NOT MASK
	W2T	(EOM)		;W2
ARPGEN:					;ARRAY REF PNTR GEN
TPNGEN:					;TEMP PNTR GEN
RPNGEN:					;REG PNTR GEN
VPNGEN:					;VAR PNTR GEN
CPNGEN:					;CONST PNTR GEN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(DTYCHE)	;DP TYPE CHECK
	JSB	(AIVCHE)	;ACTIVE INDUC VAR CHECK
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(RTYEM)	;REAL TYPE EM
	SMKF	(DITEM)	;DOUBLE ITEM EM
	POW	(D1)		;ONE
	XITF	(EXIML)	;EXIT
	SMK	(DREEM)	;DO REG EM
	JMPT	(CPNGE1)	;$1
	SMK	(CONEM)	;CONST PNTR EM
	JMPT	(FINCON)	;FL INTEGER CONST
	XW0.0	(FET)		;ZERO RUNG
	SON	(AREEM)	;ARRAY REF EM
	XW0.0T	(CLA)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL 1
	ISE	(SINFIL)	;SUBSCRIPT INTEGER FILE
CPNGE1:
	JSBT	(GIRGEN)	;GRNTEE IN REG GEN
	JMPF	(CPNGE4)
	XW0.0	(FET)		;GET DO REG.
	IER	(RTYEM)	;MAKE SURE IT'S REAL TYPE
	XW1.0	(STO)		;RETURN IT

	SNZ	(PDPSW)	;TEST MACHINE TYPE
	BRIF	(.TLC1)	;TLC 233 OCTAL INST
	FETF	(CZEPNT)	;CONST ZERO PNTR
	BINF	(.FAR0)	;FAD INST

	BRIT	(.FSC1)	;FSC 233
	JMP	(CPNGE2)	;$2

CPNGE4:
	SMK	(AREEM)	;ARRAY REF EM
	JSBT	(SCRGEN)	;SCRIPT GEN
	XW1.2T	(STK)		;"23-AR"
	JMPF	(CPNGE3)	;$3
	SMK	(DREEM)
	XW0.0F	(CLA)		;ZERO RUNG
	XW0.4F	(TLY)		;USE CNT RUNG
	POW	(D1)		;ONE
CPNGE3:
	JSB	(CTFLGE)	;CONV TO FL GEN
CPNGE2:
	IER	(ETYEM)	;EXP TYPE EM
	XIT	(EXIML)	;EXIT
DTYCHE:					;DP TYPE CHECK
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	SMK	(DITEM)	;DOUBLE ITEM EM
	XITT	(EXIML)	;EXIT
	SMK	(CONEM)	;CONST EM
	JMPF	(GIRGEN)	;GRNTEE IN REG GEN
	FET	(EOPPNT)	;EXP OP PNTR	;"21G"
	SME	(DPTEM)		;DOUBLE PRECISION OPERATION ?	;"21G"
	SMKT	(RTYEM)		;YES, IS CONST REAL?	;"21G"
	IERT	(DPTEM)		;YES CHANGE TO DBL
	XITT	(EXIML)		;EXIT
	SMK	(HTYEM)	;HOLLERITH TYPE EM
	JMPT	(LCOFIN)	;LITERAL CONSTANT FIN
	XW0.0	(FET)		;ZERO RUNG
	JMP	(FICFIN)	;FL INT CONST FIN
LCOFIN:					;LITERAL CONSTANT FINISH
	STK	(HBUIND)	;STORE ROLL PNTR
	XW0.1	(FET)		;GET HIGH ORDER PART
	XW1.0	(FET)		;GET PLEX CNT
	SLT	(TWO)		;CHK FOR DBL WD CONST
	JMPT	(FICFIN)	;NORMAL MODE FOR SINGLE WD
	SON	(MINEM)	;CHK PNTR FOR NEGATE
	JSB	(CSIADJ)	;CONSTANT SIGN ADJ
	SUBT	(ONE)		;ONE'S COMP IF NEGATE
	STO	(DAT1)	;STORE HIGH ORDER
	FET	(HBUIND)	;GET PRUNED PNTR
	XW0.2	(FET)		;GET LOW ORDER PART
	JSB	(CSIADJ)	;CONSTANT SIGN ADJ
	STO	(DAT2)	;STORE LOW ORDER
	FET	(EOPPNT)	;EXPRESSION OPERATION PNTR
	SMK	(DPTEM)	;DP TYPE EM
	POWT	(D1)		;PRUNE
	JMPT	(FICFI4)	;$4
	SME	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(FICFI3)	;$3
	JMP	(FICFI5)	;$5

FINCON:					;FL INTEGER CONST
	XW0.0	(FET)		;ZERO RUNG
	XML	(FINML)	;CONV INTEGER TO FL
FICFIN:					;FL INT CONST FIN
	JSB	(CSIADJ)	;CONST SIGN ADJUST
	STO	(DAT1)	;DATA 1
	ZER	(DAT2)		;CLEAR LOWER
	FET	(EOPPNT)	;EXP OP PNTR
CCOFIN:					;CONST CONV FIN
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	JMPF	(FICFI1)	;$1
	POW	(D1)		;ONE
	IER	(DPTEM)		;SET TO DP
FICFI4:
	REG	(DPCFIL)	;DOUBLE PREC CONST FILE
	JMP	(FICFI2)	;$2
FICFI1:
	SME	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(FICFI3)	;$3
FICFI5:
	REG	(CCOFIL)	;CONPLEX CONST FILE
	JMP	(FICFI2)	;$2
FICFI3:
	REG	(RCOFIL)	;REAL CONST FILE
	FET	(CREPNT)	;GET REG PNTR
	IER	(RTYEM)		;SET IT TO REAL
	XIT	(EXIML)		;EXIT
FICFI2:
	FET	(CREPNT)	;CRRNT REG PNTR
	XIT	(EXIML)	;EXIT
AIVCHE:					;ACTIVE INDUC VAR CHECK
	STK	(PINATO)	;PNTR INSERT ATOM
	FET	(IIVPNT)	;INSIDE INDUC VAR PNTR
	SME	(PINEM)	;PNTR INSERT EM
	NOZT	(REGSAV)	;SET CLEAR STATUS FLAG
	IERT	(DREEM)	;DO REG EM
	XIT	(EXEQML)	;EXIT EQUAL ML
APPGEN:					;ARG PLEX PNTR GEN
	STK	(APLPNT)	;ARG PLEX PNTR
	SEQ	(ZERO)	;ZERO
	JMPT	(EXIFAL)	;EXIT FALSE
	RSV	(APNROL)	;ARG PNTR ROLL
	FET	(EOPPNT)	;EXP OP PNTR
	XNI	(APLPNT)	;ARG PLEX PNTR
	FET	(ZERRUN)	;ZERO RUNG
APPGE1:
	JOW	(APPGE2)	;$2
	DFA	(APLROL)	;ARG PLEX ROLL
	FET	(APLPNT)	;ARG PLEX PNTR
	W1	(SWT)		;W1
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(SARGEN)	;SPROG ARG GEN
	MON	(APNROL)	;ARG PNTR ROLL
	STO	(APLPNT)	;ARG PLEX PNTR
	JMP	(APPGE1)	;$1
APPGE2:
	STO	(EOPPNT)	;EXP OP PNTR
	XML	(ETRML)	;EXIT TRUE

AIVREP:					;ACTIVE IND VAR REPLACE
	JSB	(AIVCHE)	;ACTIVE IND VAR CHECK
	XIT	(EXIML)	;EXIT
SLIGEN:					;SPROG LINK GEN
	SMK	(LSPEM)	;LOCAL SPROG EM
	JMPF	(SLGFIN)	;NOT A LOCAL SPROG
	FET	(LSPDEF)	;"23-AM"
	STO	(PINATO)	;"23-AM"
	SMK	(PINEM)		;"23-AM"
	CCFT	(M20QT)		;"23-AM"
	XW0.1	(CLA)		;LOCAL SPROG MADE LBL RUNG
	BAI	(.JSA1)		;BUILD	JSA	16,MADE LABEL
	XIT	(EXIML)		;AND EXIT
SLGFIN:				;SPROG LINK GEN FIN
	XW0.0	(FET)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	BAIF	(.JSA1)
	XITF	(EXIML)
	REG	(SCAFIL)	;SCALAR FILE
	CLA	(CREPNT)	;CRRNT REG PNTR
	BAI	(.JSA2)	;JSA* 16 INST
	XIT	(EXIML)	;EXIT
SREGEN:					;SPROG REF GEN
	ZER	(APNPNT)	;ARG PNTR PNTR
SREGE1:
	DFA	(APNROL)	;ARG PNTR ROLL
	RELF	(APNROL)	;ARG PNTR ROLL
	XITF	(EXIML)	;EXIT
	SMK	(MLBEM)	;MADE LBL EM
	JSBT	(MLGAKE)	;MADE LBL GEN AND KEEP
	JSB	(MTYREG)	;MAKE TYPE REG
	BIN	(.ARG0)	;ARG INST
	POW	(D1)		;ONE
	JMP	(SREGE1)	;$1
SAEXGE:				;SPROG ADDRESS EXPRESSION GEN
SARGEN:					;SPROG ARG GEN
	JSB	(GENRUN)	;GEN RUN
	SMK	(MINEM)	;MINUS EM
	SMKF	(NOTEM)
	JSBT	(GIRGEN)	;GRNTEE IN REG GEN
	SMK	(AREEM)	;ARRAY REF EM
	XW0.2T	(SNZ)		;SCRIPT EXP RUNG
	SMKF	(DAIEM)	;DUMMY ARRAY ID EM
	SMKF	(DGSEM)	;DUMMY GLOBAL SPROG EM
	JMPT	(AARGEN)	;ARRAY ARG GEN
	SMK	(REGEM)	;REG EM
	XITF	(EXIML)	;EXIT
;	SPK	(SUBEM)	;SUBEXP EM
;	XW0.0T	(XNI)		
;	SNZT	(UCNRUN)	;USE CNT RUNG
;	JMPT	(ARGEFI)	;ARG GEN FIN
;	W0	(FET)		;W0
;	AND	(DISMAS)	;DISPLACEMENT MASK
;	SLK	(EIGHT)	;EIGHT
;	SGKT	(TWO)		;TWO
;	POW	(D1)		;ONE
;	JMPT	(GPRGEN)	;GRNTEE POS REG GEN
ARGEFI:					;ARG GEN FIN
	SMK	(DITEM)	;DOUBLE ITEM EM
	JMPF	(SITGEN)	;STORE IN TEMP GEN
	SMK	(DPNEM)	;DOUBLE PREC NEG EM
	JSB	(DTEMAK)	;DOUBLE TEMP MAKER
	JSBF	(DSTGEN)	;DOUBLE STORE GEN
	JSBT	(DPNSGE)	;DOUBLE PREC NEG STORE GEN
	JMP	(DSITGF)	;DOUBLE STORE IN TEMP GEN FIN
AARGEN:					;ARRAY ARG GEN
	SMK	(DGSEM)	;DUMMY GLOBAL SPROG ?
	JMPF	(AARGE1)	;NO,CONTINUE AS PREVIOUS
	XW0.0	(FET)		;GET GLOBAL SPROG NAME
	STO	(SYMBOL)	;SETUP FOR REGISTER
	REG	(SCAFIL)	;FIND OR MAKE A SCALAR
	AND	(TASMAS)	;ISOLATE TYPE AND SIGN
	IOR	(CREPNT)	;COMBINE WITH SCALAR POINTER
AARGE1:
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
	W1	(FET)		;W1
	JSB	(RSTADV)	;REG STAUS ADVANCE
	W1	(SWT)		;W1
	SMK	(AREEM)	;ARRAY REF EM
;	BIKF	(.ME0)	;MOVE INST				; *EJG* 12/17/76
	BIKF	(.MEI4)	;MOVEI @  INST				; *EJG* 12/17/76
	BIKT	(.MEI0)	;MOVEI INST
	AND	(TASMAS)	;TYPE AND SIGN MASK
	W1	(SWT)		;W1
	JSB	(LBLMAK)	;LBL MAKER
	BIK	(.RRM0)	;HRRM INST
	W2	(IOM)		;W2
	JMP	(RREEXI)	;REG RESET EXIT
IFNDEF	$NAME,
<

NAMGEN:					;NAMELIST GEN
	FLP	(NNAROL)	;NAMELIST NAME ROLL
	FLP	(NITROL)	;NAMELIST ITEMS ROLL
NAMGE1:
	MOA	(NNAROL)	;NAMELIST NAME ROLL
	JMPF	(PUNCOD)	;PUNCH CODE
	MOA	(NNAROL)	;NAMELIST NAME ROLL
	JSB	(MLBGEN)	;MADE LBL GEN
	MOA	(CODROL)	;CODE ROLL
	XML	(ST5RAD)	;SYMBOL TO 50 RADIX
	IER	(LOPTRA)	;LOGICAL OP TRAIT
	MON	(CODROL)	;CODE ROLL
	XML	(ST5RAD)	;SYMBOL TO 50 RADIX
	POC	(ABSINS)	;ABS INST
	MON	(CODROL)	;CODE ROLL
NAMGE2:
	MOA	(NITROL)	;NAMELIST ITEMS ROLL
	SEK	(ZERO)	;MARKER SYMBOL
	POCT	(ABSINS)	;ABS INST
	MONT	(CODROL)	;CODE ROLL
	JMPT	(NAMGE1)	;$1
	STK	(SYMBOL)	;SYMBOL
	XML	(ST5RAD)	;SYMBOL TO 50 RADIX
	JSB	(IDCLAS)	;ID CLASSIFY
	JSBF	(REGSCA)	;REGISTER SCALAR
	W0	(FET)		;W0
	AND	(ITYEM)	;INTEGER TYPE EM
	DIV	(TWO)		;TWO
	AND	(MOSPOS)	;MOST POSITIVE
	W2	(IOR)		;W2
	SON	(ARREM)	;ARRAY EM
	IORT	(OTYSTA)	;OCTAL TYPE STAMP
	POC	(ABSINS)	;ABS INST
	MON	(CODROL)	;CODE ROLL
	W1T	(STK)		;W1
	AND	(LHZMAS)	;LEFT HALF ZERO MASK
	MON	(CODROL)	;CODE ROLL
	POWF	(D1)		;ONE
	JMPF	(NAMGE2)	;$2
	ISE	(ARRFIL)	;ARRAY FILE
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(THRRUN)	;THREE RUNG
	XW0.0	(FET)		;ZERO RUNG
	W0	(FET)		;W0
	RSV	(LIMROL)	;LIMITS ROLL
	ADD	(THREE)	;THREE
	IER	(ABSEM)	;ABS EM
	MON	(CODROL)	;CODE ROLL
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(TWORUN)	;TWO RUNG
	MON	(LIMROL)	;LIMITS ROLL
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(ONERUN)	;ONE RUNG
	W3	(FET)		;W3
	SME	(DITEM)	;DOUBLE ITEM EM
	W0T	(ADD)		;W0
	MON	(LIMROL)	;LIMITS ROLL
	W2	(STO)		;W2
	CFP	(LIMROL)	;LIMITS ROLL
	MON	(LIMROL)	;LIMITS ROLL
	EAW	(CODROL)	;CODE ROLL
	FLP	(LIMROL)	;LIMITS ROLL
	CAR	(LIMROL)	;LIMITS ROLL
	JMP	(NAMGE2)	;$2
>
EIRGEN:					;EXP IN REG GEN
	JSB	(GENRUN)	;GEN RUN
GIRGEN:					;GRNTEE IN REG GEN
	SMK	(TEMEM)	;TEMP EM
	JMPF	(GIRGE2)	;$2
	SWT	(SYMBOL)	;SYMBOL
	ISE	(REGFIL)	;REG FILE
	SWT	(SYMBOL)	;SYMBOL
	JMPF	(RBTAAL)	;"23-AM"
	AND	(TASMAS)	;MASK TYPE & SIGN ;"23-AM"
	XNI	(CREPNT)	;CURRENT REG PNTR ;"23-AM"
	FET	(ZERRUN)	;ZERO RUNG ;"23-AM"
	AND	(SIGMAS)	;SIGN MASK ;"23-AM"
	W1	(EOM)		;SAVE TYPE & SIGN RESULT ;"23-AM"
	IOR	(CREPNT)	;CRRNT REG PNTR ;"23-AM"
	IER	(REGEM)		;SET BITS IN LEFT HALF ;"23-AM"
GIRGE2:
	SMK	(REGEM)		;REG EM
	JMPF	(RBTAAL)	;REG BY TYPE ASSIGN AND LOAD
	SMK	(DREEM)	;DO REG EM
	JMPT	(RBTAAL)	;REG BY TYPE ASSIGN AND LOAD
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	SMK	(DITEM)	;DOUBLE ITEM EM
	XITT	(EXIML)	;EXIT
	IPK	(ETYEM)		;"23-AO"
	JMP	(DRGFIN)	;DOUBLE REG GEN FIN
GNIR0G:					;GRNTEE NOT IN REG 0 GEN
	SMK	(RZEEM)	;REG ZERO EM
	XITF	(EXIML)	;EXIT
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
	XW1.0	(FET)		;ZERO RUNG
	SMK	(SUBEM)	;SUBEXP EM
	W1	(SWT)		;W1
	XW1.3T	(STK)		;STATUS PNTR RUNG
	W1	(STO)		;W1
	XW1.0	(ZER)		;ZERO RUNG
	JMP	(RLOGEN)	;REG LOAD GEN
RBTAAL:					;REG BY TYPE ASSIGN AND LOAD
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
RLOGEN:					;REG LOAD GEN
	W1	(FET)		;W1
	JSB	(RSTADV)	;REG STATUS ADVANCE
	W1	(SWT)		;W1
	SON	(DITEM)	;DOUBLE ITEM EM
	JMPF	(SRLGEN)	;SINGLE REG LOAD GEN
	SMK	(DITEM)	;DOUBLE ITEM EM
	JMPT	(DRLGEN)	;DOUBLE REG LOAD GEN
	W1	(FET)		;W1
	IPK	(DITEM)	;DOUBLE ITEM EM
	POW	(D1)		;ONE
	JSB	(SRLGEN)

DRGFIN:					;DOUBLE REG GEN FIN
				;LINE DELETED ;"23-AK"
	SMK	(EREEM)		;EVEN REG? "22X"
	JMPT	(DRGFI1)	;IF EVEN REG CLEAR REG + 1 ;"23-AK"
	SWT	(EOPPNT)	;W0<-EOPPNT,EOPPNT<-TYPE OF ODD REG PNTR ;"23-AK"
	FET	(EOPPNT)	;W0<-ODD REG PNTR,W1<-EOPPNT ;"23-AK"
	JSB	(EIERGE)	;EXPR IN EVEN REG GEN ;"23-AK"
	W1	(SWT)		;W0<-EOPPNT,W1<-EVEN REG PNTR ;"23-AK"
	STO	(EOPPNT)	;RESTORE EOPPNT,W0<-EVEN REG PNTR ;"23-AK"
				;6 LINES DELETED ;"23-AK"
DRGFI1:				;"22X"
	IER	(ETYEM)	;"23-AK"
	W0	(TLY)		;W0
			;LINE DELETED HERE "22D"
	XW0.0	(NOZ)		;ZERO RUNG "22D"
	BRI	(.MEI0)	;SETZ INST "22D"
	W0	(DIM)		;W0
	XIT	(EXIML)	;EXIT
DRLGEN:					;DOUBLE REG LOAD GEN
	SMK	(PLUEM)	;PLUS EM
	SMKF	(DPNEM)	;DOUBLE PREC NEG EM
	BTKT	(.ME0)	;MOVE INST
	BTKF	(.MN0)	;MOVN INST
	SME	(DPNEM)	;DOUBLE PREC NEG EM
	IORT	(MINMAS)	;MINUS MASK
	XIT	(EXIML)	;EXIT
SRLGEN:					;SINGLE REG LOAD GEN
	SMK	(NOTEM)	;NOT EM
	JMPT	(SRLGE1)	;$1
	SMK	(MINEM)	;MINUS EM
	BINT	(.MN0)	;MOVN INST
	BINF	(.ME0)	;MOVE INST
	XIT	(EXIML)	;EXIT
SRLGE1:
	SMK	(MINEM)	;MINUS EM
	BIKT	(.MN0)	;MOVN INST
	W1T	(CLA)		;W1
	BINT	(.SEA0)	;SETCA INST
	BINF	(.SEM0)	;SETCM INST
	XIT	(EXIML)	;EXIT
GR0AGE:					;GRNTEE REG 0 AVAIL GEN
	FET	(RZEPNT)	;REG ZERO PNTR
	IER	(ETYEM)	;EXP TYPE EM
GABTGE:					;GRNTEE AVAILABLE BY TYPE GEN
	SPK	(DITEM)	;DOUBLE ITEM EM
	JMPF	(GAVGE1)	;$1
	JSB	(RMOTES)	;REG MOVE TEST
	XITF	(EXIML)	;EXIT
	STK	(REGTEM)	;REG TEMP
	XW0.0	(FET)		;"23AA"
	AND	(TYPMAS)	;"23AA"
	W1	(IOM)		;"23AA"
	JSB	(DSITGE)	;DOUBLE STORE IN TEMP GEN
	JMP	(GAVGE2)	;$2
RBTASS:					;REG BY TYPE ASSIGN
	XML	(REGSML)	;REG SEARCH
	JMP	(GABTGE)	;GRNTEE AVAILABLE BY TYPE GEN
GAVGEN:					;GRNTEE AVAILABLE GEN
	JSB	(RMOTES)	;REG MOVE TEST
	XITF	(EXIML)	;EXIT
	STK	(REGTEM)	;REG TEMP
	JSB	(SITGEN)	;STORE IN TEMP GEN
GAVGE2:
	CLA	(REGTEM)	;REG TEMP
	XIT	(EXIML)	;EXIT
GAVGE1:
	JSB	(GAVGEN)	;GRNTEE AVAILABLE GEN
	SMK	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	W0	(FET)		;W0
	W0	(TLY)		;W0
	IER	(ITYEM)	;INTEGER TYPE EM
	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
	XML	(P1EML)	;PRUNE ONE EXIT
RSATES:					;REG SAVE TEST
	XW0.0	(FET)		;ZERO RUNG
RSATE1:
	SMK	(SUBEM)	;SUBEXP EM
	XW0.4T	(SNZ)		;USE CNT RUNG
	XMLT	(P1ETML)	;PRUNE ONE EXIT TRUE
	XML	(P1EFML)	;PRUNE ONE EXIT FALSE
SRITGE:					;SAVE REG IN TEMP GEN
	JSB	(RSATES)	;REG SAVE TEST
	JMPT	(GABTGE)	;GRNTEE AVAILABLE BY TYPE GEN
	XIT	(EXIML)	;EXIT

RMOTES:					;REG MOVE TEST
	XW0.0	(SNZ)		;ZERO RUNG
	XITF	(EFAML)	;EXIT FALSE ;"21D"
	SPK	(RHOEM)	;RIGHT HALF ONES EM
	SPKF	(TEMEM)	;TEMP EM
	JMPT	(EXIFAL)	;EXIT FALSE
	XML	(ETRML)	;EXIT TRUE
SITGEN:					;STORE IN TEMP GEN
	JSB	(TEMMAK)	;TEMP MAKER
	SON	(MINEM)	;MINUS EM
	BIKT	(.MNM0)	;MOVNM INST
	BIKF	(.MEM0)	;MOVEM INST
NRSNOT:					;NEW REG STATUS NOTE
	XW1.0	(FET)		;ZERO RUNG
	W0	(FET)		;W0
	AND	(TYPMAS)	;TYPE MASK
	W2	(IOM)		;W2
	W2	(FET)		;GET REG POINTER
	AND	(SIGMAS)	;ISOLATE SIGN
	W2	(EOM)		;COMBINE W/ SIGN OF TEMP. PNTR
	SMK	(SUBEM)	;SUBEXP EM
	XW0.3T	(FET)		;STATUS PNTR RUNG
	ANDT	(SIGMAS)	;SIGN MASK
	W2T	(EOR)		;W2
	XW1.3T	(STO)		;STATUS PNTR RUNG
	POW	(D1)		;ONE
	XW1.0	(STK)		;TEMP PNTR TO REG ROLL
	XML	(TSAML)	;TEMP STATUS ADVANCE
	W1	(SWT)		;W1
	IPK	(ITETRA)
	XML	(P1EML)	;PRUNE ONE EXIT
RSTADV:					;REG STATUS ADVANCE
	SON	(DITEM)	;DOUBLE ITEM EM
	XW1.0	(STK)		;ZERO RUNG
	IORT	(APOMAS)	;ADR PLUS ONE MASK
	XW1.1T	(STK)		;ONE RUNG
	XML	(P1EML)	;PRUNE ONE EXIT
DSITGE:					;DOUBLE STORE IN TEMP GEN
	JSB	(DTEMAK)	;DOUBLE TEMP MAKER
	JSB	(DSTGEN)	;DOUBLE STORE GEN
DSITGF:					;DOUBLE STORE IN TEMP GEN FIN
	W1	(FET)		;W1
	W0	(TLY)		;W0
	W1	(FET)		;W1
	W0	(TLY)		;W0
	JSB	(NRSNOT)	;NEW REG STATUS NOTE
	POW	(D1)		;ONE
	JMP	(NRSNOT)	;NEW REG STATUS NOTE
DSTGEN:					;DOUBLE STORE GEN
	SON	(CTYEM)	;COMPLEX TYPE EM
	SONT	(MINEM)	;MINUS EM
	BTKT	(.MNM0)	;MOVNM INST
	BTKF	(.MEM0)	;MOVEM INST
	SON	(DPNEM)	;DOUBLE PREC NEG EM
	EORT	(MINMAS)	;MINUS MASK
	XIT	(EXIML)	;EXIT

SATREG:						;SAVE THIRD REGISTER
	SMK	(DPTEM)	;DOUBLE PRECISION ?
	XITF	(EXIML)	;NO, RETURN
	STK	(PINATO)	;SAVE FOR TEST
	W1	(FET)		;YES,GET REGISTER TO BE USED
	ADD	(TWO)		;POINT TO THIRD REGISTER
	IER	(PLUEM)		;INSURE POSITIVE REG PNTR "22E"
	SMK	(PINEM)		;ADDRESS & REG TO BE SAVED THE SAME ?
	IER	(PLUEM)		;MAKE SURE IT'S POSITIVE ;"21S"
	JSB	(GABTGE)	;SAVE THIS REGISTER
	W1T	(SWT)		;YES, DON'T USE TEMP POINTER
	ANDT	(SANMAS)	;TRANSFER SIGN AND .NOT. FLAGS
	W1T	(IOM)
	POWF	(D1)		;REMOVE EXTRA REG POINTER
	XIT	(EXIML)		;RETURN
MPOGEN:					;MOVEM POSITIVE GEN
	SON	(DPNEM)	;DOUBLE PREC NEG EM
	JSBT	(DPNSGE)	;DOUBLE PREC NEG STORE GEN
	XMLT	(P1EML)	;PRUNE ONE EXIT
	SON	(MINEM)	;MINUS EM
	BTYT	(.MNM0)	;MOVNM INST
	BTYF	(.MEM0)	;MOVEM INST
	XIT	(EXIML)	;EXIT

DPNSGE:					;DOUBLE PREC NEG STORE GEN

	SNZ	(PDPSW)	;TEST MACHINE TYPE
	JMPT	(DPNSG1)	;A PDP-10 !
	BTK	(.MNM0)	;MOVNM INST
	W1	(FET)		;W1
	FET	(ABSCPN)	;ALL BUT SIGN CONST PNTR
	W1	(TLY)		;W1
	BIN	(.TDNE0)	;TDNE INST
	POW	(D1)		;ONE
	BAK	(.SOS0)	;SOS INST
	XIT	(EXIML)

DPNSG1:
	W1	(FET)
	W0	(FET)
IFNDEF HARDFL,<							; *EJG* 06/23/76
	W0	(TLY)
	BIN	(.DFN0)	;DFN INST
>								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	BIN	(.DMVN0)	;DMOVN INST			; *EJG* 06/23/76
>								; *EJG* 06/23/76
	POW	(D1)
	BTK	(.MEM0)	;MOVEM INST

	FET	(MINMAS)
	W2	(EOM)
	XW1.0	(FET)
	SMK	(SUBEM)
	FETT	(MINMAS)
	XW1.3T	(EOM)
	POW	(D1)

	XIT	(EXIML)
DTEMAK:					;DOUBLE TEMP MAKER
	JSB	(TEMMAK)	;TEMP MAKER
	W1	(FET)
	AND	(TYPMAS)
	W1	(IOM)
	JSB	(TEMMAK)	;TEMP MAKER
	XML	(P1EML)	;PRUNE ONE EXIT
TEMMAK:					;TEMP MAKER

	TLY	(LTEPNT)	;LOCAL TEMP PNTR
	FET	(LTEPNT)	;LOCAL TEMP PNTR
	SGK	(LATPNT)	;LAST ASSIGNED TEMP PNTR
	STKT	(LATPNT)	;LAST ASSIGNED TEMP PNTR
	XIT	(EXIML)	;EXIT
PTEMAK:					;PERM TEMP MAKER
	TLY	(TEMCNT)	;TEMP CNT
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	IER	(DMYEM)	;DMY EM
	XIT	(EXIML)	;EXIT

VARSCA:					;VAR SCAN
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)	;SCALAR EM
	XITT	(EXIML)	;EXIT
	SMK	(ARREM)	;ARRAY ID EM
	LCFF	(I12QT)	;ID CONFLICT QT
	CSA	(LPAREN)	;L PAREN
	JMPT	(AREXLA)	;ARRAY REF XLATE
	LCFF	(S14QT)	;SYNTAX QT
	XIT	(EXIML)	;EXIT
IVASCA:					;INDUC VAR SCAN
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
IVSFIN:					;INDUC VAR SCAN FIN
	SMK	(ITYEM)	;INTEGER TYPE EM
	LCFF	(S18QT)	;TYPE QT ;"21T"
	SMK	(SCAEM)	;SCALAR EM
	LCFF	(I14QT)	;ID CONFLICT QT
	XIT	(EXIML)	;EXIT
IDSCAN:					;ID SCAN
	JSB	(SYMSCA)	;SYMBOL SCAN
IDCLAS:					;ID CLASSIFY
	ISE	(LDMFIL)	;LOCAL DMY FILE
	ISEF	(GSPFIL)	;GLOBAL SPROG FILE
	ISEF	(SCAFIL)	;SCALAR FILE
	ISEF	(ARRFIL)	;ARRAY FILE
	ISEF	(LSPFIL)	;LOCAL SPROG FILE
	JMPF	(EXIFAL)	;EXIT FALSE
	FPC	(CREPNT)	;CRRNT REG PNTR
	JSB	(TYPSET)	;TYPE SET
	XML	(ETRML)	;EXIT TRUE
TYPSET:					;TYPE SET
	JSB	(TYPEVA)	;TYPE EVAL
	XITT	(EXIML)	;EXIT
	XML	(ICFSSE)	;IMPLICIT CLUE FROM SYMBOL SET

IFNDEF	$IMPL,
<
	ISE	(IMPFIL)	;IMPLICIT FILE
	XNIT	(CREPNT)	;CRRNT REG PNTR
	FETT	(ZERRUN)	;ZERO RUNG
	JMPT	(ITYSE1)	;$1
>
	FET	(IMPCLU)	;IMPLICIT CLUE
	SGK	(MAXSYM)	;MAX INTEGER SYMBOL
	SLKF	(MINSYM)	;MIN INTEGER SYMBOL
	CLAT	(RTYSTA)	;REAL TYPE ATOM
	CLAF	(ITYSTA)	;INTEGER TYPE ATOM
ITYSE1:
	SMK	(SINEM)	;SUBSCRIPT INTEGER EM
	IERT	(ITYEM)	;INTEGER TYPE EM
	REGT	(SIIFIL)	;SUBSCRIPT INTEGER ID FILE
	STO	(ETYATO)	;EXP TYPE ATOM
	IER	(ETYEM)	;EXP TYPE EM
	XIT	(EXIML)	;EXIT
STYEVA:					;SYMBOL TYPE EVAL
	JSB	(SYMSCA)	;SYMBOL SCAN
TYPEVA:					;TYPE EVAL
	ISE	(CIDFIL)	;COMPLEX ID FILE
	IERT	(CTYEM)	;COMPLEX TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(DPIFIL)	;DOUBLE PREC ID FILE
	IERT	(DPTEM)	;DOUBLE PREC TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(RIDFIL)	;REAL ID FILE
	IERT	(RTYEM)	;REAL TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(LIDFIL)	;LOGICAL ID FILE
	IERT	(LTYEM)	;LOGICAL TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(IIDFIL)	;INTEGER ID FILE
	IERT	(ITYEM)	;INTEGER TYPE EM
	XIT	(EXEQML)	;EXIT EQUAL ML
CONSCA:					;CONST SCAN
	JSB	(CONANA)	;CONST ANALYSIS
	SMK	(RTYEM)	;REAL TYPE EM
	JMPF	(DCAREG)	;DP CHECK AND REGISTER
RFLCON:					;REGISTER FL CONST
	REG	(RCOFIL)	;REAL CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
DCAREG:					;DP CHECK AND REGISTER
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	JMPF	(CCAREG)	;CPLX CHECK AND REGISTER
RDPCON:					;REGISTER DP CONST
	REG	(DPCFIL)	;DOUBLE PREC CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
CCAREG:					;CPLX CHECK AND REGISTER
	SMK	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(ICAREG)	;INT CHECK AND REGISTER
RCOCON:					;REGISTER COMPLEX CONST
	REG	(CCOFIL)	;COMPLEX CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
ICAREG:					;INT CHECK AND REGISTER
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(LCAREG)	;LOG CHECK AND REGISTER
RINCON:					;REGISTER INT CONST
	REG	(ICOFIL)	;INTEGER CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
LCAREG:					;LOG CHECK AND REGISTER
	SMK	(LTYEM)	;LOGICAL TYPE EM
	JMPT	(FEREXI)	;FIRST ELEM RESET EXIT
HCAREG:					;HOLLERITH CHECK AND REGISTER
	SMK	(HTYEM)		;HOLLERITH TYPE EM
	JMPF	(OCAREG)
	SNZ	(SARFLA)
	FETT	(ZERO)		;GET USER END FLAG
	MONT	(CTEROL)	;STORE AT END OF STRING
	EAW	(CTEROL)	;CONST TEMP ROLL
	RPL	(HCOROL)	;HOL CONST ROLL
	REL	(CTEROL)
	W1	(IOM)		;W1
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT
OCAREG:					;OCTAL CHECK AND REGISTER
	REG	(OCOFIL)	;OCT CONST FILE
CREEXI:					;CONST REGISTER EXIT
	FET	(CREPNT)	;GET REG PNTR
	AND	(RHAMAS)	;CLEAR UPPER
	W1	(IOM)		;SET POINTER IN W1
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT
RWOCON:					;REGISTER WORK CONST
	STO	(DAT1)	;DATA 1
	REG	(ICOFIL)	;INTEGER CONST FILE
	FET	(CREPNT)
	XIT	(EXIML)	;EXIT
REGSCA:					;REGISTER SCALAR
	PNG	(SCAROL)	;SCALAR ROLL
	AGF	(SCAFIL)	;SCALAR FILE
SETPOS:					;SET POSITION
	W0	(FPC)		;W0
	W1	(STO)		;W1
	JMP	(TYPSET)	;TYPE SET
RGLSPR:					;REGISTER GLOBAL SPROG
	ISE	(CDAFIL)	;COMMON DATA FILE
	FPCT	(ZERO)	;ZERO
	ERMT	(I16QT)		;CONFLICT W/ COMMON DECLARATION	;"23A"
	XITT	(FAIML)		;FATAL ERROR	;"23A"
	PNGF	(GSPROL)	;GLOBAL SPROG ROLL
	AGFF	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(SETPOS)	;SET POSITION
CONANA:					;CONST ANALYSIS
	JSB	(DCOINI)	;DIGIT CONV INITIAL
	SCK	(DIGKEY)	;DIGIT KEY
	JMPT	(NOHCSC)	;NUM OR HOL CONST SCAN
	CSA	(PERIOD)	;PERIOD
	JMPT	(RDOLCS)	;REAL DBL OR LOG CONST SCAN
	CSA	(LPAREN)	;L PAREN
	JMPT	(CCOSCA)	;COMPLEX CONST SCAN
	SCE	(SNGLQT)	;QT
	JMPT	(EHCSCA)	;ENCLOSED HOL CONST SCAN
OCOSCA:					;OCTAL CONST SCAN
	CSA	(O)
	CSFF	(DBLQT)	;DBL QT
ODISCA:					;OCTAL DIGIT SCAN
	FET	(OTYSTA)	;OCTAL TYPE STAMP
	CSA	(MINUS)	;MINUS
	IERT	(MINEM)	;MINUS EM
	CSAF	(PLUS)	;PLUS
	SCK	(DIGKEY)
	CCFF	(S11QT)
	JSB	(COCNPL)
	W0	(FPC)
	W1	(STO)
	JMP	(CSIEX1)	;CONST SINGLE EXIT
NOHCSC:					;NUM OR HOL CONST SCAN
	JSB	(DICOSC)	;DIGIT CONV SCAN
	SCE	(H)		;H
	JMPT	(HCOSCA)	;HOL CONST SCAN
	SCK	(DOEKEY)	;D OR E
	JMPT	(RODCSF)	;REAL OR DBL CONST SCAN FIN
	JSB	(LAPSAV)	;LOOK AHEAD POSITION SAVE
	SCE	(PERIOD)	;PERIOD
	JSBT	(OPCHEC)	;OP CHECK
	CSFT	(PERIOD)	;PERIOD
	JMPT	(RODCSF)	;REAL OR DBL CONST SCAN FIN
	JSB	(LAPRES)	;LOOK AHEAD POSITION RESET
	FET	(ITYSTA)	;INTEGER TYPE STAMP
CSIEXI:					;CONST SINGLE EXIT
	W0	(FPC)		;W0
	SNZ	(MAC1)	;MP AC 1
	ERKT	(M3QT)	;CONST OVFLO QT
	W1	(STO)		;W1
	FET	(MAC2)	;MP AC 2
	STO	(DAT1)	;DATA 1
CSIEX1:
	ZER	(DAT2)	;DATA 2
	XML	(ETRML)	;EXIT TRUE
RDOLCS:					;REAL DBL OR LOG CONST SCAN
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(LCOSCA)	;LOG CONST SCAN
RODCSF:					;REAL OR DBL CONST SCAN FIN
	FET	(NDISCA)	;NUM DIGITS SCANNED
	STO	(NUNPOS)	;NUM UNIT POSITIONS
	SCK	(DIGKEY)	;DIGIT KEY
	JSBT	(DICOSC)	;DIGIT CONV SCAN
	FET	(NUNPOS)	;NUM UNIT POSITIONS
	SUB	(DUSCNT)	;DIGITS USED CNT
	STK	(EXPONE)	;EXPONENT
	SLT	(ZERO)	;ZERO
	FTM	(EXPA)	;EXPONENT A
	CSA	(D)		;D
	JMPT	(RODCS1)	;$1
	CSA	(E)		;E
	JMPF	(RODCS2)	;$2
	SNZ	(ZERO)	;ZERO
RODCS1:
	PST	(CONTEM)	;CONST TEMP
	JSB	(SINSCA)	;SIGNED INTEGER SCAN
	PAD	(EXPA)	;EXPONENT A
	PST	(EXPA)	;EXPONENT A
	PLD	(CONTEM)	;CONST TEMP
RODCS2:
	XML	(FCMML)	;FL CONST MAKER
	FETT	(DPTSTA)	;DOUBLE PREC TYPE STAMP
	FETF	(RTYSTA)	;REAL TYPE STAMP
	W0	(FPC)		;W0
	W1	(STO)		;W1
	PST	(DAT1)	;DATA 1
	FET	(EXPONE)	;EXPONENT
	SGT	(MAXEXP)	;MAX EXPONENT
	ERKT	(M3QT)	;CONST OVFLO QT
	XML	(ETRML)	;EXIT TRUE
LCOSCA:					;LOG CONST SCAN
	QSA	(NOTQT)	;NOT.. QT
	JMPT	(LCOSC1)	;$1
	QSA	(TRUQT)	;TRUE. QT
	QSFF	(FALQT)	;FALSE. QT
	FETT	(TCOPNT)
	FETF	(FCNPNT)	;FALSE CONST PNTR
	FTM	(DAT1)	;DATA 1
	IER	(LTYEM)	;LOGICAL TYPE EM
	JMP	(EXIFAL)	;EXIT FALSE
LCOSC1:	JSB	(LCOSCA)	;LOG CONST SCAN
	EOR	(LCIMAS)	;LOG CONST INVERT MASK
	NOT	(DAT1)	;DATA 1
	JMP	(EXIFAL)	;EXIT FALSE
CCOSCA:					;COMPLEX CONST SCAN
	JSB	(SCOSCA)	;SIGNED CONST SCAN
	LCFF	(S23QT)		;SYNTAX QT	;"23N"
CCSFIN:					;COMPLEX CONST SCAN FIN
	JSB	(CTOFL)	;CONVERT TO FL
	CSF	(COMMA)	;COMMA
	JSB	(SCOSCA)	;SIGNED CONST SCAN
	LCFF	(S1QT)	;SYNTAX QT
	JSB	(CTOFL)	;CONVERT TO FL
	CSF	(RPAREN)	;R PAREN
	STO	(DAT2)	;DATA 2
	STO	(DAT1)	;DATA 1
	FPC	(CTYSTA)	;COMPLEX TYPE STAMP
	JMP	(EXIFAL)	;EXIT FALSE
SCOSCA:					;SIGNED CONST SCAN
	CSA	(MINUS)	;MINUS
	JMPF	(SCOSC1)	;$1
	JSB	(CONANA)	;CONST ANALYSIS
	NOT	(DAT1)	;DATA 1
	TLY	(DAT1)	;DATA 1
	XIT	(EXEQML)	;EXIT EQUAL ML
SCOSC1:
	CSA	(PLUS)	;PLUS
	JMP	(CONANA)	;CONST ANALYSIS
CTOFL:					;CONVERT TO FL
	SMK	(ITYEM)	;INTEGER TYPE EM
	FET	(DAT1)	;DATA 1
	JMP	(CCAASI)	;CONVERT CONST AND ADJUST SIGN
DCOINI:					;DIGIT CONV INITIAL
	EAW	(D10)		;TEN
	STO	(CBABOX)	;CONST BASE BOX
	PLD	(MPZERO)	;MP ZERO
	PST	(EXPA)	;EXPONENT A
	ZER	(NDISCA)	;NUM DIGITS SCANNED
	ZER	(NUNPOS)	;NUM UNIT POSITIONS
	ZER	(DUSCNT)	;CLEAR DIGITS USED CNT
	XIT	(EXIML)	;EXIT
DICOSC:					;DIGIT CONV SCAN
	SCK	(DIGKEY)	;DIGIT KEY
	CCFF	(S11QT)	;SYNTAX QT
	XIT	(CDAAML)	;CONV DIGIT AND ADV
EHCSCA:					;ENCLOSED HOL CONST SCAN
	RSV	(CTEROL)	;CONST TEMP ROLL
	JSB	(PHCSET)
EHCSC1:
	JSB	(NINCHA)
	SCE	(SNGLQT)
	JMPT	(EHCSC3)
EHCSC2:
	JSB	(PHCTST)
	JMP	(EHCSC1)

EHCSC3:
	JSB	(NINCHA)
	SCE	(SNGLQT)
	JMPT	(EHCSC2)
	SCE	(SPACE)
	JSBT	(NEXCHA)
	JMP	(HCOSC3)

HCOSCA:					;HOL CONST SCAN
	SNZ	(MAC1)	;MP AC 1
	FETF	(MAC2)	;MP AC 2
	SGKF	(MHOCNT)	;MAX HOL CNT
	LCFT	(ECOQT)	;EXCESSIVE COUNT QT
	RSV	(CTEROL)	;CONST TEMP ROLL
	JSB	(PHCSET)

HCOSC1:
	JOW	(HCOSC2)	;$2
	JSB	(NINCHA)
	JSB	(PHCTST)
	JMP	(HCOSC1)	;$1

HCOSC2:
	JSB	(NEXCHA)
HCOSC3:
	FET	(HTYSTA)	;HOLLERITH TYPE STAMP

PHCEND:
	FET	(HBUIND)
	SEQ	(HBUINI)
	JSBF	(PHCMON)
	CNT	(CTEROL)	;COUNT # OF WORDS USED ;"21M"
	SEQ	(ZERO)		;NONE USED ? ;"21M"
	LCFT	(M7QT)		;YES, ITS ILLEGAL ;"21M"
	JMP	(EXIFAL)

PHCTST:
	SCE	(CRR)
	LCFT	(M7QT)
PHCHAR:
	XML	(PHCML)
	XITT	(EXIML)
PHCMON:
	FET	(HOLBUF)
	MON	(CTEROL)
PHCSET:
	FET	(HBUINI)
	STO	(HBUIND)
	FET	(ASCIBL)
	STO	(HOLBUF)
	XIT	(EXIML)
SISUSC:					;SIGNED SUBSCRIPT SCAN

	JSB	(SINSCA)	;SIGNED INTEGER SCAN
	FET	(DAT2)	;DATA 2
	XIT	(EXIML)	;EXIT
SINSCA:					;SIGNED INTEGER SCAN
	CSA	(MINUS)	;MINUS
	JMPF	(SINSC1)	;$1
	JSB	(INTSCA)	;INTEGER SCAN
	FET	(ZERO)	;ZERO
	SNZ	(DAT2)	;DATA 2
	NOTT	(DAT1)	;DATA 1
	SUB	(DAT2)	;DATA 2
	STO	(DAT2)	;DATA 2
	XIT	(EXIML)	;EXIT
SINSC1:
	CSA	(PLUS)	;PLUS
INTSCA:					;INTEGER SCAN
	ZER	(NDISCA)	;NUM DIGITS SCANNED
	PLD	(MPZERO)	;MP ZERO
	JSB	(DICOSC)	;DIGIT CONV SCAN
	SNZ	(CON1)	;CONST 1
	LCET	(M3QT)	;OVERFLOW QT
	XIT	(EXIML)	;EXIT
FESACO:					;FX EXP SCAN AND COLLAPSE
	JSB	(EXPSCA)	;EXP SCAN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(SUBFAI)	;SUBEXP FAIL
	JMP	(SUBCOL)	;SUBEXP COLLAPSE

LBLSCA:					;LBL SCAN
	JSB	(DCOINI)	;DIGIT CONV INITIALIZE
	JSB	(INTSCA)	;INTEGER SCAN
	FET	(DAT2)	;DATA 2
	SGK	(MLBALL)	;MAX LBL ALLOWED
	LCFT	(M6QT)	;NUMBER QT
	W0	(SNZ)		;W0
	LCFF	(M6QT)	;NUMBER QT
	POW	(D1)		;PRUNE LABEL NUMBER
	REG	(LBLFIL)	;LABEL FILE
	FPC	(CREPNT)	;CRRNT REG PNTR
	SMK	(SLPEM)		;"23-AP"
	CCFT	(M19QT)		;"23-AP"
IFNDEF	$CREF,
<
	SNZ	(CRFSW)
	FETT	(DAT2)
	XMLT	(BTOBCD)
	MONT	(CRFROL)
>
	XIT	(EXIML)	;EXIT

LBLMAK:					;LBL MAKER
	TLY	(MLBCNT)	;MADE LBL CNT
	FET	(MLBCNT)	;MADE LBL CNT
	IER	(MLBEM)	;MADE LBL EM
	XIT	(EXIML)	;EXIT
FINUP:					;FINISH UP

IFNDEF	FILE0,
<
	SNZ	(PROGN)	;NON-TRIVIAL PROGRAM FLAG
	XITF	(POPOUT)	;EXIT TO EXEC
>
	JSB	(SCACLO)
	JSB	(OUTCOD)

IFNDEF	$NAME,
<
	JSB	(NAMGEN)	;NAMELIST GEN
>
	REL	(ASTROL)	;ARRAY STAT ROLL
	ZER	(MACSW)	;ONLY SUPRESS CODE
	POC	(EOPLOP)	;END OF PROGRAM LOP
	FET	(MSTLOC)	;MAIN START LOC
	MON	(CODROL)	;CODE ROLL
	FET	(TEMCNT)	;TEMP CNT
	W0	(FET)		;W0
	FET	(LATPNT)	;LAST ASSIGNED TEMP POINTER
	AND	(DISMAS)	;DISPLAY MASK
	W0	(SWH)		;W0
	W1	(IOM)		;W1
	MON	(CODROL)	;CODE ROLL
	JSB	(PDASTA)	;PUNCH DATA STA
	JSB	(OCOPOO)	;OUTPUT CONST POOL
	ADD	(LATPNT)	;LAST ASSIGNED TEMP PNTR
	AND	(DISMAS)	;DISPL MASK
	AMY	(LOCCNT)	;LOC CNTR
	JSB	(COMALL)	;COMMON ALLOCATION
	JSB	(ALLOEQ)	;ALLOC EQUIV
	JSB	(PGAROL)	;PUBLISH GENERAL ALLOC ROLL
	JSB	(OGSROL)	;OUTPUT GLOBAL SPROG ROLL
	JSB	(AAPSAA)	;ALLOCATE AND PUBLISH SCALARS AND ARRAY
	FET	(LOCCNT)	;LOC CNTR
	SUB	(PROBRE)	;PROGRAM BREAK
	JSB	(OOAREF)	;OUTPUT OBJECT ARRAY REF
	MON	(CODROL)	;CODE ROLL
	JSB	(OCOARE)	;OUTPUT COMMON AREA
	NOZ	(ERRFLA)	;ERRORS FLAG
	JSB	(PDLERR)	;PUBLISH DO LOOP ERRORS
	JSB	(PLBERR)	;PUBLISH LBL ERRORS
	JSB	(PALERR)	;PUBLISH ALLOCATION ERROR
	XIT	(POPOUT)	;EXIT TO EXEC
OCOPOO:					;OUTPUT CONST POOL
	REL	(ICOROL)	;INTEGER CONST ROLL
	REL	(FCOROL)	;FLOATING CONST ROLL
	REL	(OCOROL)	;OCT CONST ROLL
	REL	(HCOROL)	;HOLLERITH CONST ROLL
	REL	(DPCROL)	;DOUBLE PREC CONST ROLL
	REL	(CCOROL)	;COMPLEX CONST ROLL
	CNT	(CPOROL)	;CONST POOL ROLL
	W0	(FET)		;W0
	ADD	(LOCCNT)	;LOC CNTR
	ADD	(ONE)		;ONE
	STK	(LOCCNT)	;LOC CNTR
	STO	(PROBRE)	;PROGRAM BREAK
	MON	(CODROL)	;CODE ROLL
	SRD	(CPOROL)	;CONST POOL ROLL
	PRQT	(CONSQT)	;CR CONST DCR QT
	ZER	(COPRCT)	;CONST PRINT COUNT
	FLP	(CPOROL)	;CONST POOL ROLL
OCOPO1:					;$1
	MOA	(CPOROL)	;CONST POOL ROLL
	JSBF	(COLEND)	;FINISH LINE
	JMPF	(PDASTA)	;PUNCH DATA STATEMENT
	W0	(FET)		;W0
	FET	(COPRCT)	;CONST PRINT COUNT
	JSB	(POCLOC)	;PRINT OCTAL LOCATION
	TLY	(COPRCT)	;CONST PRINT COUNT
	PRC	(TAB)		;OP FIELD POSITION
	JSB	(PW0OCT)	;PRINT W0 OCTAL
	PCOL	(ZERO)	;PRINT COLUMNS
	MON	(CODROL)	;CODE ROLL
	JMP	(OCOPO1)	;$1
COMALL:					;COMMON ALLOCATION
	FLP	(CDAROL)	;COMMON DATA ROLL
	FLP	(CNAROL)	;COMMON NAMES ROLL
COMAL1:
	MOA	(CNAROL)	;COMMON NAMES ROLL
	XITF	(EXIML)	;EXIT
	STO	(CANCLU)	;COMMON AREA NAME CLUE
	REG	(CANFIL)	;COMMON AREA NAME FILE
	JSB	(ATCARE)	;ADD TO COMMON AREA
	JMP	(COMAL1)	;$1
ATCARE:					;ADD TO COMMON AREA
	MOA	(CDAROL)	;COMMON DATA ROLL
	SEK	(ZERO)	;MARKER SYMBOL
	XMLT	(P1EML)	;PRUNE ONE EXIT
	JSB	(CSACLA)	;CALC SIZE AND CLASSIFY
	XNI	(CARPNT)	;COMMON AREA PNTR
	SWT	(CASRUN)	;COMMON AREA SIZE RUNG
	W0	(FET)		;W0
	XNI	(CARPNT)	;COMMON AREA PNTR
	AMY	(CASRUN)	;COMMON AREA SIZE RUNG
	FET	(CARPNT)	;COMMON AREA PNTR
	AND	(DISMAS)	;DISPL MASK
	W0	(SWH)		;W0
	W1	(IOM)		;W1
	STO	(DAT1)	;DATA 1
	PNG	(GALROL)	;GENERAL ALLOC ROLL
	IER	(APNEM)	;ALLOC PNTR EM
	AGF	(GALFIL)	;GENERAL ALLOC FILE
	JSB	(IDCLAS)	;ID CLASSIFY
	W1	(SWT)		;W1
	XW1.0	(STO)		;ZERO RUNG
	POW	(D2)		;TWO
	JMP	(ATCARE)	;ADD TO COMMON AREA
CSACLA:					;CALC SIZE AND CLASSIFY
	STO	(SYMBOL)	;SYMBOL
CSACFI:					;CALC SIZE AND CLASSIFY FIN
	ISE	(GANFIL)	;GENERAL ALLOC NAME FILE
	FETT	(CREPNT)	;CRRNT REG PNTR
	IERT	(ENPEM)	;EQUIV NAME PNTR EM
	FET	(ZERO)	;ZERO
	JSB	(TYPSET)	;TYPE SET
	W1T	(SWT)		;W1
	STOT	(SYMBOL)	;SYMBOL
	JSB	(IDCLAS)	;ID CLASSIFY
	JSBF	(REGSCA)	;REGISTER SCALAR
	AND	(RHAMAS)	;RIGHT HALF MASK
	W1	(IOM)		;W1
	SMK	(ARREM)	;ARRAY ID EM
	XW0.2T	(FET)		;ARRAY SIZE RUNG
	FETF	(ONE)		;ONE
	SON	(DITEM)	;DOUBLE ITEM EM
	W1	(SWT)		;W1
	CLA	(SYMBOL)	;SYMBOL
	W1	(SWT)		;W1
	W0T	(ADD)		;W0
	XIT	(EXEQML)	;EXIT EQUAL ML

COLEND:						;COLUMN END
	SNZ	(REGSAV)	;LAST COLUMN PRINTED ?
	PRCT	(CRR)		;NO, END THE LINE
	ZER	(REGSAV)	;RESET COLUMN COUNTER
	XIT	(EXIML)	;RETURN
ALLOEQ:					;ALLOC EQUIV
	SRD	(EDAROL)	;EQUIV DATA ROLL
	XITF	(EXIML)	;EXIT
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	EAW	(D0)		;INTEGRATE INTO COMMON
	EAW	(ETEROL)	;EQUIV TEMP ROLL
	EAW	(EDAROL)	;EQUIV DATA ROLL
	JSB	(INISEG)	;INITIALIZE SEGS
	JSB	(REMNES)	;REMOVE NEST
	EAW	(ENEFIL)	;EQUIV NEST FILE
	W4	(STO)		;W4
	W2	(NOZ)
ALLEQ1:
	W1I	(SRD)		;W1
	JSBT	(LSARNE)	;LOAD SEG AND REMOVE NEST
	JMPT	(ALLEQ1)	;$1
	POW	(D4)		;FOUR
	XIT	(EXIML)	;EXIT
ALLNES:					;ALLOCATE NEST
ALLNE1:
	MOA	(ENEROL)	;EQUIV NEST ROLL
	JMPF	(ALLNE2)	;$2
	SUB	(MINBOX)	;MIN REL BOX
	ADD	(LOCCNT)	;LOC CNTR
	STO	(DAT1)	;DATA 1
	MOA	(ENEROL)	;EQUIV NEST ROLL
	STO	(SYMBOL)	;SYMBOL
	PNG	(GALROL)	;GENERAL ALLOC ROLL
	IER	(APNEM)	;ALLOC PNTR EM
	AGF	(GALFIL)	;GENERAL ALLOC FILE
	JSB	(IDCLAS)	;ID CLASSIFY
	W1	(SWT)		;W1
	XW1.0	(STO)		;ZERO RUNG
	POW	(D1)		;ONE
	JMP	(ALLNE1)	;$1
ALLNE2:
	REL	(ENEROL)	;EQUIV NEST ROLL
	FET	(MAXBOX)	;MAX REL BOX
	SUB	(MINBOX)	;MIN REL BOX
	AMY	(LOCCNT)	;LOC CNTR
	XIT	(EXIML)	;EXIT
INISEG:					;INITIALIZE SEGS
	FLP	(EDAROL)	;EQUIV DATA ROLL
INISE1:
	SRD	(EDAROL)	;EQUIV DATA ROLL
	XITF	(EXIML)	;EXIT
	RSV	(ENEROL)	;EQUIV NEST ROLL
	FET	(MOSPOS)	;MOST POSITIVE
	STK	(MINBOX)	;MIN REL BOX
	ZER	(MAXBOX)	;MAX REL BOX
	SMY	(MAXBOX)	;MAX REL BOX
INISE3:
	LGA	(EDAROL)	;EQUIV DATA ROLL
	JMPF	(INISE4)	;$4
	JSB	(CSACFI)	;CALC SIZE AND CLASSIFY FIN
	FETT	(DAT1)	;DATA 1
	AMYT	(DAT1)	;DATA 1
	ADD	(DAT1)	;DATA 1
	JSB	(MOVBOU)	;MOVE BOUNDS
	CLA	(DAT1)	;DATA 1
	JSB	(MOVBOU)	;MOVE BOUNDS
	JSB	(IDCLAS)	;ID CLASSIFY
	IER	(ENPEM)	;EQUIV NAME PNTR EM
	STO	(SYMBOL)	;SYMBOL
	AGF	(ENEFIL)	;EQUIV NEST FILE
	JMP	(INISE3)	;$3
INISE4:
	FET	(MAXBOX)	;MAX REL BOX
	MON	(ETEROL)	;EQUIV TEMP ROLL
	FET	(MINBOX)	;MIN REL BOX
	MON	(ETEROL)	;EQUIV TEMP ROLL
	EAW	(ETEROL)	;EQUIV TEMP ROLL
	CAR	(ENEROL)	;EQUIV NEST ROLL
	AGF	(ETEFIL)	;EQUIV TEMP FILE
	JMP	(INISE1)	;$1
LSARNE:					;LOAD SEG AND REMOVE NEST
	W1	(SWT)
	W0I	(FLP)
	W0I	(MOA)
	W1I	(MOA)
	ZER	(TPOBOX)	;TIE POINT BOX
	SMY	(TPOBOX)	;TIE POINT BOX
	ADD	(TPOBOX)	;TIE POINT BOX
	STO	(MAXBOX)	;MAX REL BOX
	ZER	(MINBOX)	;MIN REL BOX
	EAW	(ENEFIL)	;EQUIV NEST FILE
	JSB	(IRESOU)	;INTEGRATE REM SOURCE
	ZER	(HITCNT)	;HITS CNTR
	JSB	(RNEFIN)	;REMOVE NEST FIN
	JMP	(ALLNES)	;ALLOCATE NEST
REMNES:					;REMOVE NEST
	W1I	(SRD)
	XITF	(EXIML)	;EXIT
	W1I	(FLP)
	W1	(SWT)
	ZER	(HITCNT)	;HITS CNTR
RNECON:					;REMOVE NEST CONTINUE
	W0I	(MOA)
	STK	(SMABOX)	;SEG MAX BOX
	W2I	(MON)
	W0I	(MOA)
	STK	(SMIBOX)	;SEG MIN BOX
	W2I	(MON)
	JSB	(SEASEG)	;SEARCH SEG
	JMPF	(RNEFIN)
	TLY	(HITCNT)	;HITS CNTR
	W2	(SNZ)
	JSBF	(IINCOM)
	JSBT	(IINNES)
RNEFIN:					;REMOVE NEST FIN
	W0I	(SRD)
	JMPT	(RNECON)	;REMOVE NEST CONTINUE
	SNZ	(HITCNT)	;HITS CNTR
	XITF	(EXIML)	;EXIT
	JMP	(REMNES)	;REMOVE NEST
SEASEG:					;SEARCH SEG
SEASE1:
	W0I	(LGA)
	FET	(SYMBOL)	;SYMBOL
	W2I	(MON)
	FET	(DAT1)	;DATA 1
	W2I	(MON)
	JMPF	(EXIFAL)	;EXIT FALSE
	XNI	(SYMBOL)	;SYMBOL
	FET	(ZERRUN)	;ZERO RUNG
	SMK	(APNEM)	;ALLOC PNTR EM
	STOT	(CREPNT)	;CRRNT REG PNTR
	XMLT	(ETRML)	;EXIT TRUE
	STO	(SYMBOL)	;SYMBOL
	W3I	(ISE)
	JMPF	(SEASE1)	;$1
	XML	(ETRML)	;EXIT TRUE
IINCOM:					;INTEGRATE INTO COMMON
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(ONERUN)	;ONE RUNG
	AND	(RHAMAS)	;RIGHT HALF MASK
	SUB	(DAT1)	;DATA 1
	ADD	(SMIBOX)	;SEG MIN BOX
	SLK	(ZERO)	;ZERO
	XNIT	(CREPNT)	;CRRNT REG PNTR
	FETT	(ONERUN)	;ONE RUNG
	XMLT	(MCAPML)	;MAKE COMMON AREA PNTR
	XW0.0T	(CLA)		;ZERO RUNG
	MONT	(AERROL)	;ALLOC ERROR ROLL
	SUB	(SMIBOX)	;SEG MIN BOX
	AMY	(SMABOX)	;SEG MAX BOX
	JSB	(ACBSIZ)	;ADV COMMON BLOCK SIZE
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	JMP	(INTFIN)	;INTEGRATE FIN
IINNES:					;INTEGRATE INTO NEST
	FET	(SMIBOX)	;SEG MIN BOX
	JSB	(SAMBOU)	;SET AND MOVE BOUNDS
	FET	(SMABOX)	;SEG MAX BOX
	JSB	(SAMBOU)	;SET AND MOVE BOUNDS
	EAW	(ENEFIL)	;EQUIV NEST FILE
INTFIN:					;INTEGRATE FIN
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(ONERUN)	;ONE RUNG
	SUB	(DAT1)	;DATA 1
	STO	(TPOBOX)	;TIE POINT BOX
	W2I	(MOA)		;W2
	W3I	(MOA)		;W3
	POW	(D2)		;TWO
INTFI1:
	W2I	(MOA)		;W2
	W3I	(MOA)		;W3
	SMK	(ENPEM)	;EQUIV NAME PNTR EM
	POWF	(D2)		;TWO
	JMPF	(IRESOU)	;INTEGRATE REM SOURCE
	XW0.0	(FET)		;ZERO RUNG
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	W4	(SEQ)		;W4
	PNGT	(GALROL)	;GENERAL ALLOC ROLL
	IERT	(APNEM)	;ALLOC PNTR EM
	XW2.0T	(STO)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	POW	(D1)		;ONE
	ADD	(TPOBOX)	;TIE POINT BOX
	STO	(DAT1)	;DATA 1
	W0I	(AGF)		;W0
	JMP	(INTFI1)	;$1
IRESOU:					;INTEGRATE REM SOURCE
IRESO1:
	W1I	(LGA)
	XMLF	(P1EML)	;PRUNE ONE EXIT
	FET	(SYMBOL)	;SYMBOL
	XW0.0	(FET)		;ZERO RUNG
	SMK	(APNEM)	;ALLOC PNTR EM
	XW0.0T	(CLA)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	W1I	(REG)
	FET	(DAT1)	;DATA 1
	ADD	(TPOBOX)	;TIE POINT BOX
	XNI	(CREPNT)	;CRRNT REG PNTR
	SWT	(ONERUN)	;ONE RUNG
	XNIT	(CREPNT)	;CRRNT REG PNTR
	SUBT	(ONERUN)	;ONE RUNG
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	W3	(SEQ)		;W3
	FETT	(CREPNT)	;CRRNT REG PNTR
	IERT	(APNEM)	;ALLOC PNTR EM
	XW2.0T	(STO)		;ZERO RUNG
	W1	(STO)		;W1
	SEQ	(ZERO)	;ZERO
	FETF	(SYMBOL)	;SYMBOL
	MONF	(AERROL)	;ALLOC ERROR ROLL
	JMP	(IRESO1)	;$1
SAMBOU:					;SET AND MOVE BOUNDS
	SUB	(DAT1)	;DATA 1
	XNI	(CREPNT)	;CRRNT REG PNTR
	ADD	(ONERUN)	;ONE RUNG
MOVBOU:					;MOVE BOUNDS
	SGK	(MAXBOX)	;MAX REL BOX
	STKT	(MAXBOX)	;MAX REL BOX
	SLK	(MINBOX)	;MIN REL BOX
	STKT	(MINBOX)	;MIN REL BOX
	XML	(P1EML)	;PRUNE ONE EXIT
ACBSIZ:					;ADV COMMON BLOCK SIZE
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(ONERUN)	;ONE RUNG
	XML	(MCAPML)	;MAKE COMMON AREA PNTR
	FET	(SMABOX)	;SEG MAX BOX
	XW1.1	(SGK)		;ONE RUNG
	XW1.1T	(STK)		;ONE RUNG
	XML	(P2EML)	;PRUNE TWO EXIT
PGAROL:					;PUBLISH GENERAL ALLOC ROLL
	ZER	(GALPNT)	;GENERAL ALLOC PNTR
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	XITF	(EXIML)	;EXIT
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	SMK	(LHOEM)	;LEFT HALF ONES EM
	JMPF	(PGARO1)	;$1
	JSB	(PGLDUM)	;PUBLISH GLOBAL DUMMIES
	XITF	(EXIML)	;EXIT
PGARO1:
	SMK	(LHZEM)	;LEFT HALF ZERO EM
	JSBF	(PUBCOM)	;PUBLISH COMMON
	JSBT	(PUBEQU)	;PUBLISH EQUIV
	XIT	(EXIML)	;EXIT
PGLDUM:					;PUBLISH GLOBAL DUMMIES
	PRQ	(GDDCRQ)	;GLOBAL DUMMIES DBL CAR RET QT
PGLDU1:
	AND	(DISMAS)	;DISPL MASK
	SUB	(ONE)		;ONE
	ADD	(PROBRE)	;PROGRAM BREAK
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	STK	(ONERUN)	;ONE RUNG
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ZERRUN)	;ZERO RUNG
	W1	(SWT)		;W1
	JSB	(PIALOC)	;PUBLISH ID AND LOC
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EFAML)	;EXIT FALSE
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	SMK	(LHOEM)	;LEFT HALF ONES EM
	JSBF	(COLEND)	;FINISH LINE
	XITF	(ETRML)	;EXIT TRUE
	JMP	(PGLDU1)	;$1
PUBCOM:					;PUBLISH COMMON
	PRQ	(COMCRQ)	;COMMON QT
PUBCO1:
	W0	(FET)		;W0
	XML	(MCAPML)	;MAKE COMMON AREA PNTR
	XW0.0	(CLA)		;ZERO RUNG
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ZERRUN)	;ZERO RUNG
	JSB	(PRIW0)	;PRINT SYMBOL
	PRC	(TAB)		;COMMON NAME LINE POSITION
	PRC	(SLASH)	;SLASH
	JSB	(PRIW0)	;PRINT SYMBOL
	PRC	(SLASH)	;SLASH
	PRC	(PLUS)	;LOC LINE POSITION
	JSB	(POCLOC)	;PRINT OCTAL LOC
	PCOL	(ZERO)	;PRINT COLUMNS
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EFAML)	;EXIT FALSE
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	SMK	(LHZEM)	;LEFT HALF ZERO EM
	JSBT	(COLEND)	;FINISH LINE
	XMLT	(ETRML)	;EXIT TRUE
	JMP	(PUBCO1)	;$1
PUBEQU:					;PUBLISH EQUIV
	PRQ	(EQCRQT)	;EQUIVALENCE QT
PUBEQ1:
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ZERRUN)	;ZERO RUNG
	W1	(SWT)		;W1
	JSB	(PIALOC)	;PUBLISH ID AND LOC
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EXIML)	;EXIT
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	JMP	(PUBEQ1)	;$1
OGSROL:					;OUTPUT GLOBAL SPROG ROLL
	SRD	(GSPROL)	;GLOBAL SPROG ROLL
	PRQT	(CRSDCR)	;CAR RET SUBPROGRAMS DBL CAR RET QT
	CNT	(GSPROL)	;GLOBAL SPROG ROLL
	MON	(CODROL)	;CODE ROLL
	FLP	(GSPROL)	;GLOBAL SPROG ROLL
OGSRO1:
	MOA	(GSPROL)	;GLOBAL SPROG ROLL
	JSBF	(COLEND)	;FINISH LINE
	JMPF	(PDASTA)	;PUNCH DATA STA
	SMK	(APNEM)	;ALLOC PNTR EM
	CLAT	(DMYSYM)	;DUMMY SYMBOL
	W0	(FET)		;W0
	JSB	(PRIW0)	;PRINT SYMBOL
	PCOL	(ONE)		;PRINT COLUMNS
	XML	(ST5RAD)	;SYMBOL TO 50 RADIX
	IER	(LENEM)	;LOADER ENTRY EM
	MON	(CODROL)	;CODE ROLL
	JMP	(OGSRO1)	;$1
AAPSAA:					;ALLOCATE AND PUBLISH SCALARS AND ARRAY
	SRD	(SCAROL)	;SCALAR ROLL
	PRQT	(SCALQT)
	EAW	(SCAROL)	;SCALAR ROLL
	EAW	(SCAPNT)	;SCALAR PNTR
	ZERT	(SCAPNT)
	NOG	(SCAROL)
	JSB	(SOAALL)	;SCALAR OR ARRAY ALLOCATION
	REL	(SCAROL)	;SCALAR ROLL
	SRD	(ARRROL)	;ARRAY ROLL
	PRQT	(ARAYQT)
	EAW	(ARRROL)	;ARRAY ROLL
	EAW	(ARRPNT)	;ARRAY PNTR
	ZERT	(ARRPNT)
	NOG	(ARRROL)
SOAALL:					;SCALAR OR ARRAY ALLOCATION
	MPY	(TWO)
SOAAL2:
	MON	(CODROL)	;CODE ROLL
	W1I	(DNG)
	POWF	(D2)		;THREE
	JSBF	(COLEND)	;FINISH LINE
	JMPF	(PDASTA)	;PUNCH DATA STA
	W0I	(XNI)
	FET	(ZERRUN)	;ZERO RUNG
	SMK	(APNEM)	;ALLOC PNTR EM
	JSBT	(GDFGAL)	;GET DATA FROM GENERAL ALLOC
	W2IT	(XNI)
	STKT	(ZERRUN)	;ZERO RUNG
	W1T	(FET)		;COPY ROLL NUMBER
	W1T	(FET)		;COPY ROLL POINTER
	JSBT	(PIALOC)	;PUBLISH THE ROLL
	MONT	(CODROL)	;CODE ROLL
	JMPT	(SOAAL1)	;$1
	W0	(FET)
	FET	(LOCCNT)	;LOC CNTR
	W0	(FET)		;W0
	MON	(CODROL)	;CODE ROLL
	JSB	(PIALOC)	;PUBLISH ID AND LOC
	W0	(FET)		;W0
	JSB	(CSACLA)	;CALC SIZE AND CLASSIFY
	W1	(STO)		;W1
	FET	(LOCCNT)	;LOC CNTR
	W3I	(XNI)
	STK	(ZERRUN)	;ZERO RUNG
	W1	(AMY)		;W1
	STO	(LOCCNT)	;LOC CNTR
SOAAL1:
	XML	(ST5RAD)	;SYMBOL TO 50 RADIX
	IER	(LSOAEM)	;LOADER SCALAR OR ARRAY EM
	JMP	(SOAAL2)	;$2
GDFGAL:					;GET DATA FROM GENERAL ALLOC
	XW0.0	(FET)		;ZERO RUNG
	W1	(SWT)		;W1
	XW0.1	(CLA)		;ONE RUNG
	XIT	(EXIML)	;EXIT
PIALOC:					;PUBLISH ID AND LOC
	W1	(FET)		;W1
	JSB	(PRIW0)	;PRINT SYMBOL
	PRC	(TAB)		;LOC LINE POSITION
	JSB	(POCLOC)	;PRINT OCTAL LOC
	PRC	(TAB)		;SEPERATE THE COLUMNS
	PCOL	(ZERO)	;PRINT COLUMNS
	XML	(P1EML)	;PRUNE ONE EXIT
OOAREF:					;OUTPUT OBJECT ARRAY REF
	FLP	(OARROL)	;OBJECT ARRAY REF ROLL
	CNT	(OARROL)	;OBJECT ARRAY REF ROLL
OOARE1:
	MON	(CODROL)	;CODE ROLL
	MOA	(OARROL)	;OBJECT ARRAY REF ROLL
	RELF	(ARRROL)	;ARRAY ROLL
	JMPF	(PUNDAT)	;PUNCH DATA
	MOA	(OARROL)	;OBJECT ARRAY REF ROLL
	SON	(DMYEM)	;DMY EM
	XW1.0F	(FET)		;ZERO RUNG
	XMLF	(CBMOFF)	;COMPUTE BASE MINUS OFFSET
	MON	(CODROL)	;CODE ROLL
	AND	(RHAMAS)	;RIGHT HALF MASK
	JMP	(OOARE1)	;$1
OCOARE:					;OUTPUT COMMON AREA
	CNT	(CARROL)	;COMMON AREA ROLL
	MON	(CODROL)	;CODE ROLL
	FLP	(CARROL)	;COMMON AREA ROLL
OCOAR1:
	MOA	(CARROL)	;COMMON AREA ROLL
	JMPF	(PUNDAT)	;PUNCH DATA
	XML	(ST5RAD)	;SYMBOL TO 50 RADIX
	IER	(LCOEM)	;LOADER COMMON EM
	MON	(CODROL)	;CODE ROLL
	MOA	(CARROL)	;COMMON AREA ROLL
	MON	(CODROL)	;CODE ROLL
	JMP	(OCOAR1)	;$1
PLBERR:					;PUBLISH LBL ERRORS
	FLP	(LBLROL)	;LBL ROLL
PLBER1:
	MOA	(LBLROL)	;LBL ROLL
	JMPF	(PLBER2)	;$2
	SMK	(DEFEM)	;DEFINED EM
	XMLF	(BTOBCD)	;CONVERT W0 TO BCD ABS
	MONF	(ULBROL)	;UNDEFINED LBL ROLL
	JMPF	(PLBER1)	;$1
	SMK	(MDEEM)	;MUL DEFINED EM
	ANDT	(LWEMAS)	;LBL WITHOUT EMS MASK
	XMLT	(BTOBCD)	;CONVERT W0 TO BCD ABS
	MONT	(MDLROL)	;MUL DEFINED LBL ROLL
	POWF	(D1)		;ONE
	JMP	(PLBER1)	;$1
PLBER2:
	SRD	(ULBROL)	;UNDEFINED LBL ROLL
	PRQT	(CRULDC)	;CAR RET UNDEFINED LBLS DBL CAR RET QT
	EAWT	(ULBROL)	;UNDEFINED LBL ROLL
	JSBT	(PUBROL)	;PUBLISH ROLL
	SRD	(MDLROL)	;MUL DEFINED LBL ROLL
	PRQT	(CRMDLD)	;CAR RET MULTIPLY DEFINED
	EAWT	(MDLROL)	;MUL DEFINED LBL ROLL
	JMP	(PALER1)	;PUBLISH ALLOC ERR $1
PALERR:					;PUBLISH ALLOCATION ERROR
	SRD	(AERROL)	;ALLOC ERROR ROLL
	PRQT	(ALERCR)	;ALLOCATION QT
	EAWT	(AERROL)	;ALLOC ERROR ROLL
PALER1:
	JSBT	(PUBROL)	;PUBLISH ROLL
	XIT	(EXIML)	;EXIT
PDLERR:					;PUBLISH DO LOOP ERRORS
	SRD	(DLOROL)	;DO LOOPS OPEN ROLL
	PRQT	(ODLQT)	;OPEN DO LOOPS QT
PDLER1:
	MOA	(DLOROL)	;DO LOOPS OPEN ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EXIML)	;EXIT
IFNDEF	FILE0,
<
	TLY	(ERRCNT)	;ERROR COUNT
>
	XW0.0	(FET)		;ZERO RUNG
	AND	(LWEMAS)	;LBL WITHOUT EMS MASK
	XML	(BTOBCD)	;CONVERT W0 TO BCD ABS
	JSB	(PRIW0)	;PRINT W0
	PCOL	(ONE)		;PRINT COLUMNS
	REL	(DLOROL)	;DO LOOPS OPEN ROLL
	JMP	(PDLER1)	;$1
PUBROL:					;PUBLISH ROLL
PUBRO1:
	W0I	(MOA)
	JSBF	(COLEND)	;FINISH LINE
	XMLF	(P1EML)	;PRUNE ONE EXIT
IFNDEF	FILE0,
<
	TLY	(ERRCNT)	;ERROR COUNT
>
	SEK	(ZERO)	;BLANKS WORD
	PRCT	(SLASH)	;SLASH
	JSB	(PRIW0)	;PRINT W0
	PRCT	(SLASH)	;SLASH
	PCOL	(ONE)		;PRINT COLUMNS
	JMP	(PUBRO1)	;$1
LGAKEE:					;LBL GEN AND KEEP
MLGAKE:					;MADE LBL GEN AND KEEP
	W0	(FET)		;W0
MLBGEN:					;MADE LBL GEN
LBLGEN:					;LBL GEN
	W0	(FET)		;W0
	IOR	(CMUEM)	;CONST MULTIPLIER EM
	MON	(CODROL)	;CODE ROLL
	JSB	(CCOLBL)	;CONVERT CODE LBL
	JMP	(MOCOEX)	;MOVE ON CODE EXIT
SUBFAI:					;SUBEXP FAIL
	JSB	(SERNOT)	;SUBEXP ERROR NOTE
	XML	(FAIML)	;FAIL ML
SFAW0:					;SYNTAX FAIL W0
	ERM	(S13QT)	;SYNTAX QT
FAIL:					;FAIL
	XML	(FAIML)	;FAIL ML
SERNOT:					;SUBEXP ERROR NOTE
	SMK	(SUBEM)	;SUBEXP EM
	XW0.0T	(FET)		;OP PNTR RUNG
	W0F	(FPC)		;W0
	XIT	(EXIML)	;EXIT
GHEGEN:					;GLOBAL HEAD GEN
	RSV	(PCOROL)	;PROLOG CODE ROLL
	EAW	(PCOROL)	;PROLOG CODE ROLL
	CAR	(CODROL)	;CODE ROLL
	FET	(SYMBOL)	;SYMBOL
	FET	(SYMBOL)	;SYMBOL
IFNDEF	FILE0,
<
	STK	(PROGN)	;PROGRAM NAME
>
	XML	(ST5RAD)	;SYMBOL TO 50 RADIX
	SNZ	(NOPPNT)	;NAME OF PROG PNTR
	JMPT	(GHEGE1)	;$1
	W1	(SWT)		;W1
	SEK	(MAITES)	;MAIN. TEST
	LSST	(FORSE.)	;FORSE.
	REGT	(GSPFIL)	;GLOBAL SPROG FILE
	LSS	(JOBFF.)	;ELIMINATE TWO SEARCHES OF JOBDAT
	REG	(GSPFIL)	;CREATE PSEUDO GLOBAL SPROG FOR THE LOADER
	PNG	(UN2ROL)	;UNUSED 2 ROLL
	STO	(NOPPNT)	;NAME OF PROG PNTR
	MON	(UN2ROL)	;UNUSED 2 ROLL
	JMP	(GHEGE2)	;$2
GHEGE1:
	W1	(STK)		;W1
	POC	(WONHEA)	;WORD ONE HEADER
	ZER	(SYMBOL)	;SYMBOL
	AGF	(CODFIL)	;CODE FILE
	IER	(ENAEM)	;ENTRY NAME EM
	MON	(CODROL)	;CODE ROLL
GHEGE2:
	POC	(WFOHEA)	;WORD FOUR HEADER
	ZER	(SYMBOL)	;SYMBOL
	AGF	(CODFIL)	;CODE FILE
	STK	(RPRNAM)	;R50 PROG NAME
	MON	(CODROL)	;CODE ROLL
	TLY	(SYMBOL)	;INDICATE FORTRAN FILE FOR LOADER	;"21H"
	SWH	(SYMBOL)	;LEFT HALF OF WORD CONTAINS 1 (FORTRAN);"21H"
	AGF	(CODFIL)	;CODE FILE
	POC	(FSIHEA)	;F4 SIGNAL HEADER
	JSB	(PDASTA)	;PUNCH DATA STA
	EAW	(CODROL)	;CODE ROLL
	CAR	(PCOROL)	;PROLOG CODE ROLL
	JSB	(OUTCOD)	;OUTPUT CODE
GHEEXI:					;GLOBAL HEAD EXIT
	JSB	(LBLMAK)	;LBL MAKER
	JSB	(MLGAKE)	;MADE LBL GEN AND KEEP
	STO	(BEXPNT)	;BEGIN EXECUTION PNTR
	ZER	(FSTFLA)	;FIRST STA FLAG
	XIT	(EXIML)	;EXIT
PDASTA:					;PUNCH DATA STA
	NOZ	(DSTFLA)	;DATA STA FLAG
	JMP	(PUNCH)	;PUNCH

PUNDAT:					;PUNCH DATA
	ZER	(PPEFLA)	;PUNCH PEEK FLAG
	JMP	(PUNCO1)	;PUNCH

OUTCOD:					;OUTPUT CODE
	JSB	(PROCOD)	;PROCESS CODE
PUNCOD:					;PUNCH CODE
	NOZ	(PPEFLA)	;PUNCH PEEK FLAG
PUNCO1:
	ZER	(DSTFLA)	;DATA STA FLAG

PUNCH:					;PUNCH
	XML	(PUNCH1)	;$1
	REL	(CODROL)
	ZER	(DSTFLA)
	XIT	(EXIML)
PROCOD:					;PROCESS CODE
	ZER	(CODPNT)	;CODE PNTR
	ZER	(ACOCNT)	;ABS CODE CNTR
	ZER	(CLBBOX)	;CODE LBL BOX
PROCO1:
	DFA	(CODROL)	;CODE ROLL
	JMPF	(CISLBL)	;CODE ISOLATED LBL
	SNZ	(ACOCNT)	;ABS CODE CNTR
	JMPT	(PROCO2)	;$2
	SMK	(PLIEM)	;PROG LBL INST EM
	SMKF	(MLIEM)	;MADE LBL INST EM
	JSBT	(SCOLBL)	;SET CODE LBL
	JMPT	(PROCO1)	;$1
	SEK	(ELOOP)	;ENTRY LOADER OP
	JMPF	(PROCO3)	;$3
	POW	(D1)		;ONE
	DFA	(CODROL)	;CODE ROLL
	POW	(D1)		;ONE
	JMP	(PROCO1)	;$1
PROCO3:
	SMK	(AINEM)	;ABS INST EM
	ANDT	(ACNMAS)	;ABS CNT MASK
	STOT	(ACOCNT)	;ABS CODE CNTR
	JMPT	(PROCO1)	;$1
PROCO2:
	SNZ	(MACSW)	;PRINTING SUPPRESSED ?
	JSBT	(PROCO4)	;YES,GET OPCODE W/O SIDE AFFECTS
	JMPT	(PROCO1)	;YES, DON'T PRINT
	JSB	(PCOLBL)	;NO, PRINT CODE LBL
	XML	(SOAFBM)	;SWITCH OCT AND FET BCD
	PRC	(TAB)
	JSB	(PRIW0)	;PRINT W0
	PRC	(TAB)
	XMLT	(PAFML)	;PRINT AC FIELD
	PRCT	(COMMA)	;COMMA
	SMK	(IINEM)	;INDIRECT INST EM
	PRCT	(INDCHA)	;INDIRECT CHAR
	SNZ	(ACOCNT)	;ABS CODE CNTR
	DIMT	(ACOCNT)	;ABS CODE CNTR
	JSBT	(CABADR)	;CODE ABS ADR
	JSBF	(CPNADR)	;CODE PNTR ADR
	SMK	(NTAEM)	;NO TAG EM
	PRCF	(LPAREN)	;L PAREN
	XMLF	(PTAML)	;PRINT TAG
	PRCF	(RPAREN)	;R PAREN
	POW	(D1)		;ONE
	PRC	(CRR)		;CAR RETURN
	JMP	(PROCO1)	;$1
PROCO4:
	SNZ	(ACOCNT)	;ABSOLUTE CODE ?
	DIMT	(ACOCNT)	;YES, KEEP TRACK OF THE NUMBER
	XML	(SOAFBM)	;SWITCH OCT AND FET BCD
	POW	(D2)		;PRUNE OPCODE MNEMONIC & INSTR.
	XIT	(EXIML)	;RETURN W/O TRUE/FALSE FLAG
CCLAGE:					;CONVERT CODE LBL AND GEN
	W1	(STK)		;W1
	XML	(ST5RAD)
	IER	(LOPTRA)	;LOGICAL OP TRAIT
	XNI	(CODPNT)	;CODE PNTR
	STO	(ZERRUN)	;ZERO RUNG
	XIT	(EXIML)	;EXIT
SCOLBL:	DFA	(CODROL)	;CODE ROLL
	JSB	(CCLAGE)	;CONVERT CODE LBL AND GEN
	STO	(CLBBOX)	;CODE LBL BOX
	XIT	(EXIML)	;EXIT
CISLBL:					;CODE ISOLATED LBL
	FET	(CLBBOX)	;CODE LBL BOX
	SEK	(ZERO)	;ZERO
	W0F	(FET)
	JSBF	(PRIW0)
	PRQF	(B0QT)	;BLOCK 0 QT
	ZER	(CLBBOX)	;CODE LBL BOX
	PRC	(CRR)		;CAR RETURN QT ;"23D"
	XML	(P1EML)	;PRUNE ONE EXIT
PCOLBL:					;PRINT CODE LBL
	FET	(CLBBOX)	;CODE LBL BOX
	ZER	(CLBBOX)	;CODE LBL BOX
PRIW0:
	XML	(PW0ML)
CABADR:					;CODE ABS ADR
	W0	(FET)		;W0
	AND	(RHAMAS)	;RIGHT HALF MASK
POCLOC:
	XML	(POLML)	;PRINT OCTAL LOC

CPNADR:					;CODE PNTR ADR
	SMK	(MLBEM)	;MADE LBL EM
	SMKF	(LBLEM)	;LBL EM
	W0	(FET)		;W0
	JSBT	(CCOLBL)	;CONVERT CODE LBL
	XMLT	(PW0ML)	;PRINT W0 ML
	SMK	(CONEM)	;CONST EM
	SMKF	(TEMEM)	;TEMP EM
	JMPT	(CDIREF)	;CONVERT DISPL REF
	SMK	(OAREM)	;OBJECT ARRAY REF EM
	JMPF	(CPAFIN)	;CODE PNTR ADR FIN
	SMK	(APOEM)	;ADR PLUS ONE EM
	EORT	(APOMAS)	;ADR PLUS ONE MASK
	XW0.0	(FET)		;OBJECT ARRAY REF NAME RUNG
	JSB	(CPAFIN)	;CODE PNTR ADR FIN
	XW0.1	(CLA)		;OBJECT ARRAY REF OFFSET RUNG
	W0T	(DIM)		;W0
	SLK	(ZERO)	;ZERO
	PRCF	(MINUS)	;MINUS
	PRCT	(PLUS)	;PLUS
	W0T	(NOT)
	W0T	(TLY)
	JMP	(POCLOC)	;PRINT OCTAL LOC
CPAFIN:					;CODE PNTR ADR FIN
	SMK	(APOEM)	;ADR PLUS ONE EM
	EORT	(APOMAS)	;ADR PLUS ONE MASK
	XW0.0	(CLA)		;ZERO RUNG
	JSB	(PRIW0)	;PRINT W0
	PRCT	(PLUS)	;PLUS
	PRCT	(N1)		;N1
	XIT	(EXIML)	;EXIT
CDIREF:					;CONVERT DISPL REF
	SMK	(PTEEM)	;PERM TEMP EM
	FETT	(PTESYM)	;PERM TEMP SYMBOL
	JMPT	(CDIRE1)	;$1
	SMK	(CONEM)	;CONST EM
	FETT	(CPOSYM)	;CONST POOL SYMBOL
	FETF	(LTESYM)	;LOCAL TEMP SYMBOL
CDIRE1:
	JSB	(PRIW0)	;PRINT W0
	SMK	(APOEM)	;ADR PLUS ONE EM
	AND	(DISMAS)	;DISPL MASK
	W0F	(DIM)		;W0
	SEK	(ZERO)	;ZERO
	XMLT	(P1EML)	;PRUNE ONE EXIT
	PRC	(PLUS)	;PLUS
	JMP	(POCLOC)	;PRINT OCTAL LOC
CCOLBL:					;CONVERT CODE LBL
	SMK	(MLBEM)	;MADE LBL EM
	XW0.0F	(CLA)		;ZERO RUNG
	AND	(RHAMAS)	;RIGHT HALF MASK
	ANDT	(DISMAS)	;DISPL MASK
	XML	(BTOBCD)	;BIN TO BCD
	EAWT	(M)		;M
	EAWF	(P)		;P
ILACHA:
	XIT	(ILACH1)	;INSERT LABEL CHAR
IFNDEF	HALFWD,
<
	DEPHASE
>

IFDEF	HALFWD,
<
	IF2,	<IFN .&1,	<
	RELOC
	+CODE
	LOC>>

	RELOC	POPMEM+<.+1>/2

>
	OPSAVE	ADD
	OPSAVE	SUB
	OPSAVE	DIV
	OPSAVE	AND
;....EOF2

	SUBTTL  FX3 V.25	20-JAN-72

	;UPDATE IF COMPILER IS CHANGED
;COPYRIGHT 1971,1972 DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.

QTTBL:
	PHASE	0

	DEFINE	QT	(A)	<
	SIXBIT	\A]\
>

SUBQT:
	QT	SUBROUTINE
FUNQT:
	QT	FUNCTION
MENQT:
	QT	MENSION
OTOQT:
	QT	OTO
FORQT:
	QT	FORMAT
CALQT:
	QT	CALL
CONQT:
	QT	CONTINUE
TYPQT:
	QT	TYPE
ACCQT:
	QT	ACCEPT
ASSQT:
	QT	ASSIGN
TOQT:
	QT	TO
COMQT:
	QT	COMMON
EQUQT:
	QT	EQUIVALENCE
EXTQT:
	QT	EXTERNAL
RETQT:
	QT	RETURN
PAUQT:
	QT	PAUSE
STOQT:
	QT	STOP
REWQT:
	QT	REWIND
BACQT:
	QT	BACKSPACE
ENDQT:
	QT	END

IFNDEF	$DATA,
<
BLOQT:
	QT	BLOCK
ATAQT:
	QT	ATA
>
INTQT:
	QT	INTEGER
REAQT:
	QT	REAL
DPRQT:
	QT	DOUBLEPRECISION
COMPQT:
	QT	COMPLEX
LOGQT:
	QT	LOGICAL
PRIQT:
	QT	PRINT
PUNQT:
	QT	PUNCH
WRIQT:
	QT	WRITE
READQT:
	QT	READ
REREQT:
	QT	REREAD
ENCQT:
	QT	ENCODE
DECQT:
	QT	DECODE
FILQT:
	QT	FILE
UNLQT:
	QT	UNLOAD
SKIQT:
	QT	SKIP
RECQT:
	QT	RECORD
ERAQT:
	QT	ERASE
IFNDEF	$NAME,
<
NAMQT:
	QT	NAMELIST
>

IFNDEF	$IMPL,
<
IMPQT:
	QT	IMPLICIT
>
SUBSQT:
	QT	SUBSCRIPT
				;2 LINES DELETED	;"23L"
ENDEQT:				;"22Q"
	QT	<,END=>
ERREQT:				;"22Q"
	QT	<,ERR=>
;6 LINES DELETED	;"23O"
IFNDEF ERRCO,		;"23O"
<	DEFINE MSGQT (TYPE,NUMBER,MESSAGE)
<
TYPE'NUMBER'QT:	SIXBIT \TYPE-NUMBER MESSAGE]\
>
>
IFDEF ERRCO,		;"23O"
<	DEFINE MSGQT (TYPE,NUMBER,MESSAGE)
<TYPE'NUMBER'QT: SIXBIT \TYPE-NUMBER ]\	;"23O"
>
>

	MSGQT	M,1,TOO MANY SUBSCRIPTS
	MSGQT	M,2,WRONG NUMBER OF SUBSCRIPTS,	;STR795
	MSGQT	M,3,CONSTANT OVERFLOW
	MSGQT	M,4,ILLEGAL 'IF' ARGUMENT
	MSGQT	M,5,ILLEGAL CONVERSION IMPLIED
	MSGQT	M,6,LABEL OUT OF RANGE OR ARRAY TOO LARGE, ;"21E"
	MSGQT	M,7,UNTERMINATED HOLLERITH STRING
	MSGQT	M,8,SYSTEM ERROR - NO MORE SPACE FOR RECURSIVE STORAGE, ;"23J"
	MSGQT	M,9,TOO MUCH DATA - WRONG ARRAY SIZE OR LITERAL TOO LONG, ;"23K"
	MSGQT	M,10,ILLEGAL DO LOOP CLOSE
	MSGQT	M,11,MORE DATA NEEDED - LITERAL TOO SHORT OR TYPE CONVERSION EXPECTED,	;"23K"
	MSGQT	M,12,NON-INTEGER PARAMETER IN 'DO' STATEMENT
	MSGQT	M,13,NON-INTEGER SUBSCRIPT
	MSGQT	M,14,ILLEGAL COMPARISION OF COMPLEX VARIABLES
	MSGQT	M,15,TOO MANY CONTINUATION CARDS
	MSGQT	M,16,NON-INTEGER I/O UNIT OR CHARACTER COUNT
	MSGQT	M,17,SYSTEM ERROR - ROLL OUT OF RANGE
	MSGQT	M,18,SYSTEM ERROR - NO MORE ROOM FOR RECURSIVE CALLS;"23J"
	MSGQT	M,19,ILLEGAL USE OF STATEMENT LABEL ;"23-AP"
	MSGQT	M,20,ILLEGAL RECURSIVE CALL ;"23-AM"
	MSGQT	I,1,DUPLICATED DUMMY VARIABLE IN ARGUMENT STRING
	MSGQT	I,2,ARRAY NAME ALREADY IN USE
	MSGQT	I,3,ATTEMPT TO REDEFINE VARIABLE TYPE
	MSGQT	I,4,NOT A VARIABLE FORMAT ARRAY
	MSGQT	I,5,NAME ALREADY USED AS NAMELIST NAME
	MSGQT	I,6,DUPLICATED NAMELIST NAME
	MSGQT	I,7,A NAME APPEARS TWICE IN AN EXTERNAL STATEMENT
	MSGQT	I,8,ARGUMENT TYPE DOESN'T AGREE WITH FUNCTION SPEC ;"23GG"
	MSGQT	I,9,THIS FUNCTION REQIURES MORE ARGUMENTS ;"23GG"
	MSGQT	I,10,SUBPROGRAM NAME ALREADY IN USE
	MSGQT	I,11,DUMMY ARGUMENT IN DATA STATEMENT
	MSGQT	I,12,NOT A SCALAR OR ARRAY
	MSGQT	I,13,ILLEGAL USE OF DUMMY ARGUMENT
	MSGQT	I,14,ILLEGAL DO LOOP PARAMETER
	MSGQT	I,15,I/O VARIABLES MUST BE SCALARS OR ARRAYS
	MSGQT	I,16,A CONFLICT EXISTS WITH A COMMON DECLARATION;"23A"
	MSGQT	S,1,ILLEGAL NAME OR DELIMITER OR KEY CHARACTER;"23O"
	MSGQT	S,2,STATEMENT KEYWORD NOT RECOGNIZED;"23O"
	MSGQT	S,3,ILLEGAL FIELD SPECIFICATION
	MSGQT	S,4,SCALAR VARIABLE-MAY NOT BE SUBSCRIPTED
	MSGQT	S,5,ILLEGAL TYPE SPECIFICATION
	MSGQT	S,6,ARGUMENT IS NOT SINGLE LETTER
	MSGQT	S,7,'NAMELIST' NOT FOLLOWED BY "/"
	MSGQT	S,8,ILLEGAL CHARACTER IN LABEL, ;"23L"
	MSGQT	S,9,MISSING COMMA OR SLASH IN SPECIFICATION STATEMENT, ;"23M"
	MSGQT	S,10,ILLEGAL ARITHMETIC "IF" - TOO MANY LABELS,	;"23M"
	MSGQT	S,11,A NUMBER WAS EXPECTED
	MSGQT	S,12,IMPLICIT TYPE RANGE OVERLAPS PREVIOUS SPECIFICATION;"23O"
	MSGQT	S,13,ATTEMPT TO USE AN ARRAY OR FUNCTION NAME AS A SCALAR
	MSGQT	S,14,ARRAY NOT SUBSCRIPTED
	MSGQT	S,15,ILLEGAL USE OF AN ARITHMETIC FUNCTION NAME
	MSGQT	S,16,MULTIPLE RETURN ILLEGAL WITHOUT STATEMENT LABEL ARG,	;"23M"
	MSGQT	S,17,INCORRECT PAREN COUNT OR MISSING IMPLIED DO INDEX
	MSGQT	S,18,INVALID INDEX IN DO LOOP OR IMPLIED DO LOOP;"21T"
	MSGQT	S,19,EQUIVALENCE REQUIRES TWO OR MORE ELEMENTS
	MSGQT	S,20,ILLEGAL DEFINITION OF A STATEMENT FUNCTION,	;"23M"
	MSGQT	S,21,MISSING COMMA IN INPUT/OUTPUT LIST,	;"23M"
	MSGQT	S,22,STATEMENT CONTINUES PAST RECOGNIZED END POINT,	;"23M"
	MSGQT	S,23,ILLEGAL COMPLEX CONSTANT;"23O"
	MSGQT	O,1,BLOCK DATA NOT A SEPARATE PROGRAM
	MSGQT	O,2,SUBROUTINE IS NOT A SEPARATE PROGRAM
	MSGQT	O,3,STATEMENT OUT OF PLACE
	MSGQT	O,4,EXECUTABLE STATEMENTS ILLEGAL IN BLOCK DATA;"23O"
	MSGQT	A,1,MINIMUM VALUE EXCEEDS MAXIMUM VALUE
	MSGQT	A,2,ATTEMPT TO ENTER A VARIABLE INTO COMMON TWICE
	MSGQT	A,3,ATTEMPT TO EQUIVALENCE A DUMMY ARGUMENT
	MSGQT	A,4,NOT A CONSTANT OR DUMMY ARGUMENT
	MSGQT	A,5,CAUTION ** COMMON VARIABLE PASSED AS ARGUMENT

ASCQT:
	QT	<ASCII>
CRMDLD:
	QT	<-***MULTIPLY DEFINED LABELS***<-<-
GDDCRQ:
	QT	<-GLOBAL DUMMIES<-<-
COMCRQ:
	QT	<-COMMON<-<-
EQCRQT:
	QT	<-EQUIVALENCE<-<-
ALERCR:
	QT	<-***ALLOCATION ERRORS***<-<-
CRSDCR:
	QT	<-SUBPROGRAMS<-<-
SCALQT:
	QT	<-SCALARS<-<-
CONSQT:
	QT	<-CONSTANTS<-<-
ARAYQT:
	QT	<-ARRAYS<-<-
CRULDC:
	QT	<-***UNDEFINED LBLS***<-<-
				;2 LINES DELETED	;"23L"
NOQT:
	QT	.NOT.
;***********************************************************************
;DO NOT SEPARATE
OQTTBL:
EQQT:
	QT	.EQV.
XOQT:
	QT	.XOR.
ORQT:
	QT	.OR.
ANQT:
	QT	.AND.
	QT	.EQ.
NEQT:
	QT	.NE.
GTQT:
	QT	.GT.
LEQT:
	QT	.LE.
GEQT:
	QT	.GE.
LTQT:
	QT	.LT.
	QT	+
	QT	-
	QT	*
	QT	/
	QT	**
;***********************************************************************
B0QT:
	QT	< BLOCK 0>
ECOQT:
	QT	EXCESSIVE COUNT
FALQT:
	QT	FALSE.
TRUQT:
	QT	TRUE.
NOTQT:
	QT	NOT..
ODLQT:
	QT	<-***OPEN DO LOOPS***<-<-
IF.QT:
	QT	<IF(>
GOTQT:
	QT	GOTO

	DEPHASE
	DEFINE	BCD	(A)	<	SIXBIT	\A\
>

BCDTBL:
	PHASE	0

ADJ.:
	BCD	ADJ.
ALLIO.:
	BCD	ALLIO.
ALPHI.:
	BCD	ALPHI.
ALPHO.:
	BCD	ALPHO.
BINWR.:
	BCD	BINWR.
BLANKS:
	OCT	0
COMM:
	BCD	.COMM.

IFNDEF	$DATA,
<
DAT.:
	BCD	DAT.
>
DIRT.:
	BCD	DIRT.
DOUBT.:
	BCD	DOUBT.
END.:
	BCD	END.
ERR.:
	BCD	ERR.
EXIT.:
	BCD	EXIT
EXP1.0:
	BCD	EXP1.0
EXP2.0:
	BCD	EXP2.0
EXP3.0:
	BCD	EXP3.0
FLIRT.:
	BCD	FLIRT.
FLOUT.:
	BCD	FLOUT.
FORSE.:
	BCD	FORSE.
INTI.:
	BCD	INTI.
INTO.:
	BCD	INTO.
JOBFF.:
	BCD	JOBFF
LINT.:
	BCD	LINT.
LOUT.:
	BCD	LOUT.
MAIN.:
	BCD	MAIN.
MBSR.:
	BCD	MBSR.
MSPR.:
	BCD	MSPR.

IFNDEF	$NAME,
<
NMLST.:
	BCD	NMLST.
>
OCTI.:
	BCD	OCTI.
OCTO.:
	BCD	OCTO.
PAUSE.:
	BCD	PAUSE.
RANAC.:
	BCD	RANAC.
RECNO.:
	BCD	RECNO.
TFMT.:
	BCD	TFMT.
TPFCN.:
	BCD	TPFCN.
VADDR.:
	BCD	VADDR.


	DEPHASE
	DEFINE	X	(TYPE,MNE,COUNT,CLUE)
<	BYTE (6) -TYPE,MNE'ROL,-COUNT (18) CLUE
>

FILES:				;FILE GROUP TABLE
	PHASE	0		;MAKE ABSOLUTE

AREFIL:	X	0,ARE,3,ARNCLU

ARRFIL:	X	0,ARR,1,SYMBOL

CANFIL:	X	0,CAR,1,SYMBOL

CCOFIL:	X	0,CCO,2,RPACLU

CDAFIL:	X	0,CDA,1,SYMBOL

CIDFIL:	X	0,CID,1,SYMBOL

CNAFIL:	X	0,CNA,1,SYMBOL

CODFIL:	X	0,COD,1,SYMBOL

CPOFIL:	X	0,CPO,1,CPOCLU
DEFFIL:	X	0,DEF,1,SYMBOL

IFNDEF	$DATA,
<
DLCFIL:	X	0,DLC,1,DAT1
>

DPCFIL:	X	0,DPC,2,DAT1

DPIFIL:	X	0,DPI,1,SYMBOL

IFNDEF	$DATA,
<
DSVACF:	X	0,DSV,2,SYMBOL

DSVFIL:	X	0,DSV,1,SYMBOL
>

EDAFIL:	X	0,EDA,2,SYMBOL

ENEFIL:	X	0,ENE,1,SYMBOL

ESEFIL:	X	1,ERR,1,ERRBOX
	XWD	007777,777777
ETEFIL:	X	0,ETE,1,SYMBOL

FREFIL:	X	0,FRE,2,FRNCLU

GALFIL:	X	0,GAL,2,SYMBOL

GANFIL:	X	0,GAL,1,SYMBOL

GDMFIL:	X	0,GDM,1,SYMBOL

GSPFIL:	X	0,GSP,1,SYMBOL

ICOFIL:	X	0,ICO,1,DAT1

IIDFIL:	X	0,IID,1,SYMBOL

IFNDEF	$IMPL,
<
IMPFIL:	X	1,IMP,1,IMPCLU
	XWD	000000,000077
>
LBLFIL:	X	1,LBL,1,DAT2
	XWD	000000,777777

LDMFIL:	X	0,LDM,1,SYMBOL

LFUFIL:	X	0,LFU,1,SYMBOL

LIDFIL:	X	0,LID,1,SYMBOL

LSPFIL:	X	0,LSP,1,SYMBOL

IFNDEF	$NAME,
<
NITFIL:	X	0,NIT,1,SYMBOL

NNAFIL:	X	0,NNA,1,SYMBOL
>

OARFIL:	X	0,OAR,2,OARNCL

OCOFIL:	X	0,OCO,1,DAT1

RCOFIL:	X	0,RCO,2,DAT1

REGFIL:	X	1,REG,1,SYMBOL
	XWD	000000,777777

RIDFIL:	X	0,RID,1,SYMBOL

SCAFIL:	X	0,SCA,1,SYMBOL

SIIFIL:
SINFIL:	X	0,SII,1,SYMBOL

SUBFIL:	X	1,SUB,3,OPNCLU
	XWD	700000,777777
	XWD	050000,777777
	XWD	050000,777777

	DEPHASE			;BACK TO NORMAL
	P1=	0
	P3=	0
	IF1,
<
DEFINE	SETINS	(MNE,TAG,CODE)	;DEFINE OPDEFS
<	SIXBIT	/MNE/
	OPDEF	TAG	[P1<-^D27]
	P1=	P1+1
>
>

	IF2,
<	P2=	^D36		;BYTE COUNTER
	RELOC	IOCTBL		;SET TO TABLE
	RELOC			;RESET

DEFINE	SETINS	(MNE,TAG,CODE)	;STORE MNEMONICS AND CODES
<	SIXBIT	/MNE/
	OPDEF	TAG	[P1<-^D27]
	P1=	P1+1
	P3=	P3+CODE<-<P2=P2-9>
	IFE P2,	<OUTCOD>
>
DEFINE	OUTCOD			;CODE DUMP ROUTINE
<	RELOC
	+P3
	RELOC
	P2=	^D36+<P3=0>
>
>
IBCTBL:				;INST BCD TABLE

	SETINS	ARG   ,	..,	000
	SETINS	MOVE  ,	.ME,	200
	SETINS	MOVN  ,	.MN,	210
	SETINS	ADD   ,	.ADD,	270
	SETINS	SUB   ,	.SUB,	274
	SETINS	IMUL  ,	.IMU,	220
	SETINS	IDIV  ,	.IDI,	230
	SETINS	CAMG  ,	.CMG,	317

	SETINS	CAMGE ,	.CMGE,	315
	SETINS	CAME  ,	.CME,	312
	SETINS	CAML  ,	.CML,	311
	SETINS	CAMLE ,	.CMLE,	313
	SETINS	CAMN  ,	.CMN,	316
	SETINS	HRRZ  ,	.RRZ,	550
	SETINS	TDNN  ,	.TDNN,	616
	SETINS	TDNE  ,	.TDNE,	612

	SETINS	OR    ,	.OR,	434
	SETINS	ORCA  ,	.ORA,	454
	SETINS	ORCM  ,	.ORM,	464
	SETINS	ORCB  ,	.ORB,	470
	SETINS	XOR   ,	.XOR,	430
	SETINS	EQV   ,	.EQV,	444
	SETINS	AND   ,	.AN,	404
	SETINS	ANDCA ,	.ANA,	410

	SETINS	ANDCM ,	.ANM,	420
	SETINS	ANDCB ,	.ANB,	440
MAXIMI=	.-IBCTBL-1

	SETINS	FADR  ,	.FAR,	144
	SETINS	FSBR  ,	.FSR,	154
	SETINS	FMPR  ,	.FMR,	164
MAXFIM=	.-IBCTBL
	SETINS	FDVR  ,	.FDR,	174
								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	SETINS	DMOVN ,	.DMVN,	121				; *EJG* 06/23/76
	SETINS	DFAD  ,	.DFA,	110				; *EJG* 06/23/76
	SETINS	DFSB  ,	.DFS,	111				; *EJG* 06/23/76
	SETINS	DFMP  ,	.DFM,	112				; *EJG* 06/23/76
	SETINS	DFDV  ,	.DFD,	113				; *EJG* 06/23/76
>								; *EJG* 06/23/76

	SETINS	ARG   ,	.ARG,	320
	SETINS	HLRZ  ,	.LRZ,	554
	SETINS	TLC   ,	.TLC,	641
	SETINS	TDC   ,	.TDC,	650
	SETINS	TDZA  ,	.TDZA,	634
	SETINS	DFN   ,	.DFN,	131
	SETINS	SETZ  ,	.SEZ,	400
	SETINS	SETO  ,	.SEO,	474
	SETINS	HRRM  ,	.RRM,	542
	SETINS	HRLOI ,	.RLOI,	525
	SETINS	MOVSI ,	.MSI,	205
	SETINS	BLT   ,	.BLT,	251
	SETINS	PUSH  ,	.PSH,	261
	SETINS	HRLI  ,	.RLI,	505

	SETINS	HRL   ,	.RL,	504
	SETINS	HRRO  ,	.RRO,	560
	SETINS	HRROI ,	.RROI,	561
	SETINS	SETCM ,	.SEM,	460

	SETINS	FSC   ,	.FSC,	132
	SETINS	ASH   ,	.ASH,	240
	SETINS	LSH   , .LSH,   242
	SETINS	MOVEM ,	.MEM,	202
	SETINS	MOVNM ,	.MNM,	212
	SETINS	ADDB  ,	.ADDB,	273
	SETINS	EXCH  ,	.EXCH,	250
	SETINS	JSA   ,	.JSA,	266
	SETINS	AOJA  ,	.AOJA,	344

	SETINS	SOJA  ,	.SOJA,	364
	SETINS	JUMPLE,	.JULE,	323
	SETINS	JUMPE ,	.JUE,	322
	SETINS	JSP   ,	.JSP,	265
	SETINS	PUSHJ ,	.PSHJ,	260
	SETINS	JRA   ,	.JRA,	267
	SETINS	MOVNS ,	.MNS,	213
	SETINS	POP   ,	.POP,	262
BICNUM=	.-IBCTBL

	SETINS	HRRI  ,	.RRI,	541
	SETINS	MOVEI ,	.MEI,	201
	SETINS	MOVNI ,	.MNI,	211
	SETINS	ADDI  ,	.ADDI,	271
	SETINS	SUBI  ,	.SUBI,	275
	SETINS	IMULI ,	.IMUI,	221
	SETINS	IDIVI ,	.IDII,	231
	SETINS	CAIG  ,	.CIG,	307

	SETINS	CAIGE ,	.CIGE,	305
	SETINS	CAIE  ,	.CIE,	302
	SETINS	CAIL  ,	.CIL,	301
	SETINS	CAILE ,	.CILE,	303
	SETINS	CAIN  ,	.CIN,	306
	SETINS	      ,	..,	000
	SETINS	SETCA ,	.SEA,	450
	SETINS	SETCMM,	.SEMM,	462

	SETINS	ORI   ,	.ORI,	435
	SETINS	ORCAI ,	.ORAI,	445
	SETINS	ORCMI ,	.ORMI,	465
	SETINS	ORCBI ,	.ORBI,	471
	SETINS	XORI  ,	.XORI,	431
	SETINS	EQVI  ,	.EQVI,	445
	SETINS	ANDI  ,	.ANI,	405
	SETINS	ANDCAI,	.ANAI,	411

	SETINS	ANDCMI,	.ANMI,	421
	SETINS	ANDCBI,	.ANBI,	441

	SETINS	FADRI ,	.FARI,	145
	SETINS	FSBRI ,	.FSRI,	155
	SETINS	FMPRI ,	.FMRI,	165
	SETINS	FDVRI ,	.FDRI,	175

	SETINS	MTOP. ,	..MTO,	024
	SETINS	RESET.,	..RES,	015
	SETINS	IN.   ,	..IN,	016
	SETINS	OUT.  ,	..OUT,	017
	SETINS	DATA. ,	..DAT,	020
	SETINS	FIN.  ,	..FIN,	021
	SETINS	RTB.  ,	..RTB,	022
	SETINS	WTB.  ,	..WTB,	023
	SETINS	SLIST.,	..SLI,	025
	SETINS	INF.  ,	..INF,	026
	SETINS	OUTF. ,	..OUF,	027
	SETINS	RERED.,	..RER,	030
	SETINS	NLI. ,	..NLI,	031
	SETINS	NLO.,	..NLO,	032
	SETINS	DEC.,	..DEC,	033
	SETINS	ENC.,	..ENC,	034

	SETINS	JUMPN ,	.JUN,	326
	SETINS	JUMPGE,	.JUGE,	325
	SETINS	JUMPL ,	.JUL,	321
	SETINS	JUMPG ,	.JUG,	327
	SETINS	ADDM  ,	.ADDM,	272
	SETINS	SKIPE ,	.SKE,	332
	SETINS	FADRM ,	.FARM,	146
	SETINS	SUBM  ,	.SUBM,	276

	SETINS	FSBM  ,	.FSM,	152
	SETINS	FSBRM ,	.FSRM,	156
	SETINS	IMULM ,	.IMUM,	222
	SETINS	FMPM  ,	.FMM,	162
	SETINS	FMPRM ,	.FMRM,	166
	SETINS	IDIVM ,	.IDIM,	232
	SETINS	FDVM  ,	.FDM,	172
	SETINS	FDVRM ,	.FDRM,	176

	SETINS	SKIPGE,	.SKGE,	335
	SETINS	SKIPLE,	.SKLE,	333
	SETINS	FADL  , .FADL,	141
NACBRE=	.-IBCTBL
	SETINS	JRST  ,	.JRST,	254
	SETINS	AOS   ,	.AOS,	350
	SETINS	SOS   ,	.SOS,	370
	SETINS	SKIPA ,	.SKA,	334
	SETINS	SETOM ,	.SEOM,	476
	SETINS	SETZM ,	.SEZM,	402
	SETINS	SKIPG , .SKG, 337
IOCTBL:	BLOCK	P1/4
	IFN	P1/4*4-P1,	;PARTIAL CODE WORD?
<	+P3			;YES, DUMP IT
>
INSTBL:				;INSTRUCTION TABLE
	PHASE	0

.FAL0:
	.FADL			;FADL
.ADD1:
	.ADD	15,		;ADD	15,
.AOJA0:
	.AOJA			;AOJA
.AOS0:
	.AOS			;AOS
.ARG0:
	.ARG			;ARG
.ARG1:				;INDIRECT ARG FOR VARIABLES
	.ARG	@
.ASH0:
	.ASH			;ASH
.LSH0:
	.LSH			;LSH
.BLT0:
	.BLT			;BLT
.DFN0:
	.DFN			;DFN
.FSC0:
	.FSC			;FSC
.FSC1:
	.FSC	233		;FSC	233
.RL1:
	.RL	1,		;HRL	1,
.RLOI0:
	.RLOI			;HRLOI
.RRM0:
	.RRM			;HRRM
.RRO1:
	.RRO	1,(16)		;HRRO	1,(16)
.RROI0:
	.RROI			;HRROI
.RROI1:
	.RROI	1,		;HRROI	1,
.HRRI0:
	.RRI			;HRRI 0,
.RLI0:
	.RLI			;HRLI 0, ;"21R"
.RRZ1:
	.RRZ	1,(16)		;HRRZ	1,(16)
.JRA1:
	.JRA	16,(16)		;JRA	16,(16)
.JRST0:
	.JRST			;JRST
.JRST1:
	.JRST	(1)		;JRST	(1)
.JRST2:
	.JRST	@(1)		;JRST	@(1)
.JSA0:
	.JSA			;JSA
.JSA1:
	.JSA	16,		;JSA	16,
.JSA2:
	.JSA	16,@		;JSA	16,@
.CIN1:
	.CIN	1,		;CAIN 1, ;"23FF"
.RRZ0:
	.RRZ	1,		;HRRZ 1, ;"23FF"
.ME1:
	.ME	15,		;MOVE	15,
.ME2:
	.ME	1,		;MOVE	1,
.MEI0:
	.MEI			;MOVEI
.MEI1:
	.MEI	1,		;MOVEI	1,
.MEI2:
	.MEI	16,		;MOVEI	16,
.MEI3:								; *EJG* 12/17/76
	.MEI	1,@		;MOVEI	1,@			; *EJG* 12/17/76
.MEI4:								; *EJG* 12/17/76
	.MEI	@		;MOVEI	@			; *EJG* 12/17/76
.MEM1:
	.MEM	15,		;MOVEM	15,
.MN1:
	.MN	15,		;MOVN	15,
.MNS0:
	.MNS			;MOVNS
.MSI0:
	.MSI			;MOVSI
IFDEF HARDFL,<							; *EJG* 06/23/76
.DMVN0:								; *EJG* 06/23/76
	.DMVN			;DMOVN				; *EJG* 06/23/76
>								; *EJG* 06/23/76
.POP1:
	.POP	1(1)		;POP	1(1)
.POP2:
	.POP	@(16)
.PSH1:
	.PSH	(16)		;PUSH	(16)
.PSH2:
	.PSH	@(16)		;PUSH	@(16)
.PSH3:
	.PSH	1(1)		;PUSH	1(1)
.PSHJ0:
	.PSHJ			;PUSHJ
.PSHJ1:
	.PSHJ	17,		;PUSHJ	17,
.SEA0:
	.SEA			;SETCA
.SEM0:
	.SEM			;SETCM
.SEMM0:
	.SEMM			;SETCMM
.SEO0:
	.SEO			;SETO
.SEOM0:
	.SEOM			;SETOM
.SEZM0:
	.SEZM			;SETZM
.SKA0:
	.SKA			;SKIPA
.SKE1:
	.SKE	1,		;SKIPE	1,
.SKGE0:
	.SKGE			;SKIPGE
.SKLE0:
	.SKLE			;SKIPLE
.SOJA0:
	.SOJA			;SOJA
.SOS0:
	.SOS			;SOS
.SUB1:
	.SUB	15,		;SUB	15,
.SUBI0:
	.SUBI			;SUBI
.TDNE0:
	.TDNE			;TDNE
.TDNN0:
	.TDNN			;TDNN
.TDZA0:
	.TDZA			;TDZA
.TLC1:
	.TLC	233000		;TLC	233000
.CMG0:
	.CMG			;CAMG
.CML0:
	.CML			;CAML
.CME0:
	.CME			;CAME
	.CME			;CAME
.CMN0:
	.CMN			;CAMN
	.CMN			;CAMN
.CMGE0:
	.CMGE			;CAMGE
.CMLE0:
	.CMLE			;CAMLE
.JUG0:
	.JUG			;JUMPG
.JUL0:
	.JUL			;JUMPL
.JUE0:
	.JUE			;JUMPE
	.JUE			;JUMPE
.JUN0:
	.JUN			;JUMPN
	.JUN			;JUMPN
.JUGE0:
	.JUGE			;JUMPGE
.JULE0:
	.JULE			;JUMPLE
.MEM2:			;"22A"
	.MEM	1,		;MOVEM 1, "22A"
.SKG0:				;"22A"
	.SKG			;SKIPG "22A"
.JRA2:				;JRA "22A"
	.JRA	16,@-1(16)	;JRA 16,@-1(16) "22A"
.ADD2:				;"22A"
	.ADD	16,		;ADD 16, "22A"
.OR0:
	.OR			;OR
	.ORM			;ORCM
	.ORA			;ORCA
	.ORB			;ORCB
	.ANB			;ANDCB
	.ANA			;ANDCA
	.ANM			;ANDCM
	.AN			;AND
.AN0:
	.AN
	.ANM
	.ANA
	.ANB
	.ORB
	.ORA
	.ORM
	.OR
.XOR0:
	.XOR			;XOR
	.EQV			;EQV
	.EQV
	.XOR
	.EQV
	.XOR
	.XOR
	.EQV
.ME0:
	.ME			;MOVE
	.ME
	-<.ME>
	-<.ME>
.MN0:
	.MN			;MOVN
	.MN
	-<.MN>
	-<.MN>
.MEM0:
	.MEM			;MOVEM
	.MEM
	-<.MEM>
	-<.MEM>
.MNM0:
	.MNM			;MOVNM
	.MNM
	-<.MNM>
	-<.MNM>

.ADD0:
	.ADD			;ADD
.FAR0:	.FAR			;FADR
IFNDEF HARDFL,<							; *EJG* 06/23/76
	SIXBIT	/DFA.0/
>								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	.DFA			;DFAD				; *EJG* 06/23/76
>								; *EJG* 06/23/76
	-<.FAR>
.SUB0:
	.SUB			;SUB
	.FSR			;FSBR
IFNDEF HARDFL,<							; *EJG* 06/23/76
	SIXBIT	/DFS.0/
>								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	.DFS			;DFSB				; *EJG* 06/23/76
>								; *EJG* 06/23/76
	-<.FSR>
.IMU0:
	.IMU			;IMUL
	.FMR			;FMPR
IFNDEF HARDFL,<							; *EJG* 06/23/76
	SIXBIT	/DFM.0/
>								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	.DFM			;DFMP				; *EJG* 06/23/76
>								; *EJG* 06/23/76
	SIXBIT	/CFM.0/
.IDI0:
	.IDI			;IDIV
	.FDR			;FDVR
IFNDEF HARDFL,<							; *EJG* 06/23/76
	SIXBIT	/DFD.0/
>								; *EJG* 06/23/76
IFDEF HARDFL,<							; *EJG* 06/23/76
	.DFD			;DFDV				; *EJG* 06/23/76
>								; *EJG* 06/23/76
	SIXBIT	/CFD.0/

.ADDM0:
	.ADDM			;ADDM
	.FARM			;FADRM
	SIXBIT	/DFAM.0/
	-<.FARM>
.SUBM0:
	.SUBM			;SUBM
	.FSRM			;FSBRM
	SIXBIT	/DFSM.0/
	-<.FSRM>
.IMUM0:
	.IMUM			;IMULM
	.FMRM			;FMPRM
	SIXBIT	/DFMM.0/
	SIXBIT	/CFMM.0/
.IDIM0:
	.IDIM			;IDIVM
	.FDRM			;FDVRM
	SIXBIT	/DFDM.0/
	SIXBIT	/CFDM.0/
..DAT0:
	..DAT			;DATA.
..FIN0:
	..FIN			;FIN.
..IN1:
	..IN	1,		;IN.	1,
..MTO0:
	..MTO			;MTO.
..OUT1:
	..OUT	1,		;OUT.	1,
..RES0:
	..RES			;RESET.
..RTB0:
	..RTB			;RTB.
..SLI0:
	..SLI			;SLIST.
..SLI1:
	..SLI	@		;SLIST.	@
..WTB0:
	..WTB			;WTB.
..DEC1:
	..DEC	1,		;DEC.	1,
..ENC1:
	..ENC	1,		;ENC.	1,
.CEXP2:
	.PSHJ	17,[SIXBIT /CEXP.2/]
.CEXP3:
	.PSHJ	17,[SIXBIT /CEXP.3/]
.DEXP2:
	.PSHJ	17,[SIXBIT /DEXP.2/]
.DEXP3:
	.PSHJ	17,[SIXBIT /DEXP.3/]
.EXER1:
	.PSHJ	17,[SIXBIT /EXER1./]
.IFIX:
	.JSA	16,IFISYM
.DFIX:
	.JSA	16,DFISYM
.FLOAT:
	.JSA	16,FLOSYM
.SNGL:
	.JSA	16,SNGLSM
WONHEA:					;WORD ONE HEADER
	XWD	4,1
WFOHEA:					;WORD FOUR HEADER
	XWD	6,2
FSIHEA:					;F4 SIGNAL HEADER
	XWD	400,0

IFNDEF	$DATA,
<
MACLOP:					;MOVE AC LOP
	MOVE	13,12
AACLOP:					;ADD AC LOP
	ADD	12,13
DOENLO:					;DO END LOP
	PUSHJ	17,2
DINLOP:					;DO INIT LOP
	PUSHJ	17,1
SASLOP:					;SET ARRAY SIZE LOP
	PUSHJ	17,0
>
ABSINS:
	XWD	777777,500001
EOPLOP:					;END OF PROGRAM LOP
	OCT	-2

	DEPHASE
				;LINE DELETED	;"23O"
PHEBYT:					;PNTR HEAD BYTE
	POINT	6,%10,23
RGRPNT:					;ROLL GROUP SIZE POINTER
	POINT	3,RGRSIZ(%02),2
HORTEN:					;HIGH ORDER TEN
	XWD	240000,0

IFNDEF	FILE0,
<
EXIRLI:
	XWD	-EXLEN1,CARBUF+CBLEN1
LENGTI:
	XWD	CBLEN1+EXLEN1,NCC1+1
>
PDPSET:
	XWD	-PDPLEN,PDPSTK-1
ZERCOR:
	XWD	IMPURE-1,IMPURE
TABBAS:					;TABLE BASES
	XWD	0,UNUTAB		;UNUSED TABLE
	XWD	0,OPTABL		;OP TABLE
	XWD	0,LFUTAB		;LIB FUNC TABLE
	XWD	0,LTAENT		;LAST TABLE ENTRY
UNUTAB:	0				;UNUSED TABLE

DEFINE	LEVEL	(ENTRYS,PRELEV,SSADR)
<
		BYTE(6)ENTRYS(12)PRELEV(18)SSADR>
DEFINE	ENTRY	(KEYS,OPQT,TRAITS,GENADR)
<
		BYTE(4)KEYS(14)OPQT(5)TRAITS(13)GENADR>

;ENTRYS - NUMBER OF ENTRIES AT THIS LEVEL
;PRELEV - ADDRESS OF PREVIOUS LEVEL W/ 1ST LEVEL AT 1
;SSADR  - INDEX INTO SUBORDINATE SCAN ADDRESS TABLE (SSATBL)
;KEYS   - INDICATES TYPE OF OPERATOR
	NOTOP==	10	;COMPLEMENTARY OPERATOR ADJACENT
	COMOP==	04	;COMMUTATIVE OPERATOR
	LOGOP==	02	;A LOGICAL OPERATOR
	RELOP==	01	;A RELATIONAL OPERATOR
;OPQT   - INDEX INTO OPERATOR QUOTE TABLE (OQTTBL)
;TRAITS - QUALITIES THE OPERATOR MAY POSSESS
	NEGOP==	20	;NEGATIVE OPERATOR MAY BE USED
	TRUID==	10	;TRUE IDENTITY
	UCOMP==	04	;USE COMPLEMENT OF RESULT
	ARITH==	02	;ARITHMETIC OPERATOR
	ADDIT==	01	;ADDITIVE OPERATOR
;GENADR - INDEX INTO OPERATOR GENERATION ADDRESS TABLE (OGATBL)

DEFINE	TBL	(NAME,TYPE,NUMBER)
<
	SIXBIT	/NAME/		;"23GG"
	BYTE	(3)TYPE	(33)NUMBER		;NAME	"23GG"
>
OPTABL:					;OP TABLE
	XWD	0,0
LEVEL	2,0,0
	ENTRY	<NOTOP+COMOP+LOGOP>,0,<TRUID+UCOMP>,15
	ENTRY	<COMOP+LOGOP>,1,<UCOMP>,0
LEVEL	1,1,0
	ENTRY	<COMOP+LOGOP>,2,0,1
LEVEL	1,4,1
	ENTRY	<COMOP+LOGOP>,3,<TRUID>,2
LEVEL	6,6,0
	ENTRY	<COMOP+RELOP>,4,0,3
	ENTRY	<NOTOP+COMOP+RELOP>,5,0,3
	ENTRY	<RELOP>,6,0,4
	ENTRY	<NOTOP+RELOP>,7,0,5
	ENTRY	<RELOP>,10,0,5
	ENTRY	<NOTOP+RELOP>,11,0,4
LEVEL	2,10,5
	ENTRY	<COMOP>,12,<ARITH+ADDIT>,6
	ENTRY	<COMOP>,13,<NEGOP+ARITH+ADDIT>,6
LEVEL	2,17,5
	ENTRY	0,14,<ARITH>,7
	ENTRY	0,15,<ARITH>,10
LEVEL	1,22,2
LFUTAB:						;LIB FUNC TABLE
	ENTRY	0,16,0,11

	TBL	(INT,REAL,1)
	TBL	(MAX0,INTEGER,2)
	TBL	(MAX1,REAL,2)
	TBL	(MIN0,INTEGER,2)
	TBL	(MIN1,REAL,2)
	TBL	(ISIGN,INTEGER,2)
	TBL	(IDIM,INTEGER,2)
DFISYM:			;INSERTED "24-4"
	TBL	(IDINT,DOUBLE,1)
	TBL	(IABS,INTEGER,1)

IFISYM:
	TBL	(IFIX,REAL,1)	;"23T" AND ALSO NEXT LINE
				;2 LINES DELETED "24-4"
	TBL	(MOD,INTEGER,2)
	TBL	(EOF1,INTEGER,1)
	TBL	(EOFC,INTEGER,1)
EOILIB:
	TBL	(EXP,REAL,1)
	TBL	(ALOG,REAL,1)
	TBL	(ALOG10,REAL,1)
	TBL	(ATAN,REAL,1)
	TBL	(ATAN2,REAL,2)
	TBL	(SIN,REAL,1)
	TBL	(SIND,REAL,1)
	TBL	(COS,REAL,1)
	TBL	(COSD,REAL,1)
	TBL	(TANH,REAL,1)
	TBL	(SINH,REAL,1)
	TBL	(COSH,REAL,1)
	TBL	(ASIN,REAL,1)
	TBL	(ACOS,REAL,1)
	TBL	(SQRT,REAL,1)
	TBL	(AINT,REAL,1)
	TBL	(AMOD,REAL,2)
	TBL	(AMAX0,INTEGER,2)
	TBL	(AMAX1,REAL,2)
	TBL	(AMIN0,INTEGER,2)
	TBL	(AMIN1,REAL,2)
	TBL	(SIGN,REAL,2)
	TBL	(DIM,REAL,2)
	TBL	(ABS,REAL,1)
FLOSYM:
	TBL	(FLOAT,INTEGER,1)
SNGLSM:
	TBL	(SNGL,DOUBLE,1)
	TBL	(REAL,COMPLEX,1)
	TBL	(AIMAG,COMPLEX,1)
	TBL	(CABS,COMPLEX,1)
				;LINE DELETED "24-6"
	TBL	(CHANG,REAL,1)
EORLIB:					;END OF REAL LIBS
	TBL	(DMOD,DOUBLE,2)
	TBL	(DEXP,DOUBLE,1)
	TBL	(DLOG,DOUBLE,1)
	TBL	(DLOG10,DOUBLE,1)
	TBL	(DATAN,DOUBLE,1)
	TBL	(DATAN2,DOUBLE,2)
	TBL	(DSIN,DOUBLE,1)
	TBL	(DCOS,DOUBLE,1)
	TBL	(DSQRT,DOUBLE,1)
	TBL	(DMAX1,DOUBLE,2)
	TBL	(DMIN1,DOUBLE,2)
	TBL	(DSIGN,DOUBLE,2)
	TBL	(DABS,DOUBLE,1)
	TBL	(DBLE,REAL,1)
EODLIB:					;END OF DBL LIBS
	TBL	(CEXP,COMPLEX,1)
	TBL	(CLOG,COMPLEX,1)
	TBL	(CSIN,COMPLEX,1)
	TBL	(CCOS,COMPLEX,1)
	TBL	(CSQRT,COMPLEX,1)
	TBL	(CMPLX,REAL,2)
LTAENT:					;LAST TABLE ENTRY
	TBL	(CONJG,COMPLEX,1)
EOCLIB:					;END OF COMPLX LIBS
			;TYPE
	INT=	0	;INTEGER ;"21N"
	UNU=	1	;UNUSED ;"21N"
	REA=	2	;REAL ;"21N"
	LOG=	3	;LOGICAL ;"21N"
	OCT=	4	;OCTAL ;"21N"
	HOL=	5	;HOLLERITH ;"21N"
	DOU=	6	;DOUBLE PRECISION ;"21N"
	COM=	7	;COMPLEX ;"21N"

;TSEMAT:
	;TYPE SELECTION MATRIX   ROW  V      COLUMN: INT,UNU,REA,LOG,OCT,HOL,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*INT>><--^D24 (3) INT,INT,REA,INT,INT,INT,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*UNU>><--^D24 (3) INT,INT,REA,INT,INT,INT,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*REA>><--^D24 (3) REA,REA,REA,REA,REA,REA,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*LOG>><--^D24 (3) INT,INT,REA,LOG,LOG,LOG,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*OCT>><--^D24 (3) INT,INT,REA,LOG,OCT,OCT,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*HOL>><--^D24 (3) INT,INT,REA,LOG,OCT,HOL,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*DOU>><--^D24 (3) DOU,DOU,DOU,DOU,DOU,DOU,DOU,COM	;"21N"
;	BYTE (12) <POINT 3,0,^D<14+3*COM>><--^D24 (3) COM,COM,COM,COM,COM,COM,COM,COM	;"21N"
TSEMAT:			;TYPE SELECTION MATRIX
	OCT	250300200067
	OCT	220300200067
	OCT	170322222267
	OCT	140300233367
	OCT	110300234467
	OCT	060300234567
	OCT	030366666667
	OCT	000377777777
	DEFINE	X	( RGRSIZ, RADIX50, FLAGS )
<	BYTE	(3) RGRSIZ (6) RADIX50 (9) FLAGS (18) -40+ >

CSTAT:
CSTATI=	.-40
RGRSIZ:

	X	1,00,000," "
	X	2,00,000,"!"
	X	1,00,004,042
	X	1,00,000,"#"
	X	1,46,200,"$"
	X	1,47,000,"%"
	X	1,00,000,"&"
	X	1,00,004,"'"

	X	1,00,004,"("
	X	1,00,040,")"
	X	1,00,200,"*"
	X	1,00,020,"+"
	X	1,00,040,","
	X	1,00,020,"-"
	X	2,45,004,"."
	X	2,00,240,"/"	;"23Q"

	X	1,01,006,"0"
	X	2,02,006,"1"
	X	5,03,006,"2"
	X	2,04,006,"3"
	X	3,05,006,"4"
	X	2,06,006,"5"
	X	1,07,006,"6"
	X	1,10,006,"7"

	X	5,11,006,"8"
	X	1,12,006,"9"
	X	1,00,000,":"
	X	3,00,000,";"
	X	1,00,000,"<"
	X	1,00,000,"="
	X	2,00,000,">"
	X	1,00,000,"?"
	X	1,00,000,"@"
	X	1,13,001,"A"
	X	1,14,001,"B"
	X	1,15,201,"C"
	X	1,16,211,"D"	;"23Q"
	X	1,17,011,"E"
	X	2,20,001,"F"
	X	1,21,001,"G"

	X	1,22,001,"H"
	X	1,23,001,"I"
	X	1,24,001,"J"
	X	1,25,001,"K"
	X	1,26,001,"L"
	X	1,27,001,"M"
	X	1,30,001,"N"
	X	1,31,001,"O"

	X	2,32,001,"P"
	X	1,33,001,"Q"
	X	1,34,001,"R"
	X	1,35,001,"S"
	X	1,36,001,"T"
	X	2,37,001,"U"	;"23GG"
	X	0,40,001,"V"
	X	0,41,001,"W"

	X	0,42,001,"X"
	X	0,43,001,"Y"
	X	0,44,001,"Z"
	X	0,00,000,"["
	X	0,00,000,"\"
	X	0,00,000,"]"
	X	0,00,000,"?"
	X	0,00,000,"<-"
LIT:	LIT

REGADR==	7	;REGISTER ADDRESS MARK
MASK==		-1	;MASK BITS
NOT==		4	;COMPLEMENT ,BIT 3
DUMMY==		2	;DUMMY ,BIT 4
SIGN==		1	;SIGN ,BIT 5
INTEGER==	0	;POINTER TYPE ,BITS 0-2
REAL==		2
LOGICAL==	3
OCTAL==		4
LITERAL==	5
DOUBLE==	6
COMPLEX==	7

IFNDEF	REENTR,
<ZZ:
	PHASE	0
>
IFDEF	REENTR,<ZZ=0>

TYPMAS:

ITYEM:	BYTE	(3)  MASK	;INTEGER TYPE EM
ITYSTA:	BYTE	(3)  INTEGER

RTYEM:	BYTE	(3)  MASK
RTYSTA:	BYTE	(3)  REAL	;REAL TYPE EM

LTYEM:	BYTE	(3)  MASK	;LOGICAL TYPE EM
LTYSTA:	BYTE	(3)  LOGICAL

OCTEM:	BYTE	(3)  MASK		;"23Y"
OTYSTA:	BYTE	(3)  OCTAL

HTYEM:	BYTE	(3)  MASK
HTYSTA:	BYTE	(3)  LITERAL

DPTEM:	BYTE	(3)  MASK
DPTSTA:	BYTE	(3)  DOUBLE

CTYEM:	BYTE	(3)  MASK
CTYSTA:	BYTE	(3)  COMPLEX
LBLEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) LBLROL
GSPEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) GSPROL
REGEM:
	BYTE	(15) 0 (9)  MASK
REGSTA:	BYTE	(15) 0 (3) REGADR (6) REGROL
ICOEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) ICOROL
HCOEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) HCOROL
SCAEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) SCAROL
LDMEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) LDMROL
ARREM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) ARRROL
SUBEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) SUBROL
NESEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) NESROL
LSPEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) LSPROL
IFNDEF	$DATA,
<
DSVEM:
	BYTE	(18) 0 (6)  MASK
	BYTE	(18) 0 (6) DSVROL
>
DAIEM:
	BYTE	(6) DUMMY (12) 0 (6)  MASK	;DUMMY ARRAY ID EM
	BYTE	(6) DUMMY (12) 0 (6)  ARRROL
DGSEM:
	BYTE	(6) DUMMY (12) 0 (6)  MASK	;DUMMY GLOBAL SPROG EM
	BYTE	(6) DUMMY (12) 0 (6)  GSPROL
TIDTRA:
	OCT	000000200000		;TRUE IDEN TRAIT
	OCT	000000200000
UCOTRA:
	OCT	000000100000		;USE COMPL TRAIT
	OCT	000000100000
CVAEM:
NOPTRA:
DEFTRA:
DEFEM:
	OCT	400000000000		;DEFINED TRAIT
	OCT	400000000000
COMTRA:
MDETRA:
MDEEM:
	OCT	200000000000		;MUL DEFINED TRAIT
	OCT	200000000000
APOEM:
APOMAS:
NEGTRA:
	OCT	000000400000		;ADR PLUS ONE EM
APOSTA:
	OCT	000040400000		;ADR PLUS ONE STAMP
LOPTRA:
	OCT	100000000000		;LOGICAL OP TRAIT
	OCT	100000000000
NOTEM:
NOTMAS:
LENEM:
ENAEM:
ROPTRA:
	OCT	040000000000		;NOT EM,ENTRY NAME EM
SANMAS:
	OCT	050000000000		;SIGN AND NOT MASK
PLUEM:
	OCT	010000000000		;PLUS EM
	OCT	000000000000
CONEM:
	BYTE	(19) 0 (2)  MASK		;CONST EM
	BYTE	(19) 0 (5)  ICOROL & CCOROL	;ALL CONSTANT ROLLS ARE NUMBERED IN THE TEENS
DITEM:
	BYTE	(2)  MASK			;DBL ITEM EM
	BYTE	(3)  DOUBLE & COMPLEX
INTEPN:
	BYTE	(18) 0 (6)  TEMROL		;INITIAL TEMP PNTR
ITETRA:
FSPEM:
DMYEM:
FREEM:
	BYTE	(4) 0 (1)  MASK		;DMY EM
	BYTE	(3) 0,  DUMMY
EVEEM:
	OCT	000000000001		;EVEN EM
	OCT	000000000000
MLBEM:
	BYTE	(18) 0 (6)  MASK		;MADE LBL EM
	BYTE	(18) 0 (6)  APNROL
TASMAS:					;TYPE AND SIGN MASK
DPNEM:
	BYTE	(3) MASK, SIGN		;DP NEG EM
	BYTE	(3) DOUBLE,SIGN
AREEM:
	BYTE	(19) 0 (5) MASK		;ARRAY REF EM
	BYTE	(19) 0 (5) AREROL
LOOCEM:
	BYTE	(18) 0 (5) MASK		;LIT OR OCTAL CONST EM
	BYTE	(18) 0 (6) HCOROL & OCOROL
PLOEM:
	BYTE	(3) MASK, NOT + SIGN	;POSITIVE LOGICAL EM
	BYTE	(3) LOGICAL, 0
COPEM:
	BYTE	(18) 0,MASK		;CONST ONE PNTR EM
	BYTE	(18) 0,<ICOROL>B23+3
ZRHEM:
	BYTE	(18) 0, MASK		;ZERO RH EM
	BYTE	(18) 0,0
EREEM:
MOPEM:
	BYTE	(30) 0 (6) 10+1		;EVEN REG EM
	BYTE	(30) 0 (6) 1
CMUEM:
	BYTE	(18) MASK			;CONST MULTIPLIER EM
	BYTE	(18) 0
PTEEM:
	BYTE	(19) 0 (5) MASK		;PERM TEMP EM
	BYTE	(19) 0 (5) ERRROL
PLIEM:
	BYTE	(18) MASK (6) MASK		;PROG LBL INST EM
	BYTE	(18) MASK (6) LBLROL
MLIEM:
	BYTE	(18) MASK (6) MASK		;MADE LBL INST EM
	BYTE	(18) MASK (6) APNROL
AINEM:
ABSEM:
	BYTE	(18) MASK (3) MASK		;ABS INST EM
	BYTE	(18) MASK (3) 5
ACMASK:					;AC MASK
	Z	1,

BICFAC:					;BUILD IMMEDIATE CONST FACTOR
	BYTE	(9)BICNUM
MOVINS:					;MOVE INST
	<.ME><-^D-27
IMUINS:					;IMUL INST
	<.IMU><-^D-27
MIMINS:					;MAX IMMED INST
	EXP	MAXIMI
MIFINS:					;MAX IMMED FLOATING INST
	EXP	MAXFIM
IINEM:
	OCT	000020000000		;INDIRECT INST EM
	OCT	000020000000
NTAEM:
	OCT	000017000000		;NO TAG EM
	OCT	000000000000
OAREM:
	BYTE	(19) 0 (5) MASK		;OBJECT ARRAY REF EM
	BYTE	(19) 0 (5) OARROL
APNEM:
ENPEM:
	BYTE	(18) MASK			;ALLOC PNTR EM
	SIXBIT *\\\*
MODOTR:
	OCT	000000060000		;MULT OF DIV OP TRAIT
AOPTRA:
	OCT	000000040000		;ARITH OP TRAIT
	OCT	000000040000
ADDTRA:
	OCT	000000020000		;ADDITIVE OP TRAIT
	OCT	000000020000
SINEM:
LSOAEM:
	OCT	740000000000		;LOADER SCALAR EM
	OCT	100000000000
FPO2EM:
	OCT	400777777777		;FL POWER OF 2 EM
	OCT	000400000000
LCOEM:
	OCT	740000000000		;LOADER COMMON EM
	OCT	440000000000
CCRPEM:
	OCT	100000700000		;CPLX CONST REAL PART EM
	OCT	000000100000
VAREM:		BYTE (9) 777		;I/O LIST VARIABLE INDICATOR
VARPNT:		BYTE (9) 555
IIVEM:		BYTE (9)0,777
IIVSTA:		BYTE (9)0,377
DREEM:
	BYTE	(6) 0 (30) MASK		;DO REG EM
DREPNT:
	BYTE	(15) 0 (3) REGADR (18) <REGROL>B23+16
DONEM:
DISMAS:
	BYTE	(24) 0 (12) MASK		;DISPL MSK
	BYTE	(24) 0 (12) 1		;DISPL ONE PNTR
ABCCMA:
	BYTE	(6) MASK (12) 0 (18) MASK	;NOT CHAR CNT MSK
ABSMAS:
	BYTE	(5) MASK (1) 0 (30) MASK	;NOT SIGN MASK
LHOEM:
LHAMAS:
	BYTE	(18) MASK		;LH ONES EM
LHZEM:
	BYTE	(18) MASK			;LH ZERO EM
RCOMAS:
	BYTE	(19) 0 (17) MASK	;REG CORR MASK
MINMAS:
MINEM:
	BYTE	(3) 0, SIGN	;MINUS EM
	BYTE	(3) 0,SIGN
RHOEM:
	BYTE	(18) 0, MASK	;RH ONES EM
MIMADR:
LHZMAS:
RHAMAS:
	BYTE	(18) 0,MASK	;RH MSK
OTAEM:
	BYTE	(18) 0(6) MASK	;OP TABLE EM
	BYTE	(18) 0 (6) OPCROL
MAITES:
	BCD	MAIN.
DATTES:
	BCD	DAT.
DMYSYM:
	BCD DUMMY.
ELOOP:
	XWD	-1,600000
RZEEM:
	BYTE	(15) 0 (21) MASK	;REG ZERO EM
BREPNT:
RZEPNT:
	BYTE (15) 0 (3) REGADR (6) REGROL (12) 1	;BLANK REG PNTR
RONPNT:
	BYTE (15) 0 (3) REGADR (6) REGROL (12) 2
R10PNT:
	BYTE (15) 0 (3) REGADR (6) REGROL (12) 11
R16PNT:
	BYTE (15) 0 (3) REGADR (6) REGROL (12) 17
R17PNT:
	BYTE (15) 0 (3) REGADR (6) REGROL (12) 20
INPPNT:
	<OPCROL>B23+23		;INT MPY PNTR
IADPNT:
	<OPCROL>B23+20		;INT ADD PNTR
CONPNT:
	<ICOROL>B23+3		;CONST ONE PNTR
CTWPNT:
	<ICOROL>B23+4		;CONST TWO PNTR
ABSCPN:
	<ICOROL>B23+5		;ALLBUT SIGN CONST PNTR
ACNMAS:
	BYTE	(21) 0 (15) MASK	;ABS CINT MASK
MAXSYM:
	EXP	N			;MAX INTEGER SYMBOL
MINSYM:
	EXP	I			;MIN INTEGER SYMBOL
HRLI1I:
	.RLI	1,
LWEMAS:
	OCT	177777777777		;LBL WITHOUT EMS MASK
MINONE:
TRUCON:
AONLOW=	.+ZZ
	XWD	-1,-1			;TRUE CONST, MINUS ONE
IFNDEF	$DATA,
<
DSTLOP:
	OCT	777777700000		;DATA STA LOP
ADDLOP:
	ADD	12,
MOVLOP:
	MOVE	12,
MPYLOP:
	IMUL	12,
IMULOP:
	IMULI	12,
DENLOP:
	JRST
>
;DO NOT SEPARATE

MPZERO:
	DEC	0			;MP ZERO
FALCON:
ZERO:
	DEC	0			;ZERO  FALSE CONST
TWO:
	DEC	2			;TWO
LCIMAS:
THREE:
	DEC	3			;THREE
FOUR:
	DEC	4			;FOUR
FIVE:
	DEC	5			;FIVE
SIX:
	DEC	6
SEVEN:
	OCT	7			;SEVEN
EIGHT:
	DEC	8			;EIGHT

IFNDEF	$CCONS,
<
SIXTEE:
	DEC	16			;SIXTEEN
SEVENT:
	DEC	17
TWEONE:
	DEC	21
>
MAXEXP:
	OCT	377			;MAX EXPONENT
CZPEM:
	BYTE	(19) 0 (17) MASK	;CONST ZERO PNTR EM
CZEPNT:
FCNPNT:
	BYTE	(19) 0 (17)<ICOROL>B23+1	;CONST ZERO PNTR
TCPEM:
	BYTE	(19) 0 (17) MASK	;TRUE CONST PNTR EM
TCOPNT:
	BYTE	(19) 0 (17) <ICOROL> B23+2	;TRUE CONST PNTR
FZPEM:
	BYTE	(19) 0 (17) MASK	;FL ZERO PNTR EM
	BYTE	(19) 0 (17) <FCOROL> B23+1
MHOCNT:
	DEC	1313			;MAX HOL CNT
MOSPOS:
	OCT	377777777777		;MAX FL NUMBER
MLBALL:
	DEC	99999			;MAX LBL
HBUINI:
	POINT	7,HOLBUF+ZZ,
PTESYM:
	BCD	TEMP.
LTESYM:
	BCD	%TEMP.
TEMEM:
	BYTE	(19) 0 (4) MASK		;TEMP EM
	BYTE	(19) 0 (5) ERRROL & TEMROL

IFNDEF	$NAME,
<
CTBCON:
	OCT	012000000000		;CONVERT TO BIN CONST
>
CPOSYM:
	BCD	CONST.
ONE:
NOFMAS:
	XWD	0,1			;ONE,SCRIPT VAR CHK TAG,
ASCIBL:
	ASCII	/     /
ASTERX:	DEC	10		;ASTERISK "22A"

; END OF DATA THAT MUST BE INITIALIZED

IFDEF	REENTR,	<
	END
>
;....EOF3

	SUBTTL	FX4 V.25	20-JAN-72
;COPYRIGHT 1971,1972 DIGITAL EQUIPEMENT CORP., MAYNARD, MASS.
IFDEF	REENTR,
<
	TITLE	IMPURE AREA - REENTRANT FORTRAN 
>
;IN V.00X-0Y X IS THE FILE VERSION AND Y IS THE PROGRAM VERSION

IFNDEF CCLSW,<CCLSW=1>	;1 IMPLIES CCL FEATURES (NORMAL CASE)
INTERNAL CCLSW		;WILL CAUSE GLOBAL SYM CONFLICT IF ALL PIECES NOT SAME

IFE	CCLSW,<TEMPC==0>
IFNDEF	TEMPC,<TEMPC==1>	;TMPCOR UUO CAN BE USED IF SET TO 1
	INTERNAL	TEMPC

IFDEF	REENTR,
<	INTERNAL	IMPURE,	PDPSW,	PROGN,	ZERA,	ENDCOD	;"23P"
	INTERNAL	ERRMSG,	LBFLG,	FEXADR,	ERRCNT,	LFUTEM	;"23GG"
	INTERNAL	LCANUM,	NDISCA,	NUNPOS,	FAICAR,	LFUATO	;"23GG"
	INTERNAL	FSTFLA,	COPRCT,	FMSBOX,	ERRBOX
	INTERNAL	SYMBOL,	CANCLU,	MAC1,	CCAFLA
	INTERNAL	CON1,	RPACLU,	DAT1,	MAC2,	LSPDEF ;"23-AM"
	INTERNAL	DAT2,	DAT3,	DAT4,	HITCNT
	INTERNAL	ISAFLA,	NOPPNT,	BEXPNT,	RPRNAM
	INTERNAL	RETPNT,	FARTEM,	ASTFLA,	IIAFLA
	INTERNAL	DSTFLA,	GSTFLA,	JSTFLA,	BDPFLA
	INTERNAL	ERRFLA,	PPEFLA,	FORFLA,	CRFSW
	INTERNAL	SINFLA,	QFACCN,	MSTLOC,	CREPNT
	INTERNAL	HOLBUF,	HBUIND,	ROLPNT,	ESIBOX
	INTERNAL	DDOCNT,	DITCNT,	DLICNT,	MCOFLA
	INTERNAL	CLBBOX,	CBABOX,	DUSCNT,	REGTEM
	INTERNAL	EXPA,	EXPONE,	DARFLA,	IOLFLA
	INTERNAL	JOUFLA,	TEMP,	DSPFLA,	SARFLA
	INTERNAL	LATPNT,	LA1S13,	LA1S14,	PROBRE
	INTERNAL	RROFLA,	FELFLA,	MINBOX,	ISCBOX
	INTERNAL	MAXBOX,	VPNBOX,	SMABOX,	IBICNT
	INTERNAL	SMIBOX,	ABLPNT,	ARGCNT,	ESTFLA
	INTERNAL	CARNUM,	LACCCN,	TEMCNT,	IIVPNT
	INTERNAL	MLBCNT,	LOCCNT,	LASACT,	LTEPNT
	INTERNAL	STAPSA,	STACSA,	STAEXS,	STAWKS
	INTERNAL	LAPTMP,	LAPEND,	SSATMP,	SSAEND	
	INTERNAL	STATBS,	AFDTPN,	RGRTMP,	PSTCRD
	INTERNAL	OARNCL,	ARNCLU,	CORSIZ,	REGSAV
	INTERNAL	FRNCLU,	OPNCLU,	IMPCLU,	AROCLU
	INTERNAL	OAROCL,	CPOCLU,	CONTEM,	APACLU
	INTERNAL	FRAPCL,	TPOBOX,	ACOCNT,	BPACLU
	INTERNAL	SEXCLU,	WORROL,	TOPS,	BOTTOM
	INTERNAL	ANCHOR,	FLOORS,	EROADR,	AC00,	AC01
	INTERNAL	AC02,	AC03,	AC04,	AC05
	INTERNAL	AC06,	AC07,	AC10,	AC11
	INTERNAL	AC12,	AC13,	AC14,	ROLMEM
	INTERNAL	CRDCNT,	PAGCNT,	TTLERR,	NUMPRO
	INTERNAL	PDPSWZ,	EXTSAV,	PROGNZ,	ERRCNZ
	INTERNAL	PDPSTK,	JOBFFI,	XE,	REGCNT	;"21V"
	INTERNAL	XE1,	XE2,	XE3,	CMDBUF
	INTERNAL	CMDPNT,	CMDCNT,	TTOBUF,	TTOPNT
	INTERNAL	TTOCNT,	BINBUF,	BINPNT,	BINCNT
	INTERNAL	LSTBUF,	LSTPNT,	LSTCNT,	SRCBUF
	INTERNAL	SRCPNT,	SRCCNT,	LINCNT,	CARBUF
	INTERNAL	DSTPNT,	GDMPNT,	FREPNT,	GSPPNT
	INTERNAL	NNAPNT,	ERRPNT,	LBLPNT,	SCAPNT
	INTERNAL	AREPNT,	CODPNT,	SUBPNT,	MACSW
	INTERNAL	ASTPNT,	APLPNT,	CPOPNT,	ARRPNT
	INTERNAL	CARPNT,	GALPNT,	UN2PNT,	OPCPNT
	INTERNAL	HCOPNT,	APNPNT,	ITEPNT,	PINATO
	INTERNAL	APAATO,	RSIEM,	SIGMAS,	RSITRA
	INTERNAL	RSIATO,	ETYEM,	EOPPNT,	ETYATO
	INTERNAL	SLPEM,	SLBPNT,	APAEM,	PINEM
	INTERNAL	CEMADR,	PEMADR,	SEQPNT,	FICPNT
	INTERNAL	AC1SAV,	EXPSAV,	DEFINE,	SAV15,	SAV16	;"21U","21V"
	INTERNAL	ENDFLG,IMDFLG,MULRET	;"22A","22K"

	EXTERNAL	ASCIBL,	PDPSET
	LBLROL=	0	;LBL ROLL
	OARROL=	1	;OBJECT ARRARY REF ROLL
	UN2ROL=	2	;UNUSED 2 ROLL
	APLROL=	3	;ARG PLEX ROLL
	PCOROL=	4	;PROLOG CODE ROLL
	CODROL=	5	;CODE ROLL
	GSPROL=	6	;GLOBAL SPROG ROLL
	REGROL=	7	;REG ROLL
	ICOROL=	10	;INT CONST ROLL
	ULBROL=	10	;UNDEFINE LBL ROLL
	CPOROL=	11	;CONST POOL ROLL
	FCOROL=	12	;FL CONST ROLL
	MDLROL=	12	;MUL DEFINED LBL ROLL
	AERROL=	13	;ALLOC ERROR ROLL
	OCOROL=	14	;OCT CONST ROLL
	HCOROL=	15	;HOLLERITH CONST ROLL
	RCOROL= 16	;REAL CONST ROLL
	DPCROL=	16	;DOUBLE PREC CONST ROLL
	ENEROL=	16	;EQUIV NEST ROLL
	CCOROL=	17	;COMPLEX CONST ROLL
	CARROL=	17	;COMMON AREA ROLL
	SCAROL=	20	;SCALAR ROLL
	LDMROL=	21	;LOCAL DMY ROLL
	ARRROL=	22	;ARRAY ROLL
	NNAROL=	23	;NAMELIST NAME ROLL
	AREROL=	24	;ARRAY REF ROLL
	GALROL=	25	;GENERAL ALLOC ROLL
	ERRROL=	26	;ERROR ROL
	TEMROL=	27	;TEMP ROLL
	FREROL=	30	;FUNC REF ROLL
	SUBROL=	30	;SUBEXP ROLL
	APNROL=	31	;ARG PNTR ROLL
	SUDROL=	32	;SUBORDS ROLL
	NESROL=	33	;NEST ROLL
	GDMROL=	34	;GLOBAL DMY ROLL
	IMPROL=	35	;IMPLICIT ROLL
	LSPROL=	36	;LOCAL SPROG ROLL
	DLOROL=	37	;DO LOOPS OPEN ROLL
	ITEROL=	40	;ITEM TEMP ROLL
	ATEROL=	41	;ARRAY TEMP ROLL
	CTEROL=	41	;CONST TEMPT ROLL
	DLIROL=	42	;DATA LIST ROLL
	DIMROL=	42	;DIMENS ROLL
	DLCROL=	43	;DATA LIST CONST ROLL
	DARROL=	43	;DIMENS ARG ROLL
	DITROL=	44	;DATA ITEMS ROLL
	LIMROL=	44	;LIMITS ROLL
	DSTROL=	45	;DATA SCRIPT TERM ROLL
	DSVROL=	46	;DATA SCRIPT VAR ROLL
	ETEROL=	46	;EQUIV TEMP ROLL
	NITROL=	47	;NAMELIST ITEMS ROLL
	IIDROL=	50	;INTEGER ID ROLL
	SIIROL=	51	;SUBSCRIPT INTEGER ID ROLL
	RIDROL=	52	;REAL ID ROLL
	LIDROL=	53	;LOGICAL ID ROLL
	CRFROL=	54	;CREF ROLL
	ASTROL=	55	;ARRAY STAT ROLL
	DPIROL=	56	;DOUBLE PRECISION ID ROLL
	CIDROL=	57	;COMPLEX ID ROLL
	EDAROL=	60	;EQUIV DATA ROLL
	CDAROL=	61	;COMMON DATA ROLL
	LRONUM=	62	;LAST ROLL NUMBER
	CNAROL=	62	;COMMON NAMES ROLL
	FTAROL=	63	;FIRST TABLE ROLL
	OPCROL=	64	;OP ROLL
	LFUROL=	65	;LIB FUNC ROLL
	CAPHEA=	170000		;COMMON AREA PNTR HEAD
	IBIEXP=	306		;INITIAL BINARY EXPONENT
	MDEEXP=	^D40		;MAX DECIMAL EXPONENT
	NOFREG=	17		;NUMBER OF REGS PLUS 1
	C6PNTR=	206		;COLUMN SIX PNTR

	ZZ=0

	WPL=	^D15		;WORDS PER BUFFER LINE

IFNDEF	NCC0,	<NCC0=	^D4 >
IFNDEF	NCC1,	<NCC1=	^D19 >	;MAX NUMBER OF CARDS PER STATEMENT

	;FIRST BUFFER CONTAINS 20 WORDS INSTEAD OF 15
	;IN ORDER TO PRINT OUT LONGER ERROR MESSAGES
	CBLEN0=	<NCC0+2>*WPL+5	
	CBLEN1=	<NCC1+2>*WPL+5	
		;AND THE REST ARE CONTINUATION CARDS


IFNDEF	EXLEN0,	<EXLEN0= 60>
IFNDEF	EXLEN1,	<EXLEN1=201>	;EXIT ROLL LENGTH

IFNDEF	WORLEN,	<WORLEN=150>	;WORK ROLL LENGTH
IFNDEF	PDPLEN,	<PDPLEN= 20>	;%17 STACK LENGTH
>
;RSITRA,ETYEM,SLPEM,APAEM,AND PINEM MASKS ARE DEFINED AT
;RUN TIME SO THAT THIS IMPURE AREA NEED NOT BE SAVED
RSIEM:
SIGMAS:
RSITRA:			;010000000000	BYTE(3)0,SIGN
	BLOCK 1
RSIATO:	BLOCK 1
ETYEM:			;700000000000	BYTE(3)MASK
	BLOCK 1
EOPPNT:
ETYATO:	BLOCK 1
SLPEM:			;000000777777	BYTE(18)0,MASK
	BLOCK	1
SLBPNT:	BLOCK 1
APAEM:			;000000400000
	BLOCK 1
APAATO:	BLOCK 1
PINEM:			;000000777777	BYTE(18)0,MASK
	BLOCK 1
PINATO:	BLOCK 1
LFUTEM:	BLOCK 1		;700000 000000 BYTE(3) MASK ;"23GG"
LFUATO:	BLOCK 1		;"23GG"

IFN CCLSW,
<	CCLFLA=.+ZZ
	BLOCK 1		;-1 IMPLIES CCL FEATURES BEING USED (ENTRY JOBSA+1)
	INTERNAL CCLFLA
IFN	TEMPC,
<
TMPFLG=.+ZZ
	BLOCK	1
TMPFIL=.+ZZ
	BLOCK	2
	INTERNAL	TMPFLG,	TMPFIL
>>
JOBFFI=.+ZZ
	BLOCK 1		;JOBFF SAVE
CMDBUF=.+ZZ
	BLOCK 1		;COMMAND STRING INPUT BUFFER HEADER BLOCK
CMDPNT=.+ZZ
	BLOCK 1		;COMMAND STRING BYTE POINTER
CMDCNT=.+ZZ
	BLOCK 2		;COMMAND STRING CHAR COUNTER

ZERA:	BLOCK 1
IMPURE=.+ZZ

PDPSW:	BLOCK	1

PROGN:	BLOCK 1
ERRCNT:	BLOCK 1
ERRMSG:	BLOCK	1
LBFLG:	BLOCK	1	;LABLE FIELD FLAG
FEXADR:	BLOCK	1	;FEX ADRE
LCANUM:	BLOCK	1	;LAST CARD NUMBER
NDISCA:	BLOCK	1	;NUM DIGITS SCANNED
NUNPOS:	BLOCK	1	;NUM UNITS POSITIONS
FAICAR:	BLOCK	1	;FAIL CARD-COL
FSTFLA:	BLOCK	1	;FIRST STA FLAG
COPRCT:	BLOCK	1	;CONST PRINT CT
FMSBOX:	BLOCK	1	;FAIL MESSAGE BOX
ERRBOX:	BLOCK	1	;ERROR BOX
CCAFLA:	BLOCK	1
REGSAV:	BLOCK	1		;-1 = SAVE REG 15-16 ONLY
REGCNT:	BLOCK	1	;HIGHEST REGISTER USED	;"21V"
DEFINE:	BLOCK	1	;-1 = CURRENT I/O LIST WILL BE REDEFINED ;"21U"
SAV15:	BLOCK	1	;-1 = REG15 NEEDS TO BE SAVED ;"21V"
SAV16:	BLOCK	1	;-1 = REG16 NEEDS TO BE SAVED ;"21V"
MULRET:	BLOCK	1	;-1 = GENERATE MULT RETURN CODE
ENDCOD:	BLOCK	1	;-1 = CODE FOR END STATEMENT ALREADY GENERATED	;"23P"
LSPDEF:	BLOCK	1	;LOCAL SUBPROGRAM BEING DEFINED ;"23-AM"
;THE FOLLOWING ASSIGNMENTS - THROUGH DAT4 - SHOULD NOT BE SEPARATED

SYMBOL:			;SYMBOL
CANCLU:	BLOCK	1	;COMMON AREA N
MAC1:			;MP AC 1
CON1:			;CONST 1
RPACLU:			;REAL PART CLUE
DAT1:	BLOCK	1		;DATA 1
MAC2:			;MP AC 2
DAT2:	BLOCK	1	;DATA 2
DAT3:	BLOCK	1	;DATA 3
DAT4:	BLOCK	1	;DATA 4
;END OF NON-SEPARABLE SECTION

;THE FOLLOWING SECTION IS ZEROED IN SCAN OPEN

HITCNT:	BLOCK	1	;HITS CNTRS
ISAFLA:	BLOCK	1	;IF STA ACTIVE FLAG
NOPPNT:	BLOCK	1	;NAME OF PROG PNTR
BEXPNT:	BLOCK	1	;BEGIN EXECUTION PNTR
RPRNAM:	BLOCK	1	;R50 NAME
RETPNT:	BLOCK	1	;RETURN POINTER
FARTEM:	BLOCK	1	;FIFTEEN ARG TEMP
ASTFLA:	BLOCK	1	;ACTIVE STA FLAG
IIAFLA:	BLOCK	1	;ILLEGAL IF ARG FLAG
DSTFLA:	BLOCK	1	;DATA STA FLAG
GSTFLA:	BLOCK	1	;GEN STA FLAG
JSTFLA:	BLOCK	1	;JUMP STA FLAG

IFNDEF	$DATA,
<
BDPFLA:	BLOCK	1	;BLOCK DATA PROG FLAG
>
ERRFLA:	BLOCK	1	;ERRORS FLAG
PPEFLA:	BLOCK	1	;PUNCH PEEK FLAG
FORFLA:	BLOCK	1	;FORMAT STA FLAG
ENDFLG:	BLOCK	1	;END= OR ERR= FLAG "22B"
IMDFLG: BLOCK	1	;IMPLIED DO FLG "22K"

;END OF ZEROED SECTION
CRFSW:	BLOCK	1	;CROSS - REFERENCE SWITCH
MACSW:	BLOCK	1	;MACRO CODE LISTING SWITCH
SINFLA:	BLOCK	1	;SUBSCRIPT INTEGER FLAG
QFACCN:	BLOCK	1	;QSA FAIL CCNS
MSTLOC:	BLOCK	1	;MAIN START LOC
CREPNT:	BLOCK	1	;CRRNT REG PNTR

HOLBUF:	BLOCK	1	;HOL BUFF
HBUIND:	BLOCK	1	;HOL BUFF INDEX
ROLPNT:	BLOCK	66

	DEFINE	X	(A)	<
	IRP	A
<	A'PNT=	ROLPNT+A'ROL>
	>

	X	<LBL,UN2,APL,COD,GSP,CPO,HCO,CAR,SCA,ARR>

	X	<NNA,ARE,GAL,ERR,SUB,FRE,APN,GDM,ITE,DST,AST,OPC>
IFNDEF	$DATA,
<
ESIBOX:	BLOCK	1	;ELEMENT SIZE BOX
DDOCNT:	BLOCK	1	;DATA DO CNT
DITCNT:	BLOCK	1	;DATA ITEMS CNT
DLICNT:	BLOCK	1	;DATA LIST CNT
>
MCOFLA:	BLOCK	1	;MINUS CONST FLAG
CLBBOX:	BLOCK	1	;CODE LBL BOX
CBABOX:	BLOCK	1	;CONST BASE BOX
DUSCNT:			;DIGITS USED CNT
REGTEM:	BLOCK	1	;REG TEMP
EXPA:	BLOCK	1	;EXPONENT A
EXPONE:	BLOCK	1	;EXPONENT
EXPSAV:	BLOCK	1	;EXTRA EXPONENT SAVE FOR FCMML
AC1SAV:	BLOCK	1	;AC1 SAVE LOC
DARFLA:	BLOCK	1	;DMY ARRAY FLAG
IOLFLA:	BLOCK	1	;IOL FLAG
JOUFLA:	BLOCK	1	;JUMP OUT FLAG
TEMP:	BLOCK	1	;TEMP
DSPFLA:			;DUMMY SPROG FLAG
SARFLA:	BLOCK	1	;SPROG ARG FLAG
LATPNT:	BLOCK	1	;LAST ASSIGNED TEMP PNTR
LA1S13:	BLOCK	1	;LOOK AHEAD 13 SAVE
LA1S14:	BLOCK	1	;LOOK AHEAD 14 SAVE

PROBRE:			;PROGRAM BREAK
RROFLA:	BLOCK	1	;RESET REG ONE FLAG
FELFLA:	BLOCK	1	;FIRST ELEMENT FLAG
MINBOX:			;MIN REL BOX
ISCBOX:	BLOCK	1	;INTEGER SCANNER BOX
MAXBOX:			;MAX REL BOX
VPNBOX:	BLOCK	1	;VAR PNTR BOX
SMABOX:			;SEG MAX BOX
IBICNT:	BLOCK	1	;INTEGER BITS CNTR
SMIBOX:	BLOCK	1	;SEG MIN BOX
ABLPNT:	BLOCK	1	;AC BLOCK PNTR
ARGCNT:	BLOCK	1	;ARG CNT

ESTFLA:	BLOCK	1	;END STA FLAG
CARNUM:	BLOCK	1	;CARD-COL NUMBERS
LACCCN:	BLOCK	1	;LAST ACTIVE CCNS

TEMCNT:	BLOCK	1	;TEMP CNT
IIVPNT:	BLOCK	1	;INSIDE INDUC VAR PNTR
MLBCNT:	BLOCK	1	;MADE LBL CNT
LOCCNT:	BLOCK	1	;LOC CNTR
LASACT:	BLOCK	1	;LAST ACTIVE13
LTEPNT:	BLOCK	1	;LOCAL TEMP PNTR
STAPSA:	BLOCK	1	;STATUS PSAVE
STACSA:	BLOCK	1	;STATUS CSAVE
STAEXS:	BLOCK	1	;STATUS EXSAVE
STAWKS:	BLOCK	1	;STATUS WKSAVE

LAPTMP:	BLOCK	LACCCN-ESTFLA+1	;LOOK AHEAD POSITION SAVE TEMP
LAPEND=	.-1

SSATMP:	BLOCK	LTEPNT-ESTFLA+1	;STATUS SAVE TEMP
SSAEND=	.-1

STATBS:	BLOCK	63	;STATUS TBSAVE
AFDTPN:	BLOCK	1	;ARITH FUNC DEF TEMP PNTR

RGRTMP:	BLOCK	1	;TEMP STORE FOR RGRSIZ

PSTCRD:	BLOCK	1
;THE FOLLOWING ASSIGNMENTS SHOULD NOT BE SEPARATED.

OARNCL:			;OBJECT ARRAY REF NAME CLUE
ARNCLU:			;ARRAY REF NAME CLUE
FRNCLU:			;FUNC REF NAME CLUE
OPNCLU:			;OP PNTR CLUE
IMPCLU:	BLOCK	1	;IMPLICIT CLUE
AROCLU:			;ARRAY REF OFFSET CLUE
OAROCL:			;OBJECT ARRAY REF OFFSET CLUE
CPOCLU:			;CONST POOL CLUE
CONTEM:			;CONST TEMP
APACLU:			;A PART CLUE
FRAPCL:	BLOCK	1	;FUNC REF ARG PLEX CLUE
TPOBOX:			;SCRIPT EXP CLUE
ACOCNT:			;ABS CODE CNTR
BPACLU:			;B PART CLUE
SEXCLU:	BLOCK	1	;SCRIPT EXP CLUE

IFNDEF	REENTR,<DEPHASE>
WORROL:	BLOCK	WORLEN

TOPS:	BLOCK	66
BOTTOM:	BLOCK	66
ANCHOR:	BLOCK	66

FLOORS=	ANCHOR+1
EROADR:	BLOCK	1

IFNDEF	FILE0,
<

AC00:	BLOCK	1		;AC EXCHANGE BLOCK
AC01:	BLOCK	1
AC02:	BLOCK	1
AC03:	BLOCK	1
AC04:	BLOCK	1
AC05:	BLOCK	1
AC06:	BLOCK	1
AC07:	BLOCK	1
AC10:	BLOCK	1
AC11:	BLOCK	1
AC12:	BLOCK	1
AC13:	BLOCK	1
AC14:	BLOCK	1

ROLMEM:	BLOCK	1		;START OF ROLL MEMORY

CRDCNT:	BLOCK	1		;MAX NUMBER OF CONTINUATION CARDS
PAGCNT:	BLOCK	1		;EXEC PAGE COUNTER
TTLERR:	BLOCK	1		;TOTAL ERROR COUNT
NUMPRO:	BLOCK	1		;NUMBER OF COMPILATIONS
CORSIZ:	BLOCK	1		;LARGEST AMOUNT OF CORE USED

>
PDPSWZ=	PDPSW+ZZ
EXTSAV:	BLOCK	1	;FILNAM EXTENSION FOR HEADER (EXEC)
CEMADR:	BLOCK	1		;CURRENT ERROR MESSAGE ADDRESS
PEMADR:	BLOCK	1		;PRINT ERROR MESSAGE ADDRESS
SEQPNT:	BLOCK	1		;SEQUENCE NUMBER POINTER
FICPNT:	BLOCK	1		;FIRST INPUT CHARACTER POINTER
IFNDEF	FILE0,
<

PROGNZ=	PROGN+ZZ
ERRCNZ=	ERRCNT+ZZ

>
PDPSTK:	BLOCK	PDPLEN		;%17 PUSH-DOWN STACK

XE:	BLOCK	1		;EXEC LOOKUP BLOCK
XE1:	BLOCK	1
XE2:	BLOCK	1
XE3:	BLOCK	1

TTOBUF:	BLOCK	1
TTOPNT:	BLOCK	1
TTOCNT:	BLOCK	1

BINBUF:	BLOCK	1
BINPNT:	BLOCK	1
BINCNT:	BLOCK	1

LSTBUF:	BLOCK	1
LSTPNT:	BLOCK	1
LSTCNT:	BLOCK	1

SRCBUF:	BLOCK	1
SRCPNT:	BLOCK	1
SRCCNT:	BLOCK	1

LINCNT:	BLOCK	1		;EXEC LINE COUNTER

CARBUF:	BLOCK	0

IFDEF	FILE0,
<
	BLOCK	CBLEN0
XITROL:	BLOCK	EXLEN0



	END	F4EXEC
>

	END

;....EOF4

