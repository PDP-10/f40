TITLE FORSE. 	 FORTRAN IV OPERATING SYSTEM 
SUBTTL	V31(224)	30-JUN-71	/DMN

;COPYRIGHT 1971, DIGITAL EQUIPMENT CORP. MAYNARD,MASS.,U.S.A.


;REENT==1 GIVES RE-ENTRANT FORTRAN OP SYSTEM /DMN
IFNDEF REENT,<REENT==0>
IFN REENT,<	HISEG	>



IFNDEF ASTFL,<ASTFL==1	;GIVES ASTERISK FILL ON FORMAT OVERFLOW>
IFE REENT,<IFNDEF FORSE.,<PRINTX ASSEMBLE WITH EITHER DATBS OR HPAR>>
SUBTTL	GLOBAL SYMBOLS


ENTRY		BINWR.
EXTERNAL	JOBFF,JOBREL,JOBUUO
EXTERNAL	ERROR.,LOGEN.,ILLCH.,INIER.,DEVER.,TBLER.,MSNG.,NOROM.
EXTERNAL	LISTB.,REDER.,ENDTP.,ILUUO.,BPHSE.,ILLMG.
EXTERNAL	DEVTB.,IOADR.,DEVND.,ILRED.,PARER.
EXTERNAL	WLKER.,NMLST.,TFMT.,TPFCN.,BUFER.,RANER.
EXTERNAL	NEG1.,NEG2.,NEG3.,NEG5.,DVTOT.
EXTERNAL	ERRINI,TRPINI		;V.021   /TWE
IFN REENT,<	ENTRY	UUOP.>
IFE REENT,<INTERN	UUOL.,UUOH.>
INTERN		DEPOT.,CHINN.,IIB.,ENDLN.,INP.,INPT.
INTERN		XIO.,OUTT.,RIN.,CLOS.,FI.,FIB.,FNCTN.,CLRSY.
INTERN		CLROU.,LOOK.,CLOSI.,SETOU.,STAT.,SESTA.
INTERN		NXTCR.,NXTLN.,WAIT.,BUFCA.,INP.,IORTR.,EOFTS.
INTERN		USET,FCM1,GETDV.
INTERN		MTPZ.,ASTRK.,IOERR.
INTERN		DYDVL.
IFN REENT,<
EXTERNAL	ASVAR.,BLOCK.,CHARS.,WORDS.,RANAC.,RECNO.
EXTERNAL	ALPHA.,OMEGA.
EXTERNAL	DYNND.,FILNUM,FILES.,VADDR.,UUOL.,PDLST.
EXTERNAL	EOL.,DADDR.,TCNT1.,TCNT2.,ONLY1.,EOFFL.
EXTERNAL	TPNTR.,ILLEG.,DELIM.,INIT.
EXTERNAL	TEMP.,UUOH.,DEVIC.,FMTEN.,FMTBG.,FRPTC.
EXTERNAL	BUFHD.,DYNDV.,DYNCH.,DEVNO.,TYPE.,OVFLS.
EXTERNAL	RERDV.,INPDV.,DEVNUM,END.,ERR.
EXTERNAL	MTABF.,MBFBG.,TABPT.,TABP1.,DATTB.
EXTERN	VAR.,DMPIO.,LEVEL.,RANDV.,WDPREC
EXTERN	DECHDR,DEVNAM,DIGPTR,DNAME,EDERR,LINK.,RLINK.,BUFSZ.
EXTERN	ENCHDR,FOBPDP,GRPRPT,HDRADD,INCNT.,INIFLG,INPDEV
EXTERN	LASTLP,LINBUF,LINHDR,RCNT1,RCNT2,RERDN.
EXTERN	RPTR1,RPTR2,SAVEAC,SAVFAC,SAVSCN,LBPTR
EXTERN	PAKFL.,TNAME.,ITMCNT
>
SUBTTL	  ;ACCUMULATORS
A=1		;UTILITY
B=2		;UTILITY
C=3		;UTILITY
D=4		;UTILITY
E=5		;FORMAT DESCRIPTOR
F=6		;FLAG REGISTER (USED IN I/O ROUTINES)
M=7		;ADDR. OF BUFFER HEADER(RH);DEV. NO. (LH)
H=10		;SLIST AOBJN WORD
I=11		;FLAG REGISTER
J=12		;RECORD COUNT(RH);WORD COUNT(LH)-BINARY
K=13		;FORMAT POINTER
L=14		;PARENTHESIS COUNT
G=15		;INPUT BUFFER HDR ADDR.(LH);DEV. NAME ADDR.(RH)
N=16		;FLAGS IN LEFT
P=17		;PUSHDOWN POINTER
IFN REENT,<LOW=16>
IFE REENT,<LOW=0>

	;UUO DEFINITIONS

OPDEF	RESET.	[15B8]
OPDEF	IN.	[16B8]
OPDEF	OUT.	[17B8]
OPDEF	DATA.	[20B8]
OPDEF	FIN.	[21B8]
OPDEF	RTB.	[22B8]
OPDEF	WTB.	[23B8]
OPDEF	MTOP.	[24B8]
OPDEF	SLIST.	[25B8]
OPDEF	INF.	[26B8]
OPDEF	OUTF.	[27B8]
OPDEF	RERED.	[30B8]
OPDEF	NLI.	[31B8]
OPDEF	NLO.	[32B8]
OPDEF	DEC.	[33B8]
OPDEF	ENC.	[34B8]
OPDEF	FCALL.	[35B8]

OPDEF	ERROR	[PUSHJ	P,]	;NEVER RETURNS
OPDEF	PJRST	[JRST]		;POPJ RETURN AT JUMP
OPDEF	DEVSIZ	[CALLI	101]
		MLON

    ;PARAMETER ASSIGNMENTS

LSTBYT==1		;++ LAST BYTE POSN
DQ==42		    ;DOUBLE QUOTE
SL==17		    ;SLASH(SIXBIT)
LF==12		     ;LINE FEED
CR==15		     ;CARRIAGE RETURN
SFCN==10              ;NUMBER OF SPECIAL TAPE FUNCTIONS
LINWDS==^D27		;OUTPUT LINE BUFFER SIZE
LINCH==5*LINWDS		;NO. OF CHARACTERS IN LINE BUFFER
DYDVL.==20		;LENGTH OF DYNAMIC DEVICE TABLE

;DEVCHR BITS

DSKBIT==(1B1)		;DSK
CRDBIT==(1B2)		;CARD I/O
LPTBIT==(1B3)		;LPT
USRTTY==(1B5)		;TTY IS USER'S CONSOL
MTABIT==(1B13)		;MTA
TTYBIT==(1B14)		;TTY
DIRBIT==(1B15)		;DEVICE HAS A DIRECTORY
ASSCON==1B18		;ASSIGNED BY CONSOL

;FLAGS STORED IN RIGHT OF DYNCH.

DFLBIT==1B19		;THIS DEVICE WAS A DEFAULT DEVICE (-1 TO -5)
SPLBIT==1B20		;THIS DEVICE IS SPOOLED
DMPBIT==1B21		;DEV. IS IN RANDOM ACCESS DUMP MODE

;DEVTYP BITS

.TYSPL==(1B13)		;DEVICE IS SPOOLED TO DSK

;FLAGS IN LEFT OF N, PREVIOUSLY FULL WORDS

TTYFL.==1		;TTY OR LPT
CDSFL.==2		;CARD I/O
DOLFL.==4		;NO CR AFTER TEXT
RRDFL.==10		;REREAD
RDWFL.==20		;FORMAT READ TO WRITE ATTEMPT
ENCFL.==40		;ENCODE/DECODE
SPLFL.==100		;SPOOLING TO DSK FOR THIS DEVICE
FKNFL.==200		;DOING RANDOM ACCESS LOOKUP/ENTER FOR UPDATING
DFLFL.==400		;DEFAULT DEVICE
ASSFL.==1000		;ASSIGNED  LOGICAL NAME FOR THIS DEVICE
RELFL.==2000		;DOING RELEAS UUO (FCALL. 0)

;FLAGS CLEARED BY FIN UUO.
FINFL.==-1
INTERN	TTYFL.
;THE FOLLOWING ASSIGNMENTS ARE USED AS ARGUMENTS IN
;TLO INSTRUCTIONS WHICH GENERATE UUO'S.

NMTAPE==(MTAPE)
NCLOSE==(CLOSE)
NINPUT==(INPUT)
NOUTPT==(OUTPUT)
NSETST==(SETSTS)
NINBUF==(INBUF)
NOUBUF==(OUTBUF)
NUSETI==(USETI)
NUSETO==(USETO)
NLOKUP==(LOOKUP)

;STATUS CHECK FLAGS

IOWERR==400000        ;WRITE PROTECTION ERROR
IODERR==200000	     ;DATA MISSED ERROR
IOPERR==100000        ;PARITY OR CHECKSUM ERROR
IOBKTL==40000         ;BLOCK TOO LARGE ON INPUT
IODEND==20000         ;END OF FILE
IOBOT==4000           ;BEGINNING OF TAPE
IOTEND==2000          ;END OF TAPE
IOCON==40             ;CONTINUOUS I-O

;   FLAG		MEANING			ON/OFF

IOF.==	400000		;OUTPUT/INPUT		OUTPUT/INPUT
SFSF.==	200000		;SCALE FACTOR SIGN	-/+
WRTPF.==200000		;WRITE OR READ TAPE	YES/NO
RTNF.==	100000		;RETURN SWITCH		ON/OFF
BFEF.==	 40000		;BUFFER EMPTY(IN)	YES/NO
LFBF.==	 20000		;1ST LF ON BACKSPACE	YES/NO
TFF.==	 20000		;T FORMAT		YES/NO
SLIOF.== 10000		;SLIST I-O		YES/NO
IECF.==	  4000		;INHIBIT EOF CHECK	YES/NO
LRIF.==	  2000		;LAST RECORD IN		YES/NO
NLIOF.==  2000		;NAMELIST I-O		YES/NO
SQF.==	  1000		;"TEXT" IN FORMAT	YES/NO
LROF.==	  1000		;LAST RECORD OUT	YES/NO
STPFF.==   400		;SPECIAL TAPE FUNCTION	YES/NO
FCF.==	   200		;FILE COMMAND		YES/NO
FIOF.==	   100		;FORMAT I-O		YES/NO
DDF.==	    40		;DECTAPE OR DISC	YES/NO
DPSF.==	    20		;DBL. PREC. IN SLIST.	YES/NO
RRF.==	    10		;REREAD UUO		YES/NO
TFBF.==	     4		;T FORMAT BACKSPACE	YES/NO
RPF.==	     2		;() REPEAT FOR LEVEL 0,1YES/NO
DF.==	     1		;DIGIT FLAG		YES/NO

ETYP.==	400000		;E TYPE CONVERSION
GTYP.==	200000		;G TYPE CONVERSION
DTYP.==	100000		;D TYPE CONVERSION
SUBTTL	UUO EXTRY AND EXIT

;RETURN TO USER...RESTORE USER'S AC'S

UXIT.:
FINUX:	MOVSI	17,SAVEAC(LOW)	;SET UP BLT TO RESTORE USER'S AC'S
	BLT	17,15
IFE REENT,<
UUOL.:	EXCH	N,SAVEAC+N	;RESTORE USER AC16>
	MOVE	17,SAVEAC+17(LOW)
RERTN:	MOVE	0,SAVEAC+0(LOW)	;RESTORE AC0
IFE REENT,<JRSTF @UUOH.		;RETURN TO USER>
IFN REENT,<JRST UUOL.(LOW)>



;ENTRY FROM USER

IFE REENT,<UUOH.:	0
	MOVEM	0,SAVEAC+0	;SAVE AC 0
	EXCH	A,JOBUUO	;PICK UP UUO
	LDB	0,[POINT 9,A,8]	;PICK UP UUO OP CODE
	CAIE	0,15		;RESET. ?>
IFN REENT,<UUOP.:>
	JRST	NRES		;NO
				;YES, FALL INTO RESET.
SUBTTL	RESET. UUO

;RELEASE ALL DEVICES IN CASE ANY BUFFERS STILL FULL

	MOVEI	0,17		;CHANNELS 17-0
IFN REENT,<	REL==A
	MOVSI	REL,(RELEAS)	;SET UP UUO>
	DPB	0,[POINT 4,REL,12];DEPOSIT CHANNEL NO.
IFN REENT,<XCT	REL		;IN ACC>
IFE REENT,<
REL:	RELEAS			;****   MODIFIED>
	SOJGE	0,.-2

	RESET			;RESET I/O
IFE REENT,<SETZM SAVEAC+N	;CLEAR ALL FLAGS INITIALLY>
	MOVE	A,FOBPDP(LOW)	;SAVE START OF PUSHDOWN
	MOVEM	A,SAVFAC+P(LOW)	;SAVE POINTER FOR NEXT UUO
	SETZM	ALPHA.(LOW)	;CLEAR DATA BLOCK
IFE REENT,<MOVE	0,[XWD ALPHA.,ALPHA.+1]>
IFN REENT,<HRLI	0,ALPHA.(LOW)
	HRRI	0,ALPHA.+1(LOW)>
	BLT	0,OMEGA.(LOW)	;ZERO DATA BASE
	MOVE	17,PDLST.(LOW)	;INITIALIZE FORTRAN
				;FUNCTION PUSHDOWN POINTER
	PUSHJ	P,ERRINI	;V.021- INITIALIZE ERROR HANDLER
	PUSHJ	P,TRPINI(LOW)	;V.021- INITIALIZE TRAP HANDLER
	HRRZS	UUOH.(LOW)	;V.021- CLEAR ARITHMETIC FLAGS
	MOVE	0,[17,,11]	;STATES WORD
	GETTAB	0,		;GET IT
	  SETZ	0,		;ERROR RETURN
	TLNN	0,(7B9)		;TEST FOR LEVEL D OR LATER
	TDZA	0,0		;NOT LEVEL D
	HRROI	0,-2		;USED FOR EXTENDED LOOKUPS (FUTURE USE)
	MOVEM	0,LEVEL.(LOW)	;STORE RESULT
	JRST	RERTN		;RETURN TO USER

SUBTTL	UUO'S OTHER THAN RESET. COME HERE

NRES:	CAIG	0,35		;CHECK UUO LIMITS
	CAIG	0,15
	PUSHJ	P,ILUUO.	;ILLEGAL UUO VALUE
	SUBI	0,16		;UUO VALUE RELATIVE TO ZERO
	DPB	0,XRP		;PUT UUO IN I.R.FIELD
	MOVE	0,A		;SAVE UUO
	MOVE	A,ACBLT		;SET UP BLT FOR USER'S AC'S
IFN REENT,<ADDI	A,(LOW)>
	BLT	A,SAVEAC+15(LOW)
IFE REENT,<EXCH	N,SAVEAC+N>
	MOVEM	17,SAVEAC+17(LOW)
	MOVE	P,SAVFAC+P(LOW)	;SET UP OP SYS PUSHDOWN POINTER
;SAVE USER'S ACCUMULATORS AND DISPATCH ON UUO

	MOVE	A,0		;UUO
	MOVE	0,JOBUUO	;USER'S AC A
	MOVEM	0,SAVEAC+A(LOW)	;USER'S AC A
	LDB	B,XRP		;RELATIVE UUO VALUE
	JRST	@TABU(B)	;DISPATCH TO UUO ROUTINES


XRP:	POINT	4,A,17		;X.R. FIELD OF UUO

;DISPATCH TABLE FOR INCOMING UUO'S..IN ORDER OF NUMERIC VALUE.

TABU:	IN.	INP		;IN.
	OUT.	OUTP		;OUT.
	DATA.	DATA		;DATA.
	FIN.	FIN		;FIN.
	RTB.	RTB		;RTB.
	WTB.	WTB		;WTB.
	MTOP.	RRBBW		;REW.,REWUN.,BSR.,WEF.,SPR.
	SLIST.	SLIST		;SLIST.
	INF.	INF		;INF.
	OUTF.	OUTF		;OUTF.
	RERED.	REREAD		;RERED.
	NLI.	NLI		;NAMELIST INPUT
	NLO.	NLO		;NAMELIST OUTPUT
	DEC.	DEC		;DECODE
	ENC.	ENC		;ENCODE
	FCALL.	FCALLI		;FORTRAN CALLI

;CALCULATE BUFFER HEADER INFORMATION
;WORDS TO BE SKIPPED IN BUFFER BEFORE DESIRED RECORD= WORDS.
;CHARACTERS TO BE SKIPPED IN BUFFER BEFORE RECORD   = CHARS.
;THE BLOCK TO BE ACCESSED IN WHICH THE RECORD LIES  = BLOCK.
;THIS IS FOR ASCII INPUT

RANASC:	PUSH	P,A
	PUSH	P,B
	MOVE	A,DEVNUM(LOW)	;F4 DEVICE (DATA SET) NUMBER
	IMULI	A,5		;5 WORDS PER DEVICE
IFN REENT,<ADDI	A,(LOW)>
	MOVE	A,FILES.-2(A)	;PICK UP RECORD SIZE IN CHARS
	ADDI	A,2		;CRLF/LINE
	IDIVI	A,5		;WDS/RECORD
	JUMPE	B,.+2		;REMAINDER?
	ADDI	A,1		;YES, ADD ONE FOR REMAINDER
	MOVEM	A,WDPREC(LOW)	;STORE IT AWAY
	MOVEI	B,200		;DSK BUFFER SIZE
	IDIV	B,A		;RECORDS/BUFFER IN B
	MOVE	A,ASVAR.(LOW)	;RECORD # IN FILE TO BE ACCESSED NEXT
	CAMN	A,[-1]		;-1 IS SPECIAL
	JRST	[MOVEM	A,BLOCK.(LOW)
		SETZM	WORDS.(LOW)
		SETZM	CHARS.(LOW)
		JRST	TSTBLK]	;SET ON EOF
	EXCH	A,B
	IDIV	B,A		;REC #/(REC/BUFFER)=BLOCK. IN ACB
	SOJL	C,.+2		;0= LAST RECORD THIS BLOCK
	AOJA	B,.+2		;NEXT BLOCK
	SOS	C,A	;PUT RECORD # IN BLOCK TO BE ACCESSED, IN AC'C' IF LAST.
;BLOCK FOR USETI IN B ,  RECORD # IN 'C'
;SET UP INFO FOR BUFFER HEADER FOR INPUT

	MOVEM	B,BLOCK.(LOW)	;BLOCK #
	MOVE	A,WDPREC(LOW)	;WORDS/RECORD
	IMULI	A,5		;5 PACKED WORDS/RECORD
	IMUL	A,C		;CHARS 'TILL DESIRED RECORD STARTS
	MOVEM	A,CHARS.(LOW)	;STORE
	IMUL	C,WDPREC(LOW)	;WORDS TILL RECORD STARTS
	MOVEM	C,WORDS.(LOW)	;STORE
TSTBLK:	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	HRRE	B,RANDV.(C)	;GET INCORE BLOCK
	CAME	B,BLOCK.(LOW)	;IS IT THE ONE WE WANT?
	PUSHJ	P,RINP.		;NO
	JUMPGE	I,.+2		;OUTPUT?
	HRROS	RANDV.(C)	;YES, SIGNAL OUTPUT FOR THIS BLOCK
	PUSHJ	P,FIXBF		;RESET WORD COUNT AND BYTE POINTER
	SKIPN	A,HDRADD(LOW)	;MIGHT BE USING LINE BUFFER
	MOVE	A,M		;WASN'T
	MOVE	0,2(A)		;GET CHAR COUNT
	SUB	0,CHARS.(LOW)	;SUBTRACT THOSE TO BE SKIPPED
	MOVEM	0,2(A)		;RESET CHAR COUNT
	HRRZ	0,1(A)		;GET ADDR FOR BYTE PTR
	ADD	0,WORDS.(LOW)	;ADD WORDS TO BE SKIPPED
	HRRM	0,1(A)		;RESET PTR
	POP	P,B
	POP	P,A
	JRST	GETAC		;AND RETURN
SUBTTL	FORMAT SCAN INITIALIZATION ROUTINE

IORET:	SKIPGE	RANAC.(LOW)	;DIRECT ACCESS CALLED FOR?
	JRST	RANASC		;YES,GO OFF TO ASCII BLOCK CALC
	JUMPL	I,GETAC		;JUMP ON OUTPUT
	MOVE	0,DEVIC.(LOW)	;GET DEVICE NAME
	MOVEM	0,RERDV.(LOW)	;SAVE INPUT DEVICE NAME
	TLNN	I,RRF.		;REREAD UUO?
	JRST	GETAC		;NO
	MOVE	C,RPTR1(LOW)	;POINTER TO BEGINNING OF LINE
	MOVEM	C,1(M)
	MOVE	C,RCNT1(LOW)	;ORIGINAL ITEM COUNT
	MOVEM	C,2(M)		;IN BUFFER HEADER
GETAC:	LDB	C,PTRU		;AC CONTAINING POINTER TO FMT
	ADDI	C,SAVEAC(LOW)	;ADDRESS OF AC BLOCK
	MOVSI	0,350700
	MOVEM	0,FMTEN.(LOW)	;SET UP POINTER TO END OF FMT
	HRRZ	K,(C)		;POINTS TO BEG. OF FORMAT
	HRLI	K,700		;BYTE SIZE
	HLRZ	0,(K)		;SEE IF JRST AROUND FORMAT
	CAIN	0,(JRST)
	JRST	HRS		;YES,THERE IS A JRST
	SUBI	K,1		;NOT A JRST BUT 1ST WORD OF FMT
	HLRZ	0,(C)		;LENGTH OF FORMAT ARRAY
	JUMPN	0,.+2
	MOVEI	0,^D251		;MAX. NO OF WORDS ALLOWED
	ADD	0,K		;UPPER BOUND ON FORMAT
	MOVEM	K,LASTLP(LOW)	;POINTER TO BEG. OF FORMAT
	MOVEM	K,GRPRPT(LOW)	;POINTER TO BEGINNING OF FMT FOR REPEAT
	AOJA	0,.+2		;POINT TO LAST WORD
HRS:	HRRZ	0,@K		;SET END ADR. FOR COMPARE
	HRRM	0,FMTEN.(LOW)	;END ADDR. OF FORMAT
	MOVEM	K,FMTBG.(LOW)	;POINTER TO BEGINNING OF FORMAT
	TLZ	I,-1-<IOF.!FIOF.!DDF.>	;CLEAR ALL BUT INPUT/OUTPUT, FMT,DIR/DEV
	SETOM	EOL.(LOW)	;SET END OF LINE FLAG AND CHAR. COUNT
	HRRI	E,0		;SCALE FACTOR=0
	CLEARB	L,OVFLS.(LOW)	;() COUNT AND LINE OVERFLOW
IN1:	TLZ	I,RTNF.		;RETURN SWITCH OFF
RIN.:	HRRI	I,0		;CLEAR ROUTINE FLAG
	CLEARB	A,FRPTC.(LOW)	;INITIALIZE COUNTERS
	HRLI	E,0		;INITIALIZE FIELD WIDTH
SUBTTL	CHARACTER SCAN AND DISPATCH

IN:	MOVEM	K,SAVSCN(LOW)
	ILDB	B,K		;NEXT FORMAT CHARACTER
	CAIN	B,11		;CCO 30-15
	MOVEI	B,40		;CCO 30-15
	CAML	K,FMTEN.(LOW)	;CHECK FOR END OF FORMAT
	JRST	PARL
	TRZ	B,100		;CLEAR HIGH ORDER BIT
	TRC	B,40		;CONVERT TO SIXBIT ASCII
	MOVE	C,B		;SAVE FORMAT CHARACTER
	IDIVI	C,7		;SET FOR DISPATCH TABLE ENTRY
	LDB	C,PTRTAB(D)	;PICK UP DISPATCH INDEX
	JRST	@DISTAB(C)	;DISPATCH TO CHARACTER ROUTINE

;CHARACTER IS 0-9

DIG:	TLOE	I,DF.		;SET DIG FLG, SKIP IF IT WASN'T SET
	JRST	.+3
	MOVE	D,SAVSCN(LOW)	;GET PTR POSN BEFORE DIGITS
	MOVEM	D,DIGPTR(LOW)	;SAVE IT FOR RESCAN
	SUBI	B,20		;OCTAL DIGIT
	IMULI	A,12		;ACCUMULATE THE NUMBER
	ADD	A,B
	JRST	IN

; CHARACTER IS .

DECPT:	TSO	E,A		;SET FIELD WIDTH
	TLZ	I,DF.		;CLEAR DIG FLG
	MOVEI	A,0
	JRST	IN


;CHARACTER IS (

PARLF:	PUSH	P,A		;SAVE COUNT
	PUSH	P,K		;SAVE POINTER TO ( IN FORMAT
	TLNN	I,2		;LAST ( ALREADY STORED?
	CAILE	L,1		;SAVE LEVEL 0 OR 1 ONLY
	JRST	PARLF1		;LEVEL 2  DON'T SAVE FOR RESCAN
	TLZN	I,DF.		;CLEAR DIG FLG, SKIP IF IT WAS SET
	JRST	PARLF0		;NO DIGS BEFORE GROUP
	MOVE	A,DIGPTR(LOW)	;DIGS BEFORE GROUP
	MOVEM	A,GRPRPT(LOW)	;SAVE PTR TO 1ST LEVEL GROUP FOR RESCAN
	JRST	PARLF2		;SKIP
PARLF0:	MOVEM	K,GRPRPT(LOW)	;SAV PTR TO ( IN GROUP REPEAT
PARLF2:	MOVEM	K,LASTLP(LOW)	;SAVE POINTER TO (
PARLF1:	MOVEI	A,0
	AOJA	L,IN		;ADD ONE TO () COUNT

;CHARACTER IS )

PARR:	PUSHJ	P,COMMA		;DO CONVERSION IF NECESSARY
	HRRI	I,0		;PREVENT FURTHER CONVERSION
	SOJG	L,PARG		;OFFSET (
	TLON	I,RPF.		;CHECK FOR AUTO. FORMAT REPEAT
	JUMPL	L,PARL
	SKIPLE	-1(P)		;CHECK () COUNT
	JRST	PARG

PARL:	PUSHJ	P,COMMA		;PERFORM CONVERSION
	PUSHJ	P,ENDLN.	;TERMINATE THIS LINE
	HRRZ	0,INIFLG(LOW)
	CAIL	0,2
	SUB	P,[XWD 2,2]	;COMPENSATE FOR () PUSH
	TLO	I,RTNF.		;RETURN SWITCH ON
	MOVE	K,GRPRPT(LOW)	;RESET SCAN AT LAST 1ST LEVEL GROUP
	TLZ	I,1		;CLEAR GRP PEPEAT FLG

;RETURN TO USER FOR DATA ADDRESS OR TERMINATION OF SCAN

IORTR.:	TLNE	I,SLIOF.	;SLIST?
	JRST	NAS		;YES
NASBAK:	SKIPGE	EDERR(LOW)	;++ ENCODE DECODE ERROR?
	JRST	EDERRM		;++ YES,TYPE OUT MESSAGE SKIP TO FIN.
	MOVEI	0,SAVFAC(LOW)	;SAVE OP SYS AC'S
	BLT	0,SAVFAC+P(LOW)
	JRST	UXIT.

;RESET SCAN AT LAST LEFT ( AND DROP COUNT

PARG:	SOSLE	-1(P)		;DROP () COUNT
	JRST	MSP
	SUB	P,[XWD 2,2]	;RESET P TO POINT TO LAST (
	JRST	IN1		;GET NEXT FORMAT CHARACTER
MSP:	MOVE	K,(P)		;RESET SCAN AT LAST (
	AOJA	L,IN1		;BUMP COUNT FOR RESCAN

;CHARACTER IS -

NEGSC:	TLO	I,SFSF.		;SCALE FACTOR SIGN
	TLZ	I,DF.		;DIG FLAG
	JRST	IN
;CHARACTER IS /

SLASH:	TLNE	N,ENCFL.	;/ IS ILLEGAL IN ENCODE-DECODE
	TTCALL	3,[ASCIZ ?WARNING! / IS ILLEGAL IN ENCODE-DECODE, END OF FORMAT ASSUMED
?]
	PUSHJ	P,COMMA		;CONVERSION,IF ANY
	PUSHJ	P,ENDLN.	;TERMINATE LINE
	JRST	RIN.

    ;CHARACTER IS SINGLE QUOTE

SQUOTE:	SETO	A,		;NO LIMIT TO CHARACTER COUNT
	TLO	I,SQF.		;SINGLE QUOTE FLAG

;CHARACTER IS H

HIO:	TLZ	I,DF.		;CLEAR DIG FLAG
	JUMPE	A,RIN.
	HRRZ	B,FMTEN.(LOW)	;END OF FORMAT
	SUBI	B,(K)		;BEG OF FORMAT
	IMULI	B,5
	JUMPGE	I,HINPT		;JUMP ON INPUT
HLDB:	ILDB	0,K		;CHARACTER FROM FORMAT
	SOJE	B,PARL		;TEST FOR END
	TLNN	I,SQF.		;SINGLE QUOTE?
	JRST	HDPB		;NO
	CAIN	0,"'"		;SINGLE QUOTE IN FORMAT?
	PUSHJ	P,DBLQTE	;TEST FOR TWO SINGLE QUOTES
HDPB:	PUSHJ	P,DEPOT.	;DEPOSIT CHARACTER
	SOJN	A,HLDB		;DROP COUNT
	JRST	RIN.
HINPT:	PUSHJ	P,CHINN.	;GET A CHARACTER
	SKIPN	OVFLS.(LOW)	;DON'T ADVANCE IF END OF LINE
	XCT	IIB.
	SOJE	B,PARL		;TEST FOR END
	ILDB	C,K		;CHARACTER FROM FORMAT
	TLNN	I,SQF.		;SINGLE QUOTE?
	JRST	HINDPB		;NO
	CAIN	0,"'"		;SINGLE QUOTE IN INPUT?
	MOVEI	0,DQ		;CHANGE TO "
	CAIN	C,"'"		;SINGLE QUOTE IN FORMAT?
	PUSHJ	P,DBLQTE	;YES,TEST FOR TWO SINGLE QUOTES
HINDPB:	CAIE	0,15		;IS CHAR. A CARRIAGE RETURN?
	JRST	.+3		;NO
	SKIPE	OVFLS.(LOW)	;YES, END OF LINE SEEN?
	MOVEI	0,40		;YES, SUBSTITUTE A BLANK
	DPB	0,K		;PUT CHARACTER IN FORMAT
	SOJN	A,HINPT		;DROP COUNT
	JRST	RIN.

DBLQTE:	PUSH	P,K		;SAVE FORMAT POINTER
	ILDB	C,K		;LOOK FOR SINGLE QUOTE
	CAIE	C,"'"
	JRST	ET		;END OF TEXT
	POP	P,(P)		;RESET STACK
	POPJ	P,
ET:	POP	P,K		;RESTORE FORMAT POINTER
	POP	P,0
	TLZ	I,SQF.		;CCO 30-12, CLEAR SINGLE QUOTE FLG
	JRST	RIN.		;RETURN TO SCAN
;CHARACTER IS X

XIO.:	TLZ	I,DF.		;CLEAR DIG FLG
	JUMPGE	I,XINPT		;JUMP IF INPUT
	MOVEI	0," "		;BLANK
	PUSHJ	P,DEPOT.	;OUTPUT A BLANK
	SOJG	A,.-1
	JRST	RIN.
XINPT:	PUSHJ	P,CHINN.	;SKIP A CHARACTER
	SKIPN	OVFLS.(LOW)	;DON'T ADVANCE IF END OF LINE
	XCT	IIB.		;ADVANCE INPUT POINTER
	SOJG	A,XINPT
	JRST	RIN.


;CHARACTER IS P

PIO:	TLZ	I,DF.		;CLEAR DIG FLAG
	TLZE	I,SFSF.		;TEST FOR SCALE SIGN
	MOVNS	A		;SCALE NEGATIVE
	HRR	E,A		;SET SCALE FACTOR
	JRST	RIN.

;CHARACTER IS T

TIO:	TLOA	I,TFF.		;T FORMAT AND SKIP

;CHARACTER IS $

DOLSGN:	TLO	N,DOLFL.	;$ CARRIAGE CONTROL CHAR.
	TLZ	I,DF.		;CLEAR DIG FLG
	JRST	RIN.		;RETURN TO SCAN

;CHARACTER IS A,D,E,F,G,I,L,O

;CHARACTER IS G

GCONV:	TLOA	E,GTYP.		;G FLAG

AEIOU:	PUSHJ	P,RTNSET	;PICK UP CONV. ROUTINE ADDRESS
AEIOU1:	MOVEM	A,FRPTC.(LOW)	;SAVE DATA COUNT
	SETZ	A,		;CLEAR DECIMAL DIGIT AC
	TLZ	I,DF.		;CLEAR DIG FLAG
	JRST	IN		;RETURN TO FORMAT SCAN

RTNSET:	LDB	C,[POINT 6,DISTAB(C),11];ROUTINE INDEX
	JUMPGE	I,.+2		;INPUT OR OUTPUT ROUTINE NEEDED?
	ADDI	C,1		;OUTPUT
	HRR	I,IOADR.(C)	;PICK UP ROUTINE ADDRESS
	POPJ	P,

;CHARACTER IS ,

COMA:	PUSHJ	P,COMMA		;CONVERSION,IF ANY
	JRST	RIN.

;CHARACTER IS E

ECONV:	TLOA	E,ETYP.		;SET E FLAG AND SKIP

;CHARACTER IS D

DCONV:	TLO	E,DTYP.		;SET D FLAG
	JRST	AEIOU
;ROUTINE TO SET FORMAT WORD & GO TO CONVERSION SUBPROGRAMS

COMMA:	TLZ	I,DF.		;CLEAR DIG FLAG
	TLZE	I,TFF.		;T FORMAT?
	JRST	TFMT.		;YES
	TLNE	E,GTYP.		; G TYPE?
	JRST	COMMA1		;YES
	TRNN	I,-1		;CONVERSION NECESSARY?
	POPJ	P,		;NO CONVERSION
COMMA1:	ANDI	A,177		;W AND D MOD 128
	MOVSS	A
	TLNE	E,177		;IS THERE A FIELD WIDTH?
	ASH	A,7		;SHIFT TO D FIELD
	IOR	E,A
	TLZN	I,RTNF.		;RETURN SWITCH ON?
	JRST	IORTR.		;GET AN ADDRESS
	JRST	CNVT		;DO CONVERSION
SUBTTL	DATA. UUO

DATA:	PUSH	P,A		;SAVE UUO
	MOVSI	0,SAVFAC(LOW)	;RESTORE OP SYS AC'S
	BLT	0,15		;ALL BUT 16 AND 17
	POP	P,A		;PICK UP UUO
	HRRZ	C,A		;UUO ADDRESS
	CAIGE	C,20		;SEE IF DATUM IN AC
	ADDI	C,SAVEAC(LOW)	;YES,PICK UP FROM SAVE LOC.
	MOVEM	C,DADDR.(LOW)	;SAVE DATA ADDRESS
	LDB	C,PTRU		;AC FIELD CONTAINS TYPE CODE
	MOVEM	C,TYPE.(LOW)	;SAVE TYPE
	CAIGE	C,6		;IF DATA IS NEITHER COMPLEX NOR
	JRST	TFB		;DOUBLE PRECISION, GO TO TFB
	CAIN	C,7		;IF DATA IS COMPLEX,
	JRST	TFBM3		;OR
	HRRZ	0,I		;IF DATA IS DOUBLE PRECISION
	CAIE	0,14		;AND THE MODE IS BINARY, GO
	JRST	TFB3		;TO TFBM3.
TFBM3:	TLO	I,SLIOF.	;SET SLIST FLAG
	MOVSI	H,-2		;ARRAY OF LENGTH 2
	HRR	H,A		;ARRAY ADDRESS
TFB:	HRRZ	0,I		;PICK UP MODE
	CAIN	0,14		;BINARY MODE?
	JRST	BINDT.		;YES
TFB3:	TLNE	I,RTNF.		;RETURN SWITCH ON?
	JRST	RIN.		;YES,GO TO FORMAT SCAN
CNVT:	SKIPGE	FRPTC.(LOW)	;CHECK REPEAT COUNT
	POPJ	P,
	TLNN	E,GTYP.		;G FORMAT?
	JRST	NOTGTY		;NO
	MOVE	C,TYPE.(LOW)	;PICK UP DATUM TYPE
	CAIN	C,6		;CHECK FOR DOUBLE WORD
	TLO	E,DTYP.		;SETS DOUBLE PRECISION
	PUSHJ	P,RTNSET	;PICK UP CONV. ROUTINE ADDRESS
NOTGTY:	PUSH	P,E		;FORMAT SPECIFICATION
	MOVE	C,DADDR.(LOW)	;ADDRESS OF DATUM
	JUMPL	I,OUTCNV	;JUMP IF OUTPUT
	PUSHJ	P,(I)		;INPUT CONVERSION
	JRST	CHECK		;ILLEGAL CHAR IN INPUT
	MOVEM	0,(C)		;STORE HIGH ORDER WORD
	TLNE	E,DTYP.		;IS THERE A LOW ORDER PART?
	MOVEM	A,1(C)		;YES ,STORE IT
SOSO:	POP	P,0		;ACCOUNT FOR FORMAT WORD
	SOSLE	FRPTC.(LOW)
	JRST	IORTR.		;GET NEXT ADDRESS
	TLZ	E,GTYP.		; CLEAR G FORMAT FLAG
	POPJ	P,		;REPEAT COUNT IS ZERO

OUTCNV:	MOVE	0,(C)		;PICK UP HIGH ORDER PART
	MOVE	A,1(C)		;PICK UP LOW ORDER PART
	PUSHJ	P,(I)		;OUTPUT CONVERSION
	JRST	SOSO


CHECK:	SKIPN	ERR.(LOW)	;DOES THE USER DESIRE PROGRAM CONTROL?
	JRST	ILLCH.		;NO, PRINT ERROR MESSAGE AND FAIL
	PUSHJ	P,NXTCR		;YES,FINISH UP THIS LINE
	JRST	FI.		;GO TO POSITION SPECIFIED

SUBTTL	SLIST. UUO    SHORT LIST I/O

;THE AC OF THE SLIST UUO CONTAINS THE TYPE CODE--0 FOR INTEGER,
;6 FOR DOUBLE PRECISION, AND 7 FOR COMPLEX.  FOR DOUBLE
;PRECISION TWO WORDS ARE PASSED AT A TIME. THE ADDRESS OF
;THE UUO CONTAINS THE ARRAY BASE ADDRESS. THE WORD FOLLOWING
;THE SLIST. UUO CONTAINS THE LENGTH OF THE ARRAY.
;ADDRESS OF THE ARRAY IN THE RIGHT HALF.



SLIST:	PUSH	P,A		;SAVE UUO
	HRLZI	0,SAVFAC(LOW)	;RESTORE OP SYS AC'S
	BLT	0,15		;ALL BUT 16 AND 17
	POP	P,A		;UUO
	TLO	I,SLIOF.	;SLIST FLAG
	LDB	C,PTRU		;AC FIELD OF UUO
	MOVEM	C,TYPE.(LOW)	;SAVE TYPE CODE
	HRLZ	H,@UUOH.(LOW)	;ARRAY LENGTH
	AOS	UUOH.(LOW)	;UPDATE RETURN ADDRESS
	HRRZ	0,I
	CAIN	0,14		;SKIP IF NOT BINARY MODE
	JRST	SLISTB		;CAN DO BLT'S FOR BINARY MODE ARRAYS
	MOVNS	H		;NEGATE LENGTH
	CAIN	C,7		;IS ARRAY COMPLEX?
	ASH	H,1		;YES,MULTIPLY BY 2
	CAIN	C,6		;IS ARRAY DOUBLE PRECISION?
	TLO	I,DPSF.		;YES,SET FLAG
	HRR	H,A		;BASE ADDRESS
HRS1:	HRRZM	H,DADDR.(LOW)	;SAVE SLIST ADDRESS
	JRST	TFB		;DO CONVERSION OR SCAN

;CONTROL TRANSFERRED HERE FOR EACH ADDRESS
;ALSO USED FOR SINGLE COMPLEX ITEMS.

NAS:	TLNE	I,DPSF.		;IS ARRAY DOUBLE PRECISION?
	ADDI	H,1		;ACCOUNT FOR 2 WORDS
	AOBJN	H,HRS1		;SET FOR NEXT DATUM
	TLZ	I,SLIOF.!DPSF.	;RESET SLIST FLAGS
	JRST	NASBAK		;RETURN TO USER

;HERE FOR BINARY MODE ARRAYS

SLISTB:	HRRZM	A,DADDR.(LOW)	;ADDRESS OF ARRAY
	HLRZS	H		;LENGTH OF ARRAY
	CAIE	C,6		;DOUBLE PRECISION?
	CAIN	C,7		;OR COMPLEX?
	ASH	H,1		;YES, DOUBLE NUMBER OF WORDS
SLISB0:	JUMPGE	I,SLISB1	;JUMP IF INPUT
	TLZE	I,LROF.		;SKIP IF OUTPUT BUFFER NOT FULL
	PUSHJ	P,BINO.		;OUTPUT BUFFER
	JRST	SLISB2
SLISB1:	SKIPG	2(M)		;SKIP IF INPUT BUFFER NOT EMPTY
	PUSHJ	P,BINI.		;FILL BUFFER
SLISB2:	MOVE	C,H		;C=WORDS STILL NEEDED
	CAMLE	C,2(M)		;SKIP IF FITS IN BUFFER
	MOVE	C,2(M)		;NO, CUT DOWN TO BUFFER SIZE
	SUB	H,C		;SUBTRACT WORDS TO BE TRANSFERRED
	JUMPGE	I,SLISB3	;DONT COUNT WORDS FOR INPUT
	HRLZ	A,C		;WORDS THIS BLT
	ADD	J,A		;COUNT WORDS ON OUTPUT
SLISB3:	SUBM	C,2(M)		;SUBTRACT WORDS TRANSFERRED FROM WORDS LEFT IN BUFFER
	MOVNS	2(M)		;EXCEPT ITS NEGATIVE THAT WAY
	HRLZ	A,DADDR.(LOW)	;ADDRESS IN ARRAY OF NEXT DATUM
	HRR	A,1(M)		;ADDR OF BUFFER - 1
	ADDI	A,1		;BLT POINTER
	JUMPGE	I,SLISB4	;JUMP IF INPUT
	ADDM	C,DADDR.(LOW)	;ADDR PAST END OF THIS BLT FROM ARRAY
	ADDB	C,1(M)		;AND LAST ADDRESS IN BUFFER FOR BLT
	AOJA	C,SLISB5	;+1 FOR OUTPUT - ALL SET FOR BLT
SLISB4:	ADDM	C,1(M)		;ADDR IN BUFFER AFTER BLT FOR INPUT
	ADDB	C,DADDR.(LOW)	;ADDR PAST END OF BLT IN ARRAY FOR INPUT
	MOVSS	A		;SWAP BLT POINTER FOR INPUT
SLISB5:	BLT	A,-1(C)		;TRANSFER DATA TO/FROM BUFFER
	JUMPGE	I,SLISB6	;DONT WORRY IF INPUT ABOUT EMPTY BUFFER
	SKIPN	2(M)		;SKIP IF OUTPUT BUFFER NOT EMPTY
	TLO	I,LROF.		;FORCE OUTPUT BEFORE NEXT TRANSFER
SLISB6:	JUMPN	H,SLISB0	;LOOP IF MORE DATA IN ARRAY
	TLZ	I,SLIOF.!DPSF.	;ALL DONE, CLEAR SLIST FLAGS
	JRST	NASBAK		;AND EXIT
SUBTTL	TABLE OF POINTERS FOR CHARACTER DISPATCH

PTRTAB:	REPEAT 7,<	POINT 5,IRTAB(C),34-<.-PTRTAB>*5>


;TABLE OF DISPATCHING INDICES

IRTAB:	BYTE (5) 0,0,26,0,0,0,10
	BYTE (5) 6,13,10,0,12,11,24
	BYTE (5) 7,7,7,7,7,1,5
	BYTE (5) 0,0,7,7,7,7,7
	BYTE (5) 0,16,0,0,0,0,0
	BYTE (5) 20,2,14,17,15,23,0
	BYTE (5) 3,21,0,0,22,0,0
	BYTE (5) 0,0,0,25,0,0,0
	BYTE (5) 0,0,0,0,0,0,4
	BYTE (5) 0,0,0,0,0,0,0
SUBTTL	DISPATCH TABLE USED FOR CHARACTER DISPATCH
;AND INDICES FOR CONVERSION ROUTINE NAMES.
;THE LEFT HALF OF THE FIRST 8 ENTRIES CONTAINS AN INDEX
;TO ENTRIES IN THE TABLE OF CONV. ROUTINE ADDRESSES,IOADR.,
;FOR G FORMAT.
;THE LEFT HALF OF THE ENTRIES FOR E,A,F,I,O,L,D CONTAINS
;AN INDEX TO THE ENTRIES IN IOADR. CORRESPONDING TO E,A,F,I,O,L,D.

DISTAB:	XWD	400,ERROR1	; ILLEGAL
	XWD	000,SLASH	;/
	XWD	200,HIO		;H
	XWD	1000,PIO	;P
	XWD	600,XIO.	;X
	XWD	000,DECPT	;.
	XWD	1200,NEGSC	;-
	XWD	200,DIG		;0-9
	XWD	000,IN		;BLANK OR +
	XWD	0,PARLF		;(
	XWD	0,PARR		;)
	XWD	0,COMA		;,
	XWD	000,GCONV	;G
	XWD	200,ECONV	;E FLOATING
	XWD	000,AEIOU	;A ALPHANUMERIC
	XWD	200,AEIOU	;F FLOATING
	XWD	400,AEIOU	;I FIXED
	XWD	600,AEIOU	;O OCTAL
	XWD	1000,AEIOU	;L LOGICAL
	XWD	1200,DCONV	;D    DOUBLE PRECISION
	XWD	000,SQUOTE	;'   TEXT
	XWD	000,TIO		;T  COLUMN SETTING
	XWD	000,DOLSGN	;$ CARRIAGE CONTROL

ERROR1:	PUSHJ	P,ERROR.	;ILLEGAL CHARACTER IN FORMAT
SUBTTL	OUTPUT ROUTINES

;DEPOT. IS CALLED BY ALL OUTPUT ROUTINES FOR DEPOSITING
;CHARACTERS IN THE OUTPUT BUFFER AND DOING OUTPUTS. THE
;CHARACTER IS SENT IN AC 0 AND AC M IS USED.DEPOT. IS 
;CALLED BY   PUSHJ P,DEPOT.

DEPOT.:	TLNE	N,ENCFL.	;++ ENCODE?
	JRST	ENCOUT		;++ DON'T MESS AROUND WITH CRLF STUFF
	AOSG	EOL.(LOW)	;IS THIS THE FIRST CHARACTER?
	JRST	FRSTCH		;YES, MAKE SOME CHECKS
				;NOT FIRST CHARACTER SO FALL INTO CO

;OUTPUT ROUTINE CALLED BY DEPOT. FOR DEPOSITING CHARACTERS
;IN PROPER BUFFER,CHECKING LINES FOR OVERFLOW, DOING OUTPUTS
;AND ERROR CHECKING.

CO:	TLNN	N,TTYFL.	;TTY OR LPT?
	SKIPG	HDRADD(LOW)	;LINE BUFFER IN USE?
	JRST	DLB		;NO
	SKIPE	OVFLS.(LOW)	;LINE OVERFLOW?
	JRST	LBCRCK		;YES,LOOK FOR CR
	IDPB	0,1(M)		;NO,DEPOSIT CHARACTER
	SOSG	2(M)		;BUFFER FULL?
	JRST	LBXCD		;YES,STASH CR,LF
LBCRCK:	CAIE	0,CR		;CARRIAGE RETURN?
	POPJ	P,		;NO,KEEP LOOKING
STLF:	PUSH	P,0		;SAVE OUTPUT CHARACTER
	PUSH	P,A		;GET AN AC. TO PLAY WITH
	SETZM	OVFLS.(LOW)	;CLEAR LINE OVERFLOW SWITCH
	MOVEI	0,LF		;PICK UP LINE FEED
	IDPB	0,1(M)		;DEPOSIT IT
	HRR	A,HDRADD(LOW)	;ADDRESS OF REAL BUFFER HEADER
NOTRN1:	MOVE	0,2(M)		;COUNT OF CHARS. LEFT IN LINE BUFFER
	SUBI	0,LINCH+1	;LENGTH OF LINE BUFFER +1 FOR LF
	ADDM	0,2(A)		;UPDATE REAL BUFFER COUNT
	SKIPGE	2(A)		;IF NEGATIVE,DO OUTPUT
	JRST	BOUT
BLTSET:	MOVEI	0,@1(M)		;WHERE POINTER IS NOW
	SUBI	0,LINBUF-1(LOW)	;NO. OF WORDS IN LINE BUFFER
IFN REENT,<BUFBLT==C
	PUSH	P,BUFBLT	;SAVE AC
	MOVSI	BUFBLT,(BLT)>
	HRRM	0,BUFBLT	;NO. OF WORDS TO BLT
	HRRZ	0,1(A)		;ADDRESS OF REAL BUFFER
	ADDM	0,BUFBLT	;BLT LIMIT
IFE REENT,<ADD	0,[XWD LINBUF,1];FROM-TO FOR BLT>
IFN REENT,<HRLI	0,LINBUF(LOW)
	ADDI	0,1
	XCT	BUFBLT		;XCT IN ACC>
IFE REENT,<
BUFBLT:	BLT	0,0		;***THIS ADDRESS MODIFIED>
	HRR	0,BUFBLT	;LAST WORD USED
IFN REENT,<POP	P,BUFBLT	;RESTORE ACC>
	HLL	0,1(M)		;POSITION AND SIZE
	MOVEM	0,1(A)		;UPDATED REAL BUFFER POINTER
	LSHC	0,-36-44	;POSITION
	DIV	0,[-7]		;GET NUMBER OF NULLS
	HRR	A,HDRADD(LOW)	;ADDRESS OF REAL BUFFER HEADER
	ADDM	0,2(A)		;ACCOUNT FOR NULLS
ZELB:	SETZM	LINBUF(LOW)	;CLEAR LINE BUFFER
IFE REENT,<MOVE	0,[XWD LINBUF,LINBUF+1]>
IFN REENT,<MOVSI 0,LINBUF(LOW)
	HRRI	0,LINBUF+1(LOW)>
	BLT	0,@1(M)		;CLEAR UP TO LAST WORD USED
	MOVEI	0,LINCH		;RESET ITEM COUNT
	MOVEM	0,2(M)	
	MOVE	0,LBPTR(LOW)	;RESET POINTER
	MOVEM	0,1(M)		;TO BEGINNING OF LINE BUFFER
	AOS	ASVAR.(LOW)	;INCREASE VALUE OF ASSOCIATED VARIABLE
	POP	P,A		;RESTORE A
	POP	P,0		;RESTORE CHARACTER
	POPJ	P,		;RETURN
BOUT:	TLNE	N,ENCFL.	;++ NO OUTPUT FOR ENCODE
	JRST	[SETOM	EDERR(LOW)	;++SET ERROR FLAG
		POP	P,A	;++RESTORE A
		JRST	NOLOK1]	;++RETURN
	PUSH	P,0		;SAVE ITEM COUNT
	PUSHJ	P,OUTOK		;DO OUTPUT
	POP	P,0		;RESTORE ITEM COUNT
	ADDM	0,2(A)		;PUT INTO BUFFER HEADER
	JRST	BLTSET		;DUMP AND CLEAR LINE BUFFER

LBXCD:	CAIN	0,CR		;WAS LAST CHAR. A CR?
	JRST	STLF		;YES,STASH LF
	PUSH	P,0		;SAVE CHAR.
	HRLI	0,170700	;NO,SET POINTER FOR CR
	HLLM	0,1(M)
	MOVEI	0,CR		;PICK UP CR
	IDPB	0,1(M)		;STASH IT
	SETOM	OVFLS.(LOW)	;SET LINE OVERFLOW FLAG
	POP	P,0		;RESTORE CHAR.
	POPJ	P,

DLB:	IDPB	0,1(M)		;DEPOSIT CHARACTER
	SOSLE	2(M)		;DROP ITEM COUNT
	CAIN	0,CR
	JRST	.+2
	POPJ	P,
	PUSH	P,0		;SAVE CHAR.
	TLNE	N,DOLFL.	;CHECK FOR $
	MOVEI	0,0		;YES,CLEAR OUT CR
	DPB	0,1(M)		;DEPOSIT CHARACTER
	SKIPLE	2(M)		;ALWAYS OUTPUT IF BUFFER FULL
	TLNN	N,SPLFL.	;BUT NOT IF SPOOLING AND BUFFER NOT FULL
	PUSHJ	P,OUTOK		;DO OUTPUT AND CHECK STATUS
	POP	P,0		;RESTORE CHAR.
	POPJ	P,		;RETURN

OUTOK:	PUSHJ	P,OUTT.		;DO OUTPUT
	PUSH	P,F		;SAVE F-USED FOR STATUS
	PUSHJ	P,STAT.		;GET STATUS
	TRNE	F,IOWERR!IODERR!IOPERR!IOBKTL!IOTEND
	PUSHJ	P,IOERR.	;I/O ERRORS
	SETZM	OVFLS.(LOW)	;CLEAR LINE OVERFLOW SWITCH
	POP	P,F		;RESTORE F
	POPJ	P,
;HERE FOR FIRST CHARACTER ON A LINE

FRSTCH:	TLNE	N,CDSFL.	;CARDS...FORCE LF ON OUTPUT
	JRST	[PUSH	P,0	;SAVE CHAR
		MOVEI	0,LF	;GET LINE FEED
		PUSHJ	P,CO	;OUTPUT IT
		POP	P,0	;GET THE CHAR
		JRST	CO]	;OUTPUT THAT CHAR
	TLNN	N,TTYFL.	;TTY OR LPT?
	JRST	CO		;NO
	PUSH	P,0		;SAVE 0
	PUSH	P,A		;SAVE AC
	MOVE	A,0		;CONTROL CHARACTER
	MOVEI	0,LF		;LINE FEED
	CAIN	A,"0"		;0?
	JRST	ZE		;YES
	CAIN	A," "		;BLANK?
	JRST	POPA		;YES
	CAIN	A,"-"		;-  SKIP TWO LINES
	JRST	MI		;MINUS SIGN
	HRRI	A,-52(A)	;LOOK FOR CODE
	JUMPL	A,POPA		;SKIP A LINE IF NOT IN RANGE
	CAILE	A,11		;NOT IN RANGE
	JRST	POPA		;THEN ISSUE LF
	HRRZ	0,TABLE(A)	;SELECT CONTROL CHARACTER
	JRST	POPA		;DEPOSIT CONTROL CHARACTER
MI:	PUSHJ	P,CO		;DEPOSIT CHARACTER
ZE:	PUSHJ	P,CO		;DEPOSIT CHARACTER

POPA:	POP	P,A		;RESTORE A
NOLOOK:	PUSHJ	P,CO		;DEPOSIT CHARACTER
NOLOK1:	POP	P,0
CPOPJ:	POPJ	P,

;ASTRK. OUTPUTS ASTERISKS IF THE FORMAT FIELD IS TOO SMALL FOR
;THE NUMBER TO BE OUTPUT
;EXPECTS FIELD WIDTH IN AC 4 (NUMBER OF * TO GO OUT)
	ACW==4
ASTRK.:
IFN ASTFL,<MOVEI 0,"*"		;SET UP *
	PUSHJ	P,DEPOT.	;OUTPUT IT
	SOJG	ACW,.-1		;LOOP>
IFE ASTFL,<HALT	.+1		;HALT IF GET HERE, RETURN ON CONTINUE>
	POPJ	P,		;TIL DONE

;++ THIS REPLACES THE OUTPUT STUFF FOR REGULAR OUTPUT. DOES NO CRLF
;++ INSERTS, JUST DEPOSITS CHAR.

ENCOUT:	SKIPGE	OVFLS.(LOW)	;++LINE END. FMT OR CHAR CNT.
	JRST	ENCOU1		;++OVFLS. SET.
	IDPB	0,1(M)		;++DEPOSIT BYTE
	SOSG	2(M)		;++ DROP CHAR COUNT
ENCLND:	SETOM	OVFLS.(LOW)	;++END OF RECORD OR BUFFER.
	POPJ	P,		;++RETURN FOR MORE

ENCOU1:	SKIPN	HDRADD(LOW)	;++USING LINE BUFFER?
	JRST	[SKIPG	2(M)	;++NOT LINE BUFFER. WAS OVFLS. FMT OR COUNT?
		SETOM	EDERR(LOW)	;++COUNT TO ZERO. FATAL ERROR .
		POPJ	P,]	;++IF FMT END LINE IGNORE. RETURN.
	SETZM	OVFLS.(LOW)	;++USING LINE BUFFER, CLEAR FLAG.
	PUSH	P,0		;++SAVE 0
	PUSH	P,A		;++SAVE AC
	MOVE	A,HDRADD(LOW)	;++GET ADDRESS INTO A
	JRST	NOTRN1		;++GO DO BLT.

TABLE:	OCT 23			;*,CR WITH NO FF AFTER 60 LINES
	OCT 0			;+, NULL
	OCT 21			;,,THIRTIETH
	OCT 0			;-,SKIP 2 LINES
	OCT 22			;.,TWENTIETH
	OCT 24			;/,SIXTH
	OCT 0			;0,SKIP 1 LINE FF AFTER 60 LINES
	OCT 14			;1,TOP OF FORM
	OCT 20			;2, HALF
	OCT 13			;3, THIRD OR V.T.
;END OF FORMAT ROUTINES
SUBTTL	END OF LINE

ENDLN.:	TLZN	I,TFBF.		;T FORMAT THIS LINE
	JRST	NOTTL		;NO
	MOVS	0,1(M)		;GET CURRENT POINTER
	TRC	0,-1		;BYTE POINTERS COUNT BACKWARDS
	PUSH	P,0		;SOMEWHERE TO SAVE IT
	MOVS	0,TPNTR.(LOW)	;BACKUP POINTER
	TRC	0,-1		;CONVERT IT ALSO
	CAMG	0,(P)		;HAS THERE BEEN A BACKUP?
	JRST	ENDLN1		;NO, BUT POP OFF STORE POINTER
	MOVE	0,TPNTR.(LOW)	;RESTORE SAVED POINTER AND ITEM COUNT
	MOVEM	0,1(M)
	MOVE	0,TCNT2.(LOW)
	MOVEM	0,2(M)
ENDLN1:	POP	P,0		;GET RID OF MODIFIED POINTER
NOTTL:	JUMPGE	I,BUFST		;JUMP IF INPUT
	TLNE	N,ENCFL.	;++ ENCODE?
	JRST	ENCLND		;++ SET LIN END FLG - ENCODE!
	JUMPLE	L,.+2		;YES,IS IT END OF FMT?
	CAIN	B,SL		;THIS CHAR. A /?
	SKIPLE	EOL.(LOW)	;YES, CHARACTER COUNT <= 0?
	JRST	CRTN		;NO,DELIMIT WITH CR
	MOVEI	0," "		;BLANK TURNS INTO LF
	PUSHJ	P,DEPOT.	;DEPOSIT BLANK
CRTN:	MOVEI	0,CR		;CARRIAGE RETURN
	PUSHJ	P,DEPOT.	;DEPOSIT C.R.
	SETOM	EOL.(LOW)	;SET END OF LINE FLAG
	POPJ	P,

BUFST:	TLNE	N,ENCFL.	;++DECODE?
	JRST	LINEND		;++ YES TERMINATE LINE
	CAIN	B,SL		;LAST CHAR. A /?
	SKIPLE	2(M)		;YES,BUFFER EMPTY?
	JRST	PPN		;NO,ADVANCE TO NEXT RECORD
	SKIPE	OVFLS.(LOW)	;CCO 30-14CHECK LINE OVERFLOW
	JRST	PPN+1		;CCO 30-14
	TLZN	I,BFEF.		;BUFFER EMPTY FLAG ON?
	PUSHJ	P,CHINN.	;NO,DO INPUT
PPN:	PUSHJ	P,NXTCR		;ADVANCE TO NEXT LINE
	SETZM	OVFLS.(LOW)	;CLEAR LINE OVERFLOW
	SETOM	EOL.(LOW)	;SET END OF LINE FLAG
	POPJ	P,		;RETURN

;++ FINISH UP ENCODE DECODE LINE END

LINEND:	SETOM	EOL.(LOW)	;++ END OF LINE FLG
LINEN1:	LDB	0,[POINT 6,1(M),5]	;++ GET PTR
	CAIN	0,LSTBYT		;++ IS THIS THE LAST BYTE?
	POPJ	P,		;++ YES, RETURN
	XCT	IIB.		;++ BUMP POINTER
	JRST	LINEN1		;++ TEST THIS BYTE
SUBTTL	FIN. UUO TERMINATE FORTRAN I-O STATEMENT

FIN:	HRLZI	0,SAVFAC(LOW)	;SET UP BLT TO RESTORE OP SYS AC'S
	BLT	0,15		;ALL BUT 16 AND 17
	HRRZ	0,I		;PICK UP MODE
	CAIN	0,14		;BINARY MODE?
	JRST	BINEN.		;YES
	AOSE	EOL.(LOW)	;END OF LINE SEEN?
	PUSHJ	P,ENDLN.	;NO,TERMINATE LINE
	TLNE	N,ENCFL.	;++ENCODE/DECODE?
	JRST	ENCEND		;++FINISH UP ARRAY IF ENCODE
FIB.:	SETZM	END.(LOW)	;CLEAR END OF FILE FLAG
FIEND:	SETZM	ERR.(LOW)	;CLEAR INPUT ERROR FLAG
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	FI.		;NO
	MOVE	B,FILNUM(LOW)	;GET F4 DEVICE NO.
	IMULI	B,5		;5 ENTRIES/DEVICE(DATA SET)
IFN REENT,<ADDI	B,(LOW)>
	MOVE	C,FILES.-1(B)	;GET ADR OF ASSOC VARIABLE
	MOVE	B,ASVAR.(LOW)	;GET INTERNAL ASSOC VAR VALUE
	MOVEM	B,(C)		;PUT VALUE IN REAL ASSOC VAR
	SKIPGE	END.(LOW)	;WAS END OF FILE DETECTED?
	PUSHJ	P,CLOSI.	;SET UP FOR ANOTHER INPUT IF EOF.
FI.:	SETZM	RANAC.(LOW)	;CLEAR RANDOM ACCESS FLG
	MOVE	0,FOBPDP(LOW)	;INITIALIZE PUSHDOWN POINTER
	MOVEM	0,SAVFAC+P(LOW)	;RESTORE PUSHDOWN PTR
	TLZ	N,FINFL.	;CLEAR FLAGS
	SETZM	INIFLG(LOW)	;CLEAR FLAGS FOR NXT I/O
IFE REENT,<MOVE	0,[XWD INIFLG,INIFLG+1]>
IFN REENT,<HRLI 0,INIFLG(LOW)
	HRRI	0,INIFLG+1(LOW)>
	BLT	0,INPDEV(LOW)	;...
	MOVSI	17,SAVEAC(LOW)	;SET UP BLT TO RESTORE USERS ACS
	BLT	17,15
IFE REENT,<EXCH	N,SAVEAC+N	;RESTORE USER AC16>
	MOVE	17,SAVEAC+17(LOW)
	MOVE	0,SAVEAC+0(LOW)	;RESTORE AC0
	SKIPN	A,ERR.(LOW)	;USER PROGRAM CONTROL IF INPUT ERROR
	JRST	ENDTST		;NO ERROR OR CONTROL NOT DESIRED
	SETZM	ERR.(LOW)	;CLEAR ERROR FLAG
	HLL	A,UUOH.(LOW)	;GET FLAGS TO RESTORE
IFN REENT,<XCT	UUOL.(LOW)	;RESET OFFSET>
	JRSTF	@A		;GO TO POSITION SPECIFIED
ENDTST:	SKIPN	A,END.(LOW)	;USER PROGRAM CONTROL IF END-OF-FILE
IFE REENT,<JRSTF @UUOH.		;NO END OF FILE OR CONTROL NOT DESIRED>
IFN REENT,<JRST UUOL.(LOW)>
	SETZM	END.(LOW)	;CLEAR EOF FLAG
	HLL	A,UUOH.(LOW)	;GET FLAGS TO RESTORE
IFN REENT,<XCT	UUOL.(LOW)>
	JRSTF	@A		;GO TO POSITION SPECIFIED


SUBTTL	CHINN.
;CHINN. IS CALLED BY ALL INPUT ROUTINES TO GET A CHARACTER.
;THE CHARACTER IS RETURNED IN AC 0. AC M IS USED.

CHINNN:	XCT	IIB.		;IGNORE CHAR.
	SOS	2(M)		;FIX COUNT
				;PROCESS NEXT CHARACTER
CHINN.:	SKIPE	OVFLS.(LOW)	;SWITCH ON IF ALL CHARS. USED
	JRST	RETCR		;IN WHICH CASE, RETURN A C.R.
	SKIPG	2(M)		;IS BUFFER EMPTY?
	PUSHJ	P,DOINP		;YES,DO INPUT
IOK:	LDB	0,1(M)		;PICK UP A CHARACTER
	JUMPE	0,CHINNN	;IGNORE NULLS
	AOS	EOL.(LOW)	;INCREMENT COLUMN COUNT
	CAIG	0,CR		;IS IT AN END OF LINE CHAR.?
	CAIGE	0,LF		;TEST FOR LF,VT,FF OR CR
	JRST	.+2		;NO
	JRST	NXTLN.		;YES,SKIP TO NEXT LINE
	CAIE	0,"Z"-100	;^Z ON TTY IS EOF MARK
	JRST	.+3		;NOT ^Z
	TLNE	N,TTYFL.	;BUT IS IT ON TTY
	JRST	EOFTS.
	SOSG	2(M)		;DROP CHARACTER COUNT
	TLO	I,BFEF.		;BUFFER EMPTY FLAG
	POPJ	P,		;RETURN

DOINP:	TLNE	N,ENCFL.	;++ DECODE?
	JRST	DECERR		;++ YES DON'T DO INPUT
	PUSHJ	P,INP.		;GET NEXT BUFFERFUL
	PUSHJ	P,SAVPTR	;SAVE POINTER FOR REREAD
	IBP	RPTR2(LOW)	;INCREMENT SAVED POINTER
IIB.:	IBP	1(M)		;ADVANCE POINTER
	PUSH	P,F		;SAVE F - USED IN I/O ROUTINES
	PUSHJ	P,STAT.		;GET ERRORS NOT ASSOCIATED WITH A BUFFER
	TRNE	F,IODEND
	JRST	EOFTS.		;END OF FILE
	TRNE	F,IOTEND!IOWERR
	ERROR	IOERR.		;EOT OR IMPROPER MODE
	HRRZ	F,(M)		;PICK UP 1ST WORD BUFFER
	MOVE	F,-1(F)		;TO GET STATUS
	TRNE	F,IODERR!IOPERR!IOBKTL
	ERROR	IOERR.
POPF:	POP	P,F		;RESTORE F
	POPJ	P,		;RETURN WITH CHARACTER

DECERR:	SETOM	OVFLS.(LOW)	;++ END OF LINE FLG
	MOVEI	0,CR		;++TELLS CONVERSION ROUTINE END OF LINE
	SETOM	EDERR(LOW)	;++ SET ERROR FLAG
	POP	P,(P)		;++GO RIGHT BACK TO CONVERSION RTN
	POPJ	P,		;++RETURN


ENCEND:	SKIPGE	I		;++ENCODE?
	SKIPN	A,2(M)		;++BUFFER EMPTY?
	JRST	FIB.		;++DECODE OR BUFFER EMPTY.
	SETZM	OVFLS.(LOW)	;++CLEAR OVERFLOW FLG
	MOVEI	0," "		;++BLANK
	PUSHJ	P,DEPOT.	;++FILL UP ARRAY.
	SOJG	A,.-1		;++
	JRST	FIB.		;++RETURN WHEN THROUGH.

EDERR.:	SKIPE	EDERR(LOW)	;++ HAVE WE BEEN HERE BEFORE?
	SETOM	EDERR(LOW)	;++YES, SET 2ND TIME ERROR FLAG
	HLLOS	EDERR(LOW)	;++ NO SET 1ST TIME FLG(NON 0 R.H.)
	POPJ	P,		;++ RETURN
;SEARCH TO END OF CURRENT LINE

NXTCR:	SKIPE	OVFLS.(LOW)	;END OF LINE ALREADY SEEN?
	POPJ	P,		;YES
NXTCR.:	XCT	IIB.
	SOSGE	2(M)		;DROP ITEM COUNT
	PUSHJ	P,DOINP		;DO INPUT
	LDB	0,1(M)		;GET NEXT CHARACTER
	CAIG	0,CR		;VERTICAL PAPER MOTION?
	CAIGE	0,LF
	JRST	NXTCR.		;NO,KEEP LOOKING
;	JRST	NXTLN.		;YES...GO TO NEXT LINE

SUBTTL	ADVANCE TO NEXT LINE IN BUFFER (IF THERE IS ONE)

NXTLN.:	SETOM	OVFLS.(LOW)	;SET END-OF-LINE SWITCH
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	AOS	ASVAR.(LOW)	;YUP, INCREMENT VALUE OF ASSOC VAR
NXTCH:	SOSG	2(M)		;DROP ITEM COUNT
	JRST	RETBLK		;RETURN A C.R.
	ILDB	0,1(M)		;GET NEXT CHARACTER
	JUMPE	0,NXTCH		;IGNORE NULLS
	CAIG	0,CR		;LOOK FOR EOL CHAR
	CAIGE	0,LF
	JRST	RETBLK		;NO, AT START OF NEW LINE
	JRST	NXTCH		;YES,CONTINUE LOOKING

RETBLK:	TLNE	N,RRDFL.	;HAS THERE BEEN A REREAD?
	JRST	RETCR		;YES,LEAVE POINTERS AS THEY ARE
	MOVE	0,1(M)		;SAVE POINTER
	EXCH	0,RPTR2(LOW)	;AND EXCHANGE WITH LAST ONE
	MOVEM	0,RPTR1(LOW)
	MOVE	0,2(M)		;SAME FOR ITEM COUNT
	EXCH	0,RCNT2(LOW)
	MOVEM	0,RCNT1(LOW)
RETCR:	MOVEI	0,CR		;RETURN A C.R.
	POPJ	P,		;RETURN

;I/O ERROR ROUTINE

IOERR.:	TRNE	F,IODERR
	JRST	REDER.		;DATA ERROR
	TRNE	F,IOPERR
	JRST	PARER.		;PARITY ERROR
	TRNE	F,IOWERR
	JRST	WLKER.		;WRITE PROTECTION ERROR
	TRNE	F,IOBKTL	;ILL DECTAPE BLK. NUMBER
	JRST	LISTB.		;LIST TOO LONG
	TRNE	F,IOTEND
	JRST	ENDTP.		;END OF TAPE
	POPJ	P,		;JUST INCASE ERROR TYPE NOT FOUND

SUBTTL	END OF FILE TESTING

EOFTS.:	TLNN	I,DDF.		;DON'T CLOSE FOR DSK/DTA
	PUSHJ	P,CLOSI.	;TURN OFF THE EOF BIT
	LDB	A,[POINT 4,M,12];GET CHAN #
IFN REENT,<ADDI A,(LOW)>	;SET UP INDEX
	SKIPL	EOFFL.(A)	;HAS THE EOFTST PROGRAM BEEN CALLED
	JRST	[SKIPN	END.(LOW);NO,DOES USER WANT PROGRAM CONTROL?
		JRST	LOGEN.	;NO,PRINT ERROR MESSAGE AND FAIL
		JRST	FIEND]	;YES,GO TO POSITION SPECIFIED
	MOVEI	A,4		;SET UP EOF SWITCH 
	IORM	A,(G)		;                  IN DEVICE NAME
EDFIN:	SOS	UUOH.(LOW)	;SET UP FOR CHECKING FOR FIN.
	MOVSI	B,(FIN.)	;PUT FIN.'S OP CODE IN  AC B
MOVUUO:	MOVE	A,@UUOH.(LOW)	;GET FORTRAN UUO FROM PROGRAM
	AOS	UUOH.(LOW)	;INCREMENT PASSED THE FIN. OP CODE
	CAME	A,B		;IS  THE UUO A FIN. 00,0
	JRST	MOVUUO		;NO,GET NEXT UUO
	JRST	FIEND		;EXECUTE FIEND AND GO TO NXT UUO AFTER FIN.


SUBTTL	IN. OR OUT. UUOS

OUTP:	MOVSI	I,IOF.		;OUTPUT,ASCII
	JRST	SFMTFL		;SET THE FORMAT FLAG

INP:	SETZ	I,		;INPUT,ASCII
	SETOM	INPDEV(LOW)	;SET ASCII INPUT DEVICE FLAG
SFMTFL:	TLO	I,FIOF.		;SET FORMAT FLAG
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	NFI		;NO
	MOVE	B,RECNO.(LOW)	;GET NEXT RECORD FROM FORTRAN PROGRAM
	MOVEM	B,ASVAR.(LOW)	;PUT IN ASSOCIATED VARIABLE (INTERNAL)
NFI:	AOS	INIFLG(LOW)
RELI:	HRRE	0,A		;DEVICE NO.
	JUMPGE	0,POSDEV	;DEFAULT DEVICES?
	CAMLE	0,[-6]		;DEFAULT DEVICE?
	JRST	DFLDEV		;YES
	CAME	0,[-6]		;REREAD?
	JRST	PDERR		;ILLEGAL DEVICE NUMBER
	PUSHJ	P,REREAD	;YES, GET DEVICE
	MOVE	0,DEVNUM(LOW)	;NUMBER INTO 0
	JRST	POSDEV		;OK NOW
DFLDEV:	PUSHJ	P,MAKPOS	;YES, GET THE DEVICE
	TLO	N,DFLFL.	;SET DEFAULT DEVICE FLAG
POSDEV:	JUMPE	0,PDERR		;DEVICE 0 IS ILLEGAL
	CAILE	0,77		;CHECK RANGE OF DEVICE NO.
PDERR:	ERROR	DEVER.		;ILLEGAL DEVICE NO.
	MOVEM	0,DEVNUM(LOW)	;SAVE F4 DEV NUM
	MOVE	C,DEVNO.(LOW)	;HIGHEST DEVICE NUMBER IN USE
	JUMPE	C,NFI2		;JUMP IF NO DEVICES IN USE
	MOVEI	D,DYNCH.(LOW)	;BEGINNING OF CHARACTERISTICS TABLE
	ADD	D,C		;ADDRESS OF LAST DEVICE IN USE
NFI1:	HRRZ	E,0		;RH E=DEVICE NUMBER FROM USER'S JOB
	XOR	E,(D)		;CHECK WITH DEVICE NUMBER IN TABLE
	SUBI	D,1		;ADDR OF NEXT IN CHAR TABLE
	TRNN	E,-1-<SPLBIT!DMPBIT>	;CHECK DEVICE NUMBER BITS
	JRST	MATFND		;COMPLETE MATCH
	TRNE	E,-1-<ASSCON!DFLBIT!SPLBIT!DMPBIT>
	JRST	MATNFD		;NO, LOOP FOR ALL OF TABLE
	TLNE	N,DFLFL.	;IS IT A DEFAULT DEVICE?
	TRNN	E,ASSCON	;AND TEST DEVICE LOGICALLY ASSIGNED
	JRST	.+2		;NOT BOTH TRUE
	JRST	MATNFD		;BOTH TRUE SO NOT SAME DEVICE
	TLNE	N,ASSFL.	;INVERSE OF ABOVE TEST
	TRNN	E,DFLBIT
	JRST	MATFND		;NOT BOTH TRUE
MATNFD:	SOJG	C,NFI1		;LOOP FOR ALL IN TABLE
MATFND:	JUMPE	C,NFI2		;JUMP IF NOT IN TABLE, NEW DEVICE
	TLNE	N,RELFL.	;DOING RELEAS?
	JRST	RELES		;YES
	PUSHJ	P,FIDLDV	;LOOK AT DEVCHR BITS
	ADD	D,C		;RETURNED D=ADDR OF DYNDV., SET D=ADDR OF ENTRY
	MOVE	0,(D)		;AND 0=CONTENTS FOR THIS DEVICE
	JRST	DEVFND		;FOUND THE DEVICE
;HERE WHEN DEVICE NOT YET INITED

NFI2:	TLNE	N,RELFL.	;DOING RELEAS UUO
	JRST	FI.		;YES, JUST RETURN (NO-OP)
	TLNE	N,DFLFL.	;DEFAULT DEVICE?
	JRST	NEGNUM		;YES, BYPASS CHECK FOR LOGICAL ASSIGNMENT
	PUSH	P,A		;SAVE AC
	IDIVI	0,12		;CONVRT TO 6-BIT
	LSH	0,6
	OR	0,1		;CAN HAVE UP TO 77 OCT DEVICES THIS WAY
	IORI	0,2020
	TRNN	0,700		;TWO DIGITS?
	LSH	0,6		;ONE DIGIT
	LSH	0,30		;LEFT JUSTIFY
	MOVE	E,0
	MOVE	B,0
	MOVEM	0,DEVNAM(LOW)
	POP	P,A		;RESTORE AC
	DEVCHR	E,
	TRNE	E,ASSCON	;HAS THE DEVICE BEEN ASIGNED BY CONSOL?
	TLOA	N,ASSFL.	;YES, SET FLAG SO DYNCH. CAN BE SET
NEGNUM:	PUSHJ	P,GETDV.	;NO, GET NAME FROM DEVTB
	TLNE	I,RRF.		;COMPARE FOR REREAD
	ERROR	ILRED.		;ILLEGAL REREAD
	PUSHJ	P,FNDSLT	;FIND A SOFTWARE CHANNEL
	HRLZ	M,C		;SAVE DEVICE NO.
	ASH	M,5		;DEVICE NO. IN AC FIELD
	MOVEM	B,(D)		;PUT DEVICE NAME IN TABLE
	HRR	G,D		;SAVE ADDR. FOR THIS NAME
	PUSHJ	P,BUFCA.	;GET A BUFFER HEADER
	MOVEM	G,DNAME(LOW)	;SAVE DEV NAME ADDR
	SKIPGE	RANAC.(LOW)	;IF RANDOM ACCESS
	ADD	0,[3,,0]	;SET UP BUFFER HEADERS TO BE ADDRESS CHECKED
	MOVEM	0,INIT.+2(LOW)	;BUFFER HEADER ADDRESS
	SETZM	INIT.(LOW)	;V.007  ZERO THE ADDRESS PART
	MOVE	B,DEVNAM(LOW)
	MOVEM	B,INIT.+1(LOW)	;DEVICE NAME
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS
	JRST	.+5		;NO
	MOVEI	0,16		;DUMP MODE
	MOVEM	0,INIT.(LOW)	;YES, SET DUMP MODE
	TLNN	E,DSKBIT	;MUST BE DSK
	ERROR	RANER.		;IT WASN'T SO FATAL ERROR
IFN REENT,<OPEN.==0
	MOVSI	OPEN.,(OPEN )	;SET UP UUO>
	DPB	C,[POINT 4,OPEN.,12]	;CHANNEL NO.
	TLNE	N,TTYFL.	;TTY OR LPT?
	HRRI	I,1		;YES,ASCII LINE
	TLNE	E,MTABIT	;V.007  DEVICE MTA?
	PUSHJ	P,MGINIT	;V.007  YES, GO SET UP MODE BITS
	PUSH	P,I		;SAVE I
	HRRZS	I		;MODE BITS ONLY
	SKIPL	RANAC.(LOW)	;SETUP ALREADY IF RANDOM ACCESS
	IORM	I,INIT.(LOW)	;SET MODE ETC
	POP	P,I		;RESTORE I
IFN REENT,<HRRI	OPEN.,INIT.(LOW)
	XCT	OPEN.		;DO OPEN UUO>
IFE REENT,<
OPEN.:	OPEN	,INIT.		;INIT THE DEVICE>
	  ERROR	INIER.		;NOT AVAILABLE OR UNDEFINED
	MOVEM	B,DEVIC.(LOW)	;CURRENT DEVICE NAME
	PUSHJ	P,CLROU.	;CLEAR OUTPUT-LAST BIT
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	PUSHJ	P,SNGLBF	;YES, GET BUFFER SPACE
	MOVEI	B,DYNCH.(LOW)	;ADDR OF DEVICE CHARACTERISTICS TABLE
	ADD	B,C		;INDEX FOR THIS DEVICE
	HRR	E,DEVNUM(LOW)	;LH=DEVCHR, RH=FTN DEVICE
	PUSH	P,C		;SAVE CHAN.
	DEVTYP	C,		;NEW DEVCHR TYPE UUO
	  JRST	NOTSPL		;NEED 5.03 TO SPOOL
	TLNE	C,.TYSPL	;TEST FOR SPOOLING
	TRO	E,SPLBIT	;YES, SET SPOOL FLAG
NOTSPL:	POP	P,C		;RESTORE CHAN.
	TLNE	N,ASSFL.	;TEST FOR FLAGS AND SET IN DYNCH.
	TRO	E,ASSCON	;LOGICALLY ASSIGNED
	TLNE	N,DFLFL.	;WAS IT A FORTRAN DEFAULT DEVICE
	TRO	E,DFLBIT	;YES
	SKIPE	RANAC.(LOW)	;RANDOM ACCESS?
	TRO	E,DMPBIT	;YES, WILL USE DUMP MODE
	MOVEM	E,(B)		;THOUGH REALLY ONLY NEED 7 BITS
	PUSHJ	P,FIDLDV	;LOOK AT DEVCHR BITS
	MOVEI	B,INIT.(LOW)	;ADDRESS OF OPEN DATA
	DEVSIZ	B,		;GET BUFFER SIZE
	  SETO	B,		;FAILED
IFN REENT,<ADDI	C,(LOW)		;SO INDEXING WILL WORK>
	MOVEM	B,BUFSZ.(C)	;STORE INFO
IFN REENT,<SUBI	C,(LOW)>
	MOVE	B,DEVNUM(LOW)	;GET DEV NUMBER
	JUMPL	I,.+2		;SKIP ON OUTPUT
	MOVEM	B,RERDN.(LOW)	;SAVE DEV. # FOR REREAD.
	MOVEM	B,FILNUM(LOW)	;SAVE FOR FILE NAME
IFN REENT,<ADDI	B,(LOW)>
	SKIPE	B,DATTB.(B)	;IF BUFFER WAS CALLED,
	PUSHJ	P,SETBFS	;GO SET UP RINGS.
	JRST	DVF
SUBTTL	FORTRAN CALLI UUO

;AT PRESENT ONLY DOES RELEAS UUO
;FCALLI 0, WHICH EXPECTS DEVICE NUMBER IN AC0

FCALLI:	TRNE	A,-1		;VALID UUO?
	PUSHJ	P,ILUUO.	;NO
	MOVE	A,SAVEAC+0(LOW)	;GET DEVICE #
	TLO	N,RELFL.	;SET RELEAS ONLY FLAG
	JRST	RELI		;GET CHAN # ETC

;RELEASE UUO -  FCALLI 0

RELES:	HRLZ	M,C		;CHAN. #
	ASH	M,5		;IN AC FIELD
	PUSHJ	P,BUFCA.	;GET HEADER
	HLR	M,G		;PUT INPUT BUFFER ADDRESS IN M FOR SURE
IFN REENT,<ADDI	C,(LOW)>
	MOVE	B,DYNDV.(C)	;GET DEVICE NAME
	TRZ	B,77		;CLEAR I/O FLAGS
	CAMN	B,RERDV.(LOW)	;SAME AS LAST READ-DEV?
	SETZM	RERDV.(LOW)	;YES, CLEAR IT.
	CAMN	B,INPDV.(LOW)	;SAME AS LAST ASCII-INPUT DEV?
	SETZM	INPDV.(LOW)	;YES, CLEAR IT.
	MOVEI	A,TABPT.(LOW)	;POINTER TO MTABF.
CLRMTA:	CAIGE	A,MTABF.(LOW)	;DONE WITH MTABF.?
	JRST	DONMTA		;YES
	MOVE	D,(A)		;GET NAME FROM MTABF.
	TRZ	D,77		;CLEAR I/O FLAGS
	CAME	D,B		;THE ONE WE WANT?
	SOJA	A,CLRMTA	;NO, GET NEXT
	SETZM	(A)		;YES, CLEAR IT
DONMTA:	MOVE	B,DYNCH.(C)	;GET DEVCHR WORD
	TRNN	B,DMPBIT	;RANDOM ACCESS DEVICE?
	JRST	XREL		;NO
	SETOM	RANAC.(LOW)	;SET RANDOM ACCESS FLAG
	SKIPL	RANDV.(C)	;MUST WE OUTPUT LAST BLOCK.
	JRST	NOTOUT		;NO
	SETZM	BLOCK.(LOW)	;INHIBIT INPUT OF NEXT BLOCK
	PUSHJ	P,ROUTP.	;OUTPUT LAST BLOCK
NOTOUT:	HRRZ	B,(M)		;GET INPUT BUFFER ADDRESS
	PUSHJ	P,LNKDMP	;LINK BUFFER IN CHAIN OF THEM
XREL:	HLLZ	0,M		;GET CHAN #
	TLO	0,(RELEAS)	;SET UP RELEAS UUO
	XCT	0		;DO RELEAS UUO
	PUSHJ	P,LNKBUF	;LINK THE BUFFERS INTO CHAIN
	SETZM	FILES.-5(C)	;CLEAR RANDOM FILENAME
	SETZM	FILES.-4(C)	;CLEAR RANDOM ACCESS EXT.
	SETZM	DYNDV.(C)	;CLEAR DYNDV. ENTRY
	SETZM	DYNCH.(C)	;CLEAR DEVCHR BITS
	SETZM	BUFSZ.(C)	;CLEAR BUFFER DATA
	SETZM	INCNT.(C)
	SETZM	EOFFL.(C)
	SETZM	ONLY1.(C)	;CLEAR EOF ANS ONLY1 FLAGS FOR CHANNEL
IFN REENT,<SUBI	C,(LOW)>
	ASH	C,1		;2 ENTRIES/CHANNEL
IFN REENT,<ADDI	C,(LOW)>
	SETZM	TNAME.(C)	;CLEAR FILE NAME INPUT/OUTPUT
	SETZM	TNAME.+1(C)	;
	JRST	FI.		;RETURN
;RELEASED BUFFER SPACE IS LINKED TOGETHER HERE
;LINK. CONTAING THE MASTER POINTERS
;XWD FIRST LINK ,, LAST LINK
;LINK. POINTS TO THE FIRST WORD OF THE BUFFER AREA RECOVERED
;IN THAT AREA THE FIRST WORD IS A LINK TO THE PREVIOUS AND NEXT AREAS
;POINTER IS XWD PREVIOUS AREA ,, NEXT AREA
;SECOND WORD IS DEVSIZ RETURN
;XWD NUMBER OF BUFFERS IN RING ,, BUFFER SIZE
;A POINTER OF ZERO IS THE END OF THE CHAIN

LNKBUF:	SKIPG	A,BUFSZ.(C)	;GET BUFFER INFO.
	POPJ	P,		;NOT AVAILABLE, OR DONE
	PUSH	P,E		;BETTER SAVE E
	MOVE	B,LINK.(LOW)	;GET LINK TO BUFFERS
	SKIPE	D,(M)		;INPUT BUFFER USED?
	PUSHJ	P,LINKUP	;YES, RECLAIM IT
	SKIPE	D,3(M)		;OUTPUT BUFFER USED?
	PUSHJ	P,LINKUP	;YES
	POP	P,E		;RESTORE IT
	POPJ	P,		;RETURN

LINKUP:	HRRZ	E,(D)		;GET NEXT BUFFER IN RING
	CAIN	E,(D)		;BEEN ROUND RING?
	SOJA	D,LINK3		;YES
	CAIG	E,(D)		;NEARER ZERO?
	MOVE	D,E		;YES
	HRRZ	E,(E)		;NEXT BUFFER IN RING
	JRST	LINKUP+1	;TRY AGAIN

LINK1:	HRLM	D,LINK.(LOW)	;FIRST BUFFER IN CHAIN
	SETZM	(D)		;CLEAR LINK WORD
	JRST	LINK2		;STORE DEVSIZ DATA

LINK3:	HRRM	D,LINK.(LOW)		;POINT TO NEW BUFFER
	TLNN	B,-1		;FIRST TIME?
	JRST	LINK1		;YES, SET START OF LINKED BUFFERS
	HRLZM	B,(D)		;BACKWARD LINK
	HRRM	D,(B)		;FORWARD LINK
LINK2:	MOVEM	A,1(D)		;BUFFER DATA
	POPJ	P,

;HERE TO LINK DUMP MODE BUFFER

LNKDMP:	HRRZ	0,(M)		;POINTER TO BUFFER
	EXCH	0,RLINK.(LOW)	;PUT IN CHAIN
	MOVEM	0,@RLINK.(LOW)	;AND LINK TO IT
	POPJ	P,		;RETURN


SUBTTL INBUF AND OR OUTBUF FOR DEVICE JUST INITED
;EXPECTS:	(B)=RING DATA FROM DATTB. 
;		(C)=CHAN. NUM

SETBFS:	PUSH	P,B		;SAVE DATA
	HLRZS	B		;GET BUFFER SIZE
				;SKIP IF NOT DETERMINED,DO NUMBER/NOT SIZE
	JUMPN	B,SETUP1	;GO SET UP ODD SIZED BUFFERS,EXPAND IF NECESSARY

IBUF:	LDB	B,[POINT 4,(P),31]	;GET "IN"DATA
	JUMPE	B,CHKOT1	;SEE IF RING SPEC.
	DPB	C,[POINT 4,B,12]
	TLO	B,NINBUF	;SETUP INBUF UUO.
	XCT	B		;EXECUTE INBUF ON CHAN.(LOW) (C)

CHKOT1:	LDB	B,[POINT 4,(P),35]	;GET "OUT" DATA
	JUMPE	B,BFDONE	;SEE IF RING SPEC.
	DPB	C,[POINT 4,B,12]
	TLO	B,NOUBUF	;SET UP OUTBUF UUO
	XCT	B		;EXECUTE OUTBUF

BFDONE:	POP	P,(P)		;PUT STACK BACK IN SYNK.
	JRST	CLRBFZ		;CLEAR BUFSZ.(LOW)

;THE FOLLOWING CODE SETS UP NON-STANDARD SIZE BUFFERS FOR THE DEVICE INITED
;ON CHAN. # FOUND IN AC(C).  CORE IS EXPANDED IF NEEDED.  IF THE
;USER HAS SPECIFIED NUMBER AND SIZE SUCH THAT THE BUFFERS WILL NOT FIT IN
;CORE, THE NUMBER OF BUFFERS IS FIRST CUT TO TWO , THEN ONE.

SETUP1:	ADDI	B,2		;TOTAL AREA/BUFFER
	PUSH	P,B		;STORE TOTAL SIZE
	EXCH	C,-1(P)		;SAVE CHAN # FOR FUTURE USE
	PUSH	P,C		;DATA ON TOP OF STACK AGAIN
	MOVE	B,JOBFF		;GET JOBFF
	LDB	C,[POINT 4,(P),31]	;GET # BUFFERS INPUT
	JUMPN	C,.+2		;WAS IT INPUT?
	LDB	C,[POINT 4,(P),35]	;GET # BUFFERS OUTPUT
	PUSH	P,C		;SAVE NUM BUFFERS
TRYAGN:	IMUL	C,-2(P)		;CALCULATE SPACE NEEDED
	ADD	C,B		;GET HIGEST LOCATION NEEDED
	CAML	C,JOBREL	;WILL IT FIT?
	JRST	GETCOR		;NO, GO GET MORE CORE
GOTCOR:	MOVEM	C,JOBFF		;YES,NOW IT FITS.SET UP NEW JOBFF
	MOVEI	C,2(B)		;PICK UP FIRST DATA WORD ADDRESS
	HRRM	C,1(M)		;STORE IT IN RING HEADER
	MOVEI	C,1(B)		;1ST BUFFER 2ND WD
	TLO	C,(1B0)		;SET USE BIT
	MOVEM	C,(M)		;PUT IN 1ST WD RING HEADER
	HLL	C,-1(P)		;SET UP 2ND WD BUFFER
	MOVE	0,C		;SAVE POINTER
NXTBUF:	SOSG	(P)		;IS THIS LAST BUF TO BE SETUP?
	JRST	LASTBF		;YES,GO SET IT UP
	ADD	0,-2(P)		;NO,CALCULATE 2ND WD NEXT BUFFER
	MOVEM	0,(C)		;STORE IT IN 2ND WD THIS BUFFER
	MOVE	C,0		;
	JRST	NXTBUF		;FIXUP NEW BUFFER

LASTBF:	HRRI	0,1(B)		;SETUP POINTER TO 2ND WD 1ST BUFFER
	MOVEM	0,(C)		;STORE IT IN 2ND WD LAST BUUFER
	SUB	P,[3,,3]	;STACK BACK IN SYNK.
	POP	P,C		;RESTORE CHAN. #
CLRBFZ:
IFN REENT,<ADDI	C,(LOW)		;DOUBLE INDEXING>
	SETZM	BUFSZ.(C)	;CLEAR BUFFER RING DATA
IFN REENT,<SUBI	C,(LOW)		;BACK AS IT WAS>
	POPJ	P,		;RETURN

;C CONTAINS NEW JOBFF NEEDED

GETCOR:	MOVE	0,C		;SAV AC
	CALLI	0,11		;EXPAND CORE
	JRST	LESCOR		;FAILED
	JRST	GOTCOR		;PASSED

LESCOR:	JUMPLE	0,NOCORE	;FAIL IF NO CORE AVAILABLE
	MOVE	C,(P)		;GET # BUFFERS DESIRED
	SOJLE	C,NOCORE	;TRIED ONE AND FAILED - TOTAL FAILURE
	CAIE	C,1		;IF =1,LEAVE IT ALONE
	MOVEI	C,2		;IF>=2,MAKE IT 2
	MOVEM	C,(P)		;SAVE NUM BUFFERS
	JRST	TRYAGN		;TRYAGAIN

NOCORE:	ERROR	BUFER.		;FATAL ERROR MESSAGE

SUBTTL	SUBROUTINE TO LOOK AT DEVCHR BITS
;IN E AND SET APPROPRIATE FLAGS
;ARGS	E=LH DEVCHR BITS
;VALUES	D=ADDRESS OF DYNDV. TABLE
;	SEVERAL FLAGS SET

FIDLDV:	TLNE	E,DIRBIT	;DECTAPE OR DISK?
	TLO	I,DDF.		;YES
	TLNE	E,LPTBIT!TTYBIT	;LPT OR TTY?
	TLO	N,TTYFL.	;YES,SET LPT OR TTY FLAG
	TLNE	E,CRDBIT	;CARDS I/O?
	TLO	N,CDSFL.	;SET CARD READER/PUNCH FLAG
	TRNE	E,SPLBIT	;IS DEVICE SPOOLING TO DSK?
	TLO	N,SPLFL.	;YES
	TLNE	E,USRTTY	;IS THIS THE USERS TELETYPE ?
	MOVSI	B,(SIXBIT ?TTY?);YES, MOVE TTY INTO DYNDV. TABLE
	MOVEI	D,DYNDV.(LOW)	;ADDR. OF DYNAMIC DEVICE TABLE
	SKIPE	RANAC.(LOW)	;MAKE TEST TO SEE IF MODE HAS CHANGED
	JRST	[TRNN	E,DMPBIT
		PJRST	FXMODE
		POPJ	P,]
	TRNE	E,DMPBIT	;SHOULD NOT BE ON
	PJRST	FXMODE		;IT WAS SO SORT OUT MODE
	POPJ	P,

GETDV.:	MOVE	0,DEVNUM(LOW)	;RESTORE DEVICE LOGICAL NUMBER
	CAILE	0,DVTOT.	;LEGAL DEVICE?
	ERROR	DEVER.		;NO
	MOVNI	C,DEVTB.	;CALCULATE ADDR. OF DEVICE NAME
	ADDI	C,1(LOW)
	SKIPG	B,0		;DEVICE NO. NEGATIVE?
IFN REENT,<JRST	[	>
	ADDI	B,DEVND.(C)	;YES,GO TO END OF TABLE
IFN REENT,<JRST	.+2]
	ADDI	B,(LOW)	>
	MOVE	B,DEVTB.(B)	;PICK UP DEVICE NAME
	CAMN	B,[SIXBIT /REREAD/]
	JRST	REREAD		;SET UP TO REREAD 
SAVDNM:	SKIPN	E,B		;GET DEV NAME AND
	ERROR	ILRED.		;FAIL IF IT WAS RELEASED.
	HLRZS	E		;STRIP OFF #
	CAIE	E,(SIXBIT .DSK.) ;DSKN ?
	SKIPA	E,B		;NO RESTORE NAME
	HRLZS	E		;SWAP BACK
	MOVEM	E,DEVNAM(LOW)	;SAVE DEVICE FOR INITIALIZATION
	DEVCHR	E,
	POPJ	P,

DEVFND:	MOVE	B,DEVNUM(LOW)
	MOVEM	B,FILNUM(LOW)	;SAVE F4 DEVICE NUMBER
	JUMPL	I,.+2		;SKIP ON OUTPUT
	MOVEM	B,RERDN.(LOW)	;SAVE DEV. # FOR REREAD
	MOVEM	0,DEVIC.(LOW)	;SAVE DEVICE NAME
	SKIPGE	INPDEV(LOW)	;IS THIS AN ASCII INPUT DEVICE ?
	PUSHJ	P,CKDVEQ	;YES, SEE IF THE SAME AS LAST INPUT DEV.
	HRLZ	M,C		;DEVICE NUMBER
	ASH	M,5		;DEVICE NO. IN AC FIELD
	PUSHJ	P,BUFCA.	;GET HEADER ADDRESS
	HRR	G,D		;ADDR. FOR THIS DEVICE NAME
	MOVEM	G,DNAME(LOW)	;SAVE DEVICE NAME ADDR
	SKIPLE	INPDEV(LOW)	;IS THIS A NEW INPUT DEVICE ?
	PUSHJ	P,SAVPTR	;YES,SAVE NEW POINTER FOR REREAD
	TLNN	N,TTYFL.	;IS THE DEVICE THE TTY OR LPT ?
	PUSHJ	P,JSB		;NO,CHECK FOR CHANGE IN MODE
	JUMPGE I,DVF		;DONT CHECK ON INPUT FOR CHANGE IN I/O
	SKIPG	-3(M)		;HAS AN INPUT BEEN DONE YET?
	JRST	DVF		;NO,CONTINUE
	MOVE	D,(D)		;
	TRNN	D,2		;OUTPUT LAST?
	TLO	N,RDWFL.	;SET READ TO WRITE FLAG
DVF:	TLNE	I,FCF.		;FILE COMMAND?
	JRST	FCM		;YES
FTST:	TLNN	I,STPFF.	;SPECIAL TAPE FUNCTION?
	TLNN	I,DDF.		;DSK OR DECTAPE?
	JRST	FTST1
	MOVE	D,C		;YES,GET DEV. NO.
	ASH	D,1		;SET INDEX FOR FILE NAME
	JUMPG	I,.+2		;SKIP ON INPUT
	ADDI	D,1		;INDEX FOR OUTPUT FILE
IFN REENT,<ADDI	D,(LOW)>
	SKIPE	TNAME.(D)	;ANY NAME THERE?
	JRST	FTST1		;FILE NAME ALREADY SET
	PUSH	P,A
	SETZM	TEMP.+2(LOW)	;CLEAR DATE, TIME AND PROTECTION
	MOVE	B,FILNUM(LOW)
	IMULI	B,5		;B HAS F4 DEV NO
IFN REENT,<ADDI	B,(LOW)>
	CAILE	B,DYDVL.*5(LOW)	;INDEX TOO BIG?
	JRST	FTST5		;YES, USE DEFAULT NAMES
	SKIPE	A,FILES.-5(B)	;IS THERE A FILE NAME?
	JRST	SETNAM		;YES, GO PUT IT IN TEMP FOR LOOKUP ETC.
FTST5:	LDB	0,[POINT 6,FILNUM(LOW),35]    ;NO, GET POSITIVE F4 DEVICE NO
	IDIVI	0,12		;CONVERT TO 6BIT
	LSH	0,6
	OR	0,1
	IOR	0,FORZRO	;SIXBIT FOR00
	LSH	0,6
	MOVEM	0,TEMP.(LOW)
	MOVSI	A,444164	;SIXBIT 'DAT'
	MOVEM	A,TEMP.+1(LOW)	;SET 'DAT' UP FOR EXTENSION
	CAILE	B,DYDVL.*5(LOW)	;
	JRST	DEFALT
SETPPN:	SKIPE	A,FILES.-3(B)	;IS THERE A PPN FOR LOOKUPS OR ENTER?
	MOVEM	A,TEMP.+3(LOW)	;YES, SET IT UP
DEFALT:	POP	P,A		;NO,FORGET IT
	PUSHJ	P,FCM1		;DO LOOKUP OR ENTER
FTST1:	TLNE	N,RDWFL.	;TRYING TO READ THEN WRITE?
	JRST	RDWR		;YES,GO SET UP BUFFERS ETC
FTST0:	JUMPGE	I,FTST2		;OUTPUT?
	PUSHJ	P,CLOSI.	;YES,DO INPUT CLOSE FOR LAST READ
	SKIPG	(M)		;DUMMY OUTPUT NEC. ?
	PUSHJ	P,OUTT.		;YES
				;IT INTO THE OUTPUT BUFFER
FTST2:	TLNE	I,NLIOF.	;NAMELIST?
	JRST	NAMEL		;YES
	TLNE	I,STPFF.	;SPECIAL TAPE FUNCTION?
	JRST	TPFCN.		;YES,GO TO FUNCTION DISPATCH
	TLNN	I,FIOF.		;FORMAT?
	JRST	BINWR.		;NO,GO TO BINARY READ & WRITE
	TLNE	N,TTYFL.	;TTY OR LPT?
	JRST	IORET		;YES
FTST4:	LDB	C,[POINT 9,@(M),17];PICK UP BUFFER WORD-SIZE
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	MOVEI	C,200		;DSK  BUFFER SIZE
	SUBI	C,LINWDS+1
	TLNE	N,ENCFL.	;ENCODE?
	JRST	GETAC		;YES
	JUMPLE	C,IORET		;DON'T USE LINE BUFFER IF
				;DEVICE BUFFER SIZE TOO SMALL
FTST3:	HRRZM	M,HDRADD(LOW)	;ADDRESS OF REAL BUFFER HEADER
	JUMPGE	I,IORET		;ON INPUT,DON'T SET UP LINE BUFFER
	PUSHJ	P,SETOU.	;SET OUTPUT BIT
	MOVEI	C,LINBUF-1(LOW)	;INITIALIZE LINE BUFFER HEADER
	MOVEM	C,LINHDR(LOW)
	MOVE	C,LBPTR(LOW)	;POINTER TO LINE BUFFER
	MOVEM	C,LINHDR+1(LOW)
	MOVEI	C,LINCH		;ITEM COUNT
	MOVEM	C,LINHDR+2(LOW)
	HRRI	M,LINHDR(LOW)	;HEADER ADDRESS
	LDB	C,[POINT 4,M,12]	;GET CHAN #
IFN REENT,<ADDI C,(LOW)	>
	SETOM	PAKFL.(C)	;SET PACK FLAG ON CHANNEL
	TLNN	N,ENCFL.	;ENCODE?
	JRST	IORET		;NO, GO TO FORMAT SCAN
	JRST	GETAC		;YES
;SET UP PROJ,PROG NO,  FILENAME,  EXT FOR I/O.

SETNAM:	MOVEM	A,TEMP.(LOW)	;SET UP DESIRED FILENAME
	SKIPE	A,FILES.-4(B)	;GET EXT IF ANY & SET IT UP
	HLLZM	A,TEMP.+1(LOW)
	DPB	A,[POINT 9,TEMP.+2(LOW),8]	;PROTECTION CODE
	JRST	SETPPN		;SET UP PPN IF ANY


;CHECK TO SEE IF CURRENT INPUT DEVICE IS THE SAME AS LAST ONE
CKDVEQ:	SKIPN	INPDV.(LOW)	;IS THIS THE FIRST INPUT DEV. ?
	MOVEM	0,INPDV.(LOW)	;YES,MOVE INTO HOLDING AREA
	CAMN	0,INPDV.(LOW)	;ARE THE TWO DEVICES THE SAME ?
	POPJ	P,		;YES, RETURN
	MOVEM	0,INPDV.(LOW)	;NO,MOVE NEW DEV. INTO HOLDING AREA
	XORM	0,INPDEV(LOW)	;SET UP FLAG TO SAY THEY ARE DIFF.
	POPJ	P,		;RETURN

;SAVE THE CURRENT POINTER AND ITEM COUNT FOR REREAD

SAVPTR:	MOVE	0,1(M)		;GET POINTER
	MOVEM	0,RPTR2(LOW)	;SAVE IN RPTR2
	MOVE	0,2(M)		;GET ITEM COUNT
	MOVEM	0,RCNT2(LOW)	;SAVE IN RCNT2
	POPJ	P,		;RETURN
;RESET STATUS FOR CURRENT DEVICE

JSB:	TLNN	I,FIOF.		;IS THE MODE ASCII ?
	POPJ	P,		;NO, RETURN
	LDB	0,[POINT 6,1(M),11];YES, GET POINTER SIZE
	CAIE	0,44		;IS THE POINTER BINARY ?
	POPJ	P,		;NO,RETURN
	MOVEI	0,0700		;YES,SET UP ASCII POINTER
	HRLM	0,1(M)		;PUT NEW POINTER INTO BUFFER HEADER
	MOVE 	0,2(M)		;ADJUST WORD COUNT
	IMULI	0,5		;FOR ASCII MODE
	MOVEM	0,2(M)		;REPLACE WITH NEW COUNT
	POPJ	P,		;RETURN WITH MODE CHANGED

;SET BUFFER HEADER ADDRESS FOR CURRENT DEVICE

BUFCA.:	LDB	0,[POINT 4,M,12];DEVICE NUMBER
	IMULI	0,6		;SIX WORDS FOR EACH DEVICE
	ADDI	0,BUFHD.(LOW)	;BASE ADDRESS
	HRLS	0		;IN BOTH HALVES
	HLL	G,0		;ADDRESS OF INPUT BUFFER HEADER
	SKIPL	RANAC.(LOW)	;ONLY ONE BUFFER IF RANDOM ACCESS
	ADD	0,[XWD 3,0]	;OUTPUT ADDR.,INPUT ADDR.
	HLR	M,0		;HEADER ADDRESS
	JUMPL	I,CPOPJ		;SKIP ON OUTPUT
	HRR	M,0		;HEADER ADDRESS
	POPJ	P,

;HERE TO SET UP DUMP MODE BUFFER FOR RANDOM ACCESS

SNGLBF:	SKIPE	RLINK.(LOW)	;CAN WE REUSE SOME SPACE?
	JRST	REUSE		;YES
	HRRZ	0,JOBFF		;TOP OF FREE CORE
	ADDI	0,202		;BUFFER SPACE
	CAIL	0,JOBREL	;WILL IT FIT
	PUSHJ	P,XPAND		;NO
	EXCH	0,JOBFF		;ALLOCATE SPACE
SNGLB1:	HRRZM	0,(M)		;STORE BUFFER POINTER
	ADDI	0,2		;POINT TO DATA
	HRRZM	0,@(M)		;STORE POINTER TO DATA, SIGN BIT IS OFF
	MOVSI	0,(POINT 7,,35)	;ASSUME ASCII
	TRNE	I,17		;WAS IT
	MOVSI	0,(POINT 36,,35)	;NO, BINARY
	MOVEM	0,1(M)		;STORE BYTE POINTER
	SETZM	2(M)		;CLEAR WORD COUNT
	POPJ	P,		;RETURN

;HERE TO REUSE OLD BUFFER SPACE

REUSE:	MOVE	0,@RLINK.(LOW)	;GET LINK
	EXCH	0,RLINK.(LOW)	;REMOVE FIRST LINKED BUFFER
	JRST	SNGLB1		;RETURN WITH BUFFER SPACE

;HERE TO EXPAND CORE

XPAND:	PUSH	P,A		;SAVE AN AC
	MOVE	A,0		;CORE NEEDED
	CORE	A,		;TRY
	ERROR	BUFER.		;FAILED, PRINT MESSAGE
	POP	P,A
	POPJ	P,

;HERE TO CHANGE MODE FOR RANDOM ACCESS/SEQUENTIAL CHANGE

FXMODE:	TLNE	I,STPFF.	;AN MTOP. UUO?
	POPJ	P,		;YES, RANAC IS NEVER SETUP
	HRLZ	M,C		;DEVICE NUMBER
	ASH	M,5		;PUT IN ACC FIELD
	PUSHJ	P,BUFCA.	;GET BUFFER HEADER INTO M (RH)
IFN REENT,<ADDI	C,(LOW)>
	SKIPN	RANAC.(LOW)	;DO WE WANT DUMP MODE NOW?
	JRST	FX2ASC		;NO
	PUSHJ	P,CLOS.		;OUTPUT LAST BLOCK IF NEED BE
	HLR	M,G		;PUT INPUT BUFFER IN M
	PUSH	P,A		;SAVE SOME ACCS
	PUSH	P,B
	PUSH	P,D
	PUSHJ	P,LNKBUF	;LINK THE BUFFERS
	POP	P,D
	POP	P,B
	POP	P,A
	HLLZ	0,M		;GET CHAN. #
	HRRI	0,16		;DUMP MODE
	TLO	0,NSETST	;FORM UUO
	XCT	0		;DO IT
	SETZM	BUFSZ.(C)	;SIGNAL NO BUFFERS
	PUSHJ	P,SNGLBF	;GET A DUMP MODE BUFFER
	JRST	FXDRET		;RETURN

	JUMPGE	I,.+2		;SKIP IF INPUT
	SUBI	M,3		;USE INPUT HEADER FOR OUTPUT
FX2ASC:	SETZM	BLOCK.(LOW)	;CLEAR WANTED BLOCK. #
	SKIPGE	RANDV.(C)	;ANYTHING TO GO OUT?
	PUSHJ	P,ROUTP.	;YES, DUMP LAST BLOCK
	HLLZ	0,M		;GET CHAN. #
	TLO	0,NSETST	;SETSTS UUO 
	XCT	0		;CHANGE MODE TO ASCII
	MOVEI	0,INIT.(LOW)	;DEVICE NAME
	DEVSIZ	0,		;GET BUFFER SIZE
	  SETO	0,		;FAILED
	MOVEM	0,BUFSZ.(C)	;STORE INFO.
	PUSHJ	P,LNKDMP	;GARBAGE COLLECT BUFFER
	SETZM	(M)		;NO BUFFERS SET UP 
	SETZM	3(M)		;FOR INPUT OR OUTPUT
FXDRET:	SETZM	RANDV.(C)	;CLEAR INCORE BLOCK
	MOVE	E,DYNCH.(C)	;GET DEVCHR WORD
	TRC	E,DMPBIT	;PUT BIT RIGHT WAY 
	MOVEM	E,DYNCH.(C)	;IN TABLE
IFN REENT,<SUBI	C,(LOW)>
	JUMPGE	I,CPOPJ		;INPUT?
	SKIPN	RANAC.(LOW)	;SAME BUFFER IF RANDOM ACCESS
	ADDI	M,3		;NO
	POPJ	P,		;RETURN

SUBTTL	INF. AND OUT. UUOS

OUTF:	MOVSI	I,IOF.!FCF.	;OUTPUT,FILE COMMAND,ASCII
	JRST	INF+1		;GET NAME AND DO INIT

INF:	MOVSI	I,FCF.		;FILE COMMAND,ASCII
	LDB	D,PTRU		;AC CONTAINING FILE NAME
	ADDI	D,SAVEAC(LOW)	;ADDR. WHERE AC SAVED

;CONVERT FILE NAME TO SIXBIT

	MOVE	B,[POINT 6,TEMP.(LOW)];RESULT POINTER
	MOVE	D,(D)		;7-BIT ASCII FILE NAME
	SETZM	TEMP.(LOW)	;CLEAR NAME
SSBC:	JUMPE	D,NFI		;JUMP IF THROUGH
	LSHC	C,7		;GET NEXT CHARACTER
	TRC	C,40		;CONVERT TO SIXBIT
	IDPB	C,B		;DEPOSIT IN ENTRY BLOCK
	JRST	SSBC

SUBTTL	REREAD UUO--FORMAT SIMILAR TO READ

REREAD:	TLO	I,RRF.		;REREAD , ASCII
	TLO	N,RRDFL.	;SET REREAD USE FLAG ON
	MOVE	B,RERDN.(LOW)	;PICK UP LAST INPUT DEVICE NUMBER
	MOVEM	B,DEVNUM(LOW)	;MAKE IT THIS DEVICE NUMBER
	MOVE	B,RERDV.(LOW)	;PICK UP LAST INPUT DEVICE NAME
	JRST	SAVDNM		;RETURN

SUBTTL	NAMELIST (NLIN.,NLOUT.) UUO'S

NLI:	MOVSI	I,NLIOF.	;NAMELIST
	JRST	NFI		;INITIALIZE DEVICE

NLO:	MOVSI	I,IOF.!NLIOF.	;OUTPUT,NAMELIST,ASCII
	JRST	NFI

;NAMELIST SET UP

NAMEL:	LDB	A,PTRU		;AC FIELD OF NAMELIST UUO
IFN REENT,<ADDI	A,(LOW)>
	MOVEI	A,@SAVEAC(A)	;POINTER TO NAMELIST TABLE
	PUSHJ	P,NMLST.	;GO OFF TO NAMELIST ROUTINE
	JRST	IORTR.		;RETURN TO USER

SUBTTL	BINARY TAPE READ(RTB) / WRITE(WTB)  UUO
;DEVICE NO. IN RIGHT HALF OF UUO


WTB:	SKIPA	I,[XWD IOF.,14]	;OUTPUT BINARY
RTB:	MOVEI	I,14		;INPUT BINARY
	SKIPL	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	NFI		;NO, SEQUENTIAL I/O
	MOVE	0,RECNO.(LOW)	;YES SET UP ASSOCIATED VARIABLE
	MOVEM	0,ASVAR.(LOW)	;
	TLZ	N,FKNFL.	;CLEAR ASCII RANDOM ACCESS FLAG
	JRST	NFI		;DO INITIALIZATION

SUBTTL	SPECIAL TAPE FUNCTIONS
;DEVICE NO. IN RIGHT HALF OF UUO
;FUNCTION IN AC FIELD OF UUO

RRBBW:	LDB	I,PTRU		;AC FIELD OF UUO
	TRO	I,STPFF.	;SPECIAL FUNCTION
	HRLZS	I		;SWAP AND ZERO RH FOR ASCII
	JRST	NFI		;DO INITIALIZATION

SUBTTL	ENCODE/DECODE

;++ ENCODE COMES HERE

ENC:	HRLI	I,IOF.!FIOF.	;++ FORMAT, OUTPUT.
	MOVEI	M,ENCHDR(LOW)	;++ SET UP ENCODE BUFFER HEADER
	PUSHJ	P,DECENC	;++ SET UP HEADER WORDS
	JRST	FTST4		;++ GO TO FORMAT SCAN

;++ DECODE COMES HERE

DEC:	HRLI	I,FIOF.		;++ INPUT ASCII
	AOS	INIFLG(LOW)	;++ ??
	MOVEI	M,DECHDR(LOW)	;++ SET UP DECODE BUFFER HDR
	PUSHJ	P,DECENC	;++SET UP HEADER WORDS
	XCT	IIB.		;++ MOVE POINTER UP ONE
	JRST	FTST4		;++ GO TO FORMAT SCAN

DECENC:	TLO	N,ENCFL.	;++ SET ENCODE/DECODE FLAG
	HRRZM	A,2(M)		;++ GET # CHARS PUT IN HDR
	HRLI	0,700		;++ SET UP HEADER
	HRR	0,VADDR.(LOW)	;++ GET ADR OF 1ST WORD
	MOVEM	0,1(M)		;++ SET UP BYTE PTR
	SOS	1(M)		;++POINT TO WORD BEFORE DATA FOR ENC.
	POPJ	P,		;++ RETURN

EDMESS:	ASCIZ /
ENCODE - DECODE ERROR!
/
EDERRM:	TTCALL	3,EDMESS	;++ TYPE OUT ERROR MESSAGE
	SETZM	EDERR(LOW)	;++ CLEAR ERROR FLAG
	JRST	EDFIN		;++ GO TO FIN UUO DIRECTLY SKIPPING OTHERS



SUBTTL	DO LOOKUP AND ENTER FOR FILE NAMES ON TAPE.
;DEVICE NO. IN ACZ AND FILE NAME IN TEMP

FCM:	PUSHJ	P,CLOSI.	;DO INPUT CLOSE ON DEVICE
	PUSH	P,D		;JUST TO BE SAFE
	LDB	D,[POINT 4,M,12] ;GET CHANNEL
IFN REENT,<ADDI	D,(LOW)>
	SETZM	PAKFL.(D)	;ZERO FLAG FOR THIS CHANNEL
	POP	P,D		;RESTORE D
	MOVSI	0,(SIXBIT /DAT/)
	MOVEM	0,TEMP.+1(LOW)	;SET EXTENSION
	PUSHJ	P,FCM1		;DO LOOKUP OR ENTER
	JRST	FI.		;RETURN



FCM1:	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	RFCM		;YES, USE UPDATE MODE
FCM2:	MOVE	0,TEMP.(LOW)	;GET FILE NAME
	ASH	C,1		;SET INDEX FOR LOC. OF NAME
IFN REENT,<ADDI	C,(LOW)>
	JUMPL	I,OENTER	;JUMP ON OUTPUT
	PUSHJ	P,CLOS.		;DO CLOSE BEFORE LOOKUP
	MOVE	0,TEMP.(LOW)	;INPUT,GET FILE NAME
	MOVEM	0,TNAME.(C)	;SAVE THE NAME
	MOVE	0,[LOOKUP 0,TEMP.(LOW)]
IFN REENT,<SUBI	C,(LOW)>
	DPB	C,[POINT 5,0,13];DEPOSIT CHAN. NO.
	PUSH	P,TEMP.+3(LOW)	;SAVE PPN
	XCT	0		;DO LOOKUP
	JRST	RETRY		;DO ANOTHER LOOKUP WITHOUT THE EXT.
	POP	P,TEMP.+3(LOW)	;REESTORE PPN
	POPJ	P,

OENTER:	MOVEM	0,TNAME.+1(C)	;SAVE NAME
IFN REENT,<SUBI	C,(LOW)>
	PUSH	P,TEMP.+3(LOW)	;SAVE PPN
	MOVE	0,[ENTER 0,TEMP.(LOW)]
	DPB	C,[POINT 5,0,13];   CHAN. NO.
	XCT	0		;DO ENTER
	ERROR	NOROM.		;DIRECTORY FULL
	POP	P,TEMP.+3(LOW)	;RESTORE PPN
	POPJ	P,


;HERE TO ENTER UPDATE MODE
;LOOKUP FOLLOWED BY ENTER
;IF INPUT THEN LOOKUP MUST SUCCEDE

RFCM:	JUMPGE	I,RFCMO		;JUST DO LOOKUP/ENTER,DON'T CREATE NEW FILE(ENTER)
	TLZ	I,IOF.		;SET INPUT FLG
	TLO	N,FKNFL.	;FORCE LOOKUP/ENTER. CREATE NEW FILE IF LOOKUP FAILS
RFCMO:	PUSH	P,TEMP.+2(LOW)	;SAVE PROTECTION
	PUSH	P,C		;SAV AC
	PUSHJ	P,FCM2		;DO LOOKUP
	POP	P,C		;RESTORE AC
	POP	P,TEMP.+2(LOW)	;RESTORE PROTECTION
	TLNN	N,FKNFL.	;NEED ENTER FOR OUTPUT?
	POPJ	P,		;NO, ONLY UPDATE IF REALLY NEEDED
	TLO	I,IOF.		;SET OUTPUT FLG
	PUSHJ	P,FCM2		;DO ENTER
	TLZN	N,FKNFL.	;LOOKUP DONE FOR OUTPUT?
	TLZ	I,IOF.		;NO, ENTER FOR INPUT.  RESET INPUT FLAG
	POPJ	P,		;RETURN

;DO ANOTHER LOOKUP ON DECTAPE OR DISC---THIS TIME WITHOUT
;EXTENSION "DAT" .

RETRY:	TLNN	N,FKNFL.	;IS THIS A LOOKUP FOR AN OUTPUT FILE?
	JRST	RETRY1		;NO, REAL LOOKUP FAILURE.
	POP	P,TEMP.+3(LOW)	;RESTORE AC(C)
	MOVE	C,-1(P)		;RESTORE AC C
	TLO	I,IOF.		;SET OUTPUT FLAG--FORCE ENTER.
	PUSHJ	P,FCM2		;DO ENTER
	TLZ	I,IOF.		;RESET FOR INPUT
	MOVE	C,-1(P)		;RESTORE AC C
	JRST	FCM2		;DO CLOSE,LOOKUP/ENTER

;FOR REAL LOOKUP FAILURE.  NOT CREATING NEW RANDOM WRITE FILE
RETRY1:	SETZM	TEMP.+1(LOW)	;CLEAR EXTENSION
	POP	P,TEMP.+3(LOW)	;RESTORE PPN
	XCT	0		;LOOKUP 0,TEMP. IN AC 0
	ERROR	MSNG.		;COMPLETE FAILURE
	MOVE	0,1(P)		;RESTORE PPN
	MOVEM	0,TEMP.+3(LOW)
	POPJ	P,		;SUCCEED

;DO SPECIAL MAG TAPE OPERATION

FNCTN.:	HLLZ	0,M		;DEVICE NO.
	TLO	0,NMTAPE+D	;MTAPE UUO
	XCT	0
	POPJ	P,

;SET OUTPUT LAST FLAG IN WORD CONTAINING SIXBIT DEVICE NAME

SETOU.:	PUSH	P,G
	MOVE	G,DNAME(LOW)
	MOVEI	0,2
	IORM	0,(G)
SETOU1:	POP	P,G
	POPJ	P,

;CLEAR OUTPUT LAST FLAG

CLROU.:	PUSH	P,G
	MOVE	G,DNAME(LOW)
	MOVEI	0,2	
	ANDCAM	0,(G)
	JRST	SETOU1

;CLEAR ITEM COUNT IN INPUT BUFFER HEADER
;     ITEM COUNT USED AS USER-SYSTEM SYNC FLAG

CLRSY.:	PUSH	P,G
	HLRZ	G,DNAME(LOW)
	SETZM	2(G)
	JRST	SETOU1

;DO STATUS CHECK FOR CURRENT DEVICE
STAT.:	HLLZ	0,M		;DEVICE NO.
	IOR	0,[GETSTS F]	;GET STATUS
	XCT	0
	POPJ	P,
;DO CLOSE FOR CURRENT DEVICE

CLOSI.:	SKIPGE	0,RANAC.(LOW)	;DONT WANT TO CLOSE ON RANDOM ACCESS
	JRST	CLRSY.
	EXCH	0,D
	LDB D,[POINT 4,M,12]	;GET CHAN #
IFN REENT,<ADDI	D,(LOW)>
	SETZM	INCNT.(D)	;CLEAR "INPUT"TALLY
	EXCH	0,D
	MOVEI	0,1		;INHIBIT OUTPUT CLOSE
	JRST	CLOSI1

CLOS.:	PUSH	P,D		;GET AN ACC TO PLAY WITH
	LDB	D,[POINT 4,M,12]
IFN REENT,<ADDI	D,(LOW)>
	SKIPL	RANDV.(D)	;ANY OUTPUT STILL TO DO
	JRST	CLOSO1		;NO
	SETZM	BLOCK.(LOW)	;INHIBIT INPUT OF NEXT BLOCK
	PUSHJ	P,ROUTP.	;DUMP CURRENT BUFFERFUL
CLOSO1:	SETZM	RANDV.(D)	;CLEAR INCORE BLOCK
	SETZM	PAKFL.(D)	;CLEAR PACKED I/O FLAG FOR THIS CHAN.
	POP	P,D
	SETZ	0,		;CLOSE BOTH INPUT AND OUTPUT
CLOSI1:	HLL	0,M		;DEVICE NO.
	TLO	0,NCLOSE	;CLOSE UUO
	XCT	0
	JRST	CLRSY.		;CLEAR SYNC FLAG

SUBTTL	DO INPUT FOR CURRENT DEVICE

INP.:	SKIPGE	RANAC.(LOW)	;@@@ARE WE DOING DIRECT ACCESS?
	PJRST	NXRINP		;YES, DO DUMP MODE INPUT
	HLLZ	0,M		;DEVICE NO.
	TLO	0,NINPUT	;INPUT UUO
	SKIPN	(M)		;BUFFERS SET UP
	PUSHJ	P,GETSPC	;NO, TRY TO RECLAIN SOME SPACE
	  XCT	0
	LDB	0,[POINT 4,M,12]	;GET CHAN#
	ADDI	0,INCNT.(LOW)	;POINT TO COUNT
	AOS	@0		;TALLY UP # OF "INPUTS" DONE
	JRST	CLROU.		;CLEAR FLAGS.
SUBTTL	DO OUTPUT FOR CURRENT DEVICE

OUTT.:	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	PJRST	NXROUT		;YES, DO DUMP MODE OUTPUT
	HLLZ	0,M		;DEVICE NO.
	TLO	0,NOUTPT	;OUTPUT UUO
	SKIPN	(M)		;HAVE BUFFERS BEEN SET UP?
	PUSHJ	P,GETSPC	;FIND SOME SPACE FOR THEM
	  XCT	0
	PUSHJ	P,SETOU.	;SET OUTPUT LAST FLAG
	JRST	CLRSY.		;CLEAR USER-SYS SYNCH FLAG


IUSET:	HLLZ	0,M		;CHAN #
	TLO	0,NUSETI	;USETI OPCODE
	JRST	USETIO		;COMMON CODE

USET:	HLLZ	0,M		; CHAN #
	TLO	0,NUSETO	;USETO UUO OPCODE
USETIO:	SKIPN	BLOCK.(LOW)	;BLOCK 0 ?
	AOS	BLOCK.(LOW)	;YES, DON'T ALLOW USETO TO  IT
	HRR	0,BLOCK.(LOW)	;BLOCK WHERE RECORD STARTS
	XCT	0		;
	POPJ	P,
	
SUBTTL	RANDOM ACCESS DUMP MODE INPUT/OUTPUT ROUTINES

NXRINP:	AOS	BLOCK.(LOW)	;GET NEXT BLOCK
RINP.:	PUSH	P,C		;SAVE AN ACC
	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	SKIPL	RANDV.(C)	;DO WE NEED TO OUTPUT INCORE BLOCK
	JRST	RINP1		;NO, JUST DO INPUT
	PUSHJ	P,ROUTPF	;YES, OUTPUT IT BEFORE NEXT INPUT
	HRRE	0,RANDV.(C)	;RECOVER REQUIRED BLOCK
	MOVEM	0,BLOCK.(LOW)	;SET IT UP AGAIN
RINP1:	PUSHJ	P,IUSET		;SET ON REQUIRED BLOCK
ROUTP1:	HRREM	0,RANDV.(C)	;INCORE BLOCK (SOON TO BE)
	PUSHJ	P,RINPF		;DO INPUT
POPC:	POP	P,C		;RESTORE C
	POPJ	P,		;RETURN

RINPF:	SKIPE	HDRADD(LOW)	;LINE BUFFER IN USE?
	JRST	[MOVE	0,@HDRADD(LOW)	;GET REAL BUFFER ADDRESS
		JRST	.+2]		;SKIP RETURN
	HRRZ	0,(M)		;POINT TO DATA-2
	ADDI	0,1		;FORM I/O ADDRESS
	HRRM	0,DMPIO.(LOW)	;STORE ADDRESS IN IOWD
	HLL	0,M		;CHAN. #
	HRRI	0,DMPIO.(LOW)	;POINT TO I/O LIST
	TLO	0,NINPUT	;SET UP UUO
	XCT	0		;DUMP MODE INPUT
	PUSHJ	P,CHKSTS	;CHECK STATUS
	PUSHJ	P,FIXBF		;FIXUP BUFFER HEADERS
	POPJ	P,		;RETURN

NXROUT:	AOS	BLOCK.(LOW)	;GET NEXT BLOCK
ROUTP.:	PUSH	P,C		;SAVE AN AC
	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	PUSHJ	P,ROUTPF	;OUTPUT BLOCK
	SKIPN	RANDV.(C)	;IS REQUIRED BLOCK = 0?
	PJRST	POPC		;YES, MEANS DON'T DO INPUT (CLOSE ONLY)
	PUSHJ	P,IUSET		;SET ON NEXT BLOCK
	HRRE	0,RANDV.(C)	;GET SAVED BLOCK NUMBER
	EXCH	0,BLOCK.(LOW)	;RESTORE BLOCK NUMBER
	JRST	ROUTP1		;DO INPUT OF REQUIRED BLOCK

ROUTPF:	HRRE	0,RANDV.(C)	;GET INCORE BLOCK #
	EXCH	0,BLOCK.(LOW)	;MAY NOT BE SAME
	MOVEM	0,RANDV.(C)	;SAVE REQUIRED BLOCK
	PUSHJ	P,USET		;SET ON THIS BLOCK
	AOS	BLOCK.(LOW)	;SET TO INPUT NEXT BLOCK
	SKIPE	HDRADD(LOW)	;LINE BUFFER IN USE?
	JRST	[MOVE	0,@HDRADD(LOW)	;GET REAL BUFFER ADDRESS
		JRST	.+2]		;SKIP RETURN
	HRRZ	0,(M)		;POINT TO DATA-2
	ADDI	0,1		;FORM I/O ADDRESS
	HRRM	0,DMPIO.(LOW)	;STORE ADDRESS IN IOWD
	HLL	0,M		;CHAN. #
	HRRI	0,DMPIO.(LOW)	;POINT TO I/O LIST
	TLO	0,NOUTPT
	XCT	0		;DO OUTPUT
	PUSHJ	P,CHKSTS	;CHECK STATUS
	POPJ	P,

;HERE TO CHECK STATUS OF DUMP MODE I/O

CHKSTS:	PUSH	P,F		;SAVE F-USED FOR STATUS
	PUSHJ	P,STAT.		;GET STATUS
CHKST1:	TRNE	F,IOWERR!IODERR!IOPERR!IOBKTL!IOTEND
	PUSHJ	P,IOERR.	;I/O ERRORS
	TRNN	F,IODEND	;END OF FILE?
	PJRST	POPF		;NO RESTORE F AND RETURN
	MOVE	0,BLOCK.(LOW)	;GET THE NUMBER WE TRIED
	CAMN	0,[-1]		;-1 IS SPECIAL
	JRST	GOTOM1		;IT WAS
	JUMPGE	I,REOFTS	;TRUE EOF IF INPUT
	SKIPL	LEVEL.(LOW)	;HOPE ITS LEVEL D
	JRST	LCALOC		;NO SUCH LUCK
	AOS	BLOCK.(LOW)	;DO USETO TO BLOCK+1
	PUSHJ	P,USET		;TO ALLOCATE BLOCK+0
	SOS	BLOCK.(LOW)	;ORIGINAL BLOCK
	PUSHJ	P,IUSET		;SET ON IT
	TLC	0,012000	;CHANGE USETI INTO INPUT
	HRRI	0,DMPIO.(LOW)	;GET I/O LIST ADDRESS
	XCT	0		;RETRY INPUT
	PUSHJ	P,STAT.		;GET STATUS 
	TRNN	F,IODEND	;EOF
	JRST	CHKST1		;CHECK FOR I/O ERRORS
REOFTS:	SETZM	RANDV.(C)	;CLEAR INCORE BLOCK # SINCE IT NEVER MADE IT
	JRST	EOFTS. 		;AND GIVE UP

;HERE IF BLOCK # IS -1

GOTOM1:	PUSHJ	P,ZBUFR		;CLEAR BUFFER
	HRRZM	0,RANDV.(LOW)	;SET IN CORE BLOCK TO BE -1
	TRZ	F,IODEND	;CLEAR EOF
	PUSHJ	P,SESTA.	;IN STATUS WORD
	JRST	CHKST1		;RETURN

ZBUFR:	PUSH	P,A		;NEED SOME ACCS
	PUSH	P,B
	HRRZ	B,DMPIO.(LOW)	;ADDRESS OF DATA -1
	SETZM	1(B)		;ZERO FIRST WORD
	HRLI	A,1(B)		;FORM ALT WORD
	HRRI	A,2(B)
	BLT	A,200(B)
	POP	P,B		;RESTORE B
	POP	P,A		;AND A
	POPJ	P,

;HERE TO CREATE NEW FILE IF LEVEL C, A VERY SLOW LOOP 

LCALOC:	PUSHJ	P,ZBUFR		;CLEAR BUFFER
ALOCMR:	PUSHJ	P,USET		;SET ON BLOCK WE NEED
	TLC	0,012000	;USETO TO OUTPUT
	HRRI	0,DMPIO.(LOW)	;I/O LIST ADDRESS
	XCT	0		;DUMP ONE BLOCK
	TRZ	F,IODEND	;CLEAR EOF
	PUSHJ	P,SESTA.	;IN STATUS WORD
	PUSHJ	P,IUSET		;BACK ON BLOCK
	TLC	0,012000	;USETI TO INPUT
	HRRI	0,DMPIO.(LOW)	;PUT ADDRESS BACK ALSO
	XCT	0		;TRY INPUT
	PUSHJ	P,STAT.		;SEE IF WE WON
	TRNE	F,IOWERR!IODERR!IOPERR!IOBKTL!IOTEND
	ERROR	IOERR.		;I/O ERRORS
	TRNE	F,IODEND	;EOF STILL?
	JRST	ALOCMR		;NOT DONE YET
	JRST	CHKST1		;CONTINUE

;HERE TO SETUP FAKE BUFFER COUNT AND BYTE POINTER

FIXBF:	PUSH	P,A		;GET AN ACC
	SKIPN	A,HDRADD(LOW)	;LINE BUFFER IN USE?
	MOVE	A,M		;NO
	MOVE	0,1(A)		;GET BYTE POINTER
	TLZ	0,770077	;CLEAR OUT REST OR IT
	JUMPN	0,.+2		;IF NOT SET UP YET
	MOVSI	0,(POINT 7,,35)	;ASSUME ASCII
	HRR	0,(A)		;GET ADDRESS
	ADDI	0,1		;POINT TO DATA
	JUMPL	I,.+3		;IF INPUT ADVANCE BYTE POINTER
	TLNN	0,4000		;IN ASCII MODE ONLY
	IBP	0		;SO LDB GET FIRST DATA WORD
	MOVEM	0,1(A)		;STORE BYTE POINTER
	HRRI	0,1200		;ASCII WORD COUNT
	TLNE	0,4000		;BUT IF BINARY
	HRRI	0,200		;ONLY 200 WORDS
	HRRZM	0,2(A)		;STORE WORD COUNT
	POP	P,A
	POPJ	P,
RDWR:	SKIPL	RANAC.(LOW)	;RETURN IF RANDOM ACCESS
	TLNN	I,FIOF.		;FORMAT I/O?
	JRST	FTST0		;NO,BINWR TAKES CARE OF THIS FOR BINARY
	TLNN	N,TTYFL.	;TTY IS OK.
	TLNE	I,NLIOF.!STPFF.	;NAMELIST OR TAPE FUNCTION?
	JRST	FTST0		;YES,DON'T SET UP BUFFERS ETC
	TLNN	E,DSKBIT!MTABIT	;MTA?OR DSK?
	JRST	RDWRER		 ;NO,PRINT ERROR MESSAGE
	MOVE	0,-1(M)		;GET NO OF CHARS.(LOW)
	MOVEM	0,CHARS.(LOW)	;STORE IT
	HRRZ	0,-2(M)		;BYTE PTR
	HRRZ	B,-3(M)		;BUFFER PTR
	SUB	0,B		;GET NO WORDS USED
	SUBI	0,2		;MAKE UP FOR 3RD WORD & IN/OUT DIFFERENCES
	MOVEM	0,WORDS.(LOW)	;STORE IT
	SKIPG	(M)		;OUTPUT RING SETUP?
	PUSHJ	P,OUTT.		;NO DO DUMMY OUTPUT
	HRRZ	B,@(M)		;GET 2ND WD IN BUFFER
	HLRZ	B,(B)		;# WORDS IN THIS BUFFER
	HRRZ	D,(M)		;GET BUFFER ADDRESS
	ADDM	B,D		;GET FINAL ADDRESS
IFE REENT,<HRRM	D,BLOTZ		;SET UP BLT>
IFN REENT,<MOVSI 0,(BLT D,)
	HRR	0,D>
	HRLZ	D,-3(M)		;-FROM- INPUT BUFFER
	HRR	D,(M)		;-TO-   OUTPUT BUFFER
	AOBJP	D,.+1		;ST DATA WORD
IFE REENT,<BLOTZ: BLT	D,0	;***THIS INST GETS CHANGED, DO BLT>
IFN REENT,<XCT	0>
	MOVE	0,CHARS.(LOW)	;PICK UP CHAR COUNT
	MOVEM	0,2(M)		;SET IT UP FOR OUTPUT
	HRRZ	0,1(M)		;OUTPUR POINTER
	ADD	0,WORDS.(LOW)	;SKIP OVER WORDS USED ALREADY
	HRRM	0,1(M)		;SET UP OUTPUT POINTER
	TLNN	I,DDF.		;DSK?
	JRST	[MOVEI	D,7	;BACKSPACE CODE
		PUSHJ	P,FNCTN.;NO,MTA. DO A BACKSPACE
		PUSHJ	P,CLOSI. ;CLOSE INPUT
		JRST	FTST3]	;CONTINUE,SET UP LINE BUFFERS ETC.
	LDB	D,[POINT 4,M,12];CHANNEL NUMBER
IFN REENT,<ADDI	D,(LOW)>
	MOVE	0,INCNT.(D)	;GET COUNT OF # OF INPUTS DONE
	MOVEM	0,BLOCK.(LOW)	;SET UP BLOCK#
	PUSHJ	P,CLOSI.	;CLOSE INPUT
	PUSHJ	P,USET		;DO USETI ON 'BLOCK'
	JRST	FTST3		;CONTINUE,SET UP LINE BUFFERS ETC
;THE USER HAS ATTEMPTED TO CHANGE FROM READ TO WRITE WHILE DOING FORMATTED
;I/O, BUT THE DEVICE CANNOT BE BACKSPACED AND THE OUTPUT MAY BE GARBELED

RDWRER:	TTCALL	3,[ASCIZ /
WARNING! FORMATTED READ FOLLOWED BY WRITE MAY FAIL.
/]
	JRST	FTST0		;CONTINUE
SUBTTL	SET STATUS FOR CURRENT DEVICE

SESTA.:	HLLZ	0,M		;DEVICE NO.
	TLO	0,NSETST+F	;SET STATUS UUO
	XCT	0
	POPJ	P,

;I-O WAIT FOR CURRENT DEVICE

WAIT.:	HLLZ	0,M		;DEVICE NO.
	IOR	0,[WAIT]	;WAIT
	XCT	0
	POPJ	P,


;I/O WAIT FOR MAG TAPES

MTPZ.:	HLLZ	0,M		;CHAN NO
	TLO	0,(MTAPE 0,0)	;MTAPE AC,0 UUO
	XCT	0
	POPJ	P,		;RETURN

;DUMMY LOOKUP FOR CURRENT DEVICE-CLEARS SYSTEM CLOSE BIT

LOOK.:	HLLZ	0,M		;DEVICE NO.
	TLO	0,NLOKUP	;LOOKUP UUO
	XCT	0
	JFCL			;ERROR RETURN
	POPJ	P,
SUBTTL	MAGTAPE ROUTINES
; WE ARE ABOUT TO INIT A MAG TAPE UNIT
; SEE IF MAGDEN HAS BEEN CALLED FOR THIS UNIT, IF SO SET
; THE APPROPRIATE MODE BITS IN THE RIGHT HALF OF THE INIT.

MGINIT:	PUSH	P,G		;SAVE
	PUSH	P,C		;AC'S
	PUSH	P,D		;G,C,D
	SETZ	D,		;INIT
	MOVEI	G,TABPT.(LOW)	;POINTERS
FINDLP:	MOVE	C,(G)		;GET A NAME
	TRZ	C,77		;CLEAR FLAG BITS
	CAMN	C,B		;IS IT THE ONE WE WANT?
	JRST	SETMOD		;YES, GO SET MODE
	JUMPN	C,MGNDTS	;NO, IS IT AN EMPTY SLOT?
	MOVE	D,G		;YES, SAVE POINTER
MGNDTS:	SOJ	G,		;NO, DECREMENT POINTER AND
	CAIE	G,MBFBG.(LOW)	;SEE IF DONE WITH TABLE
	JRST	FINDLP		;NOT DONE, GET NEXT NAME
	JUMPE	D,TBLER.	;IF NOT ENTERED & NO ROOM, FAIL!
	JRST	SETRET		;RETURN
SETMOD:	LDB	B,[POINT 6,(G),35]	;GET MODE BITS
	LSH	B,6		;POSITION THEM
	HRRM	B,INIT.(LOW)	;PUT THEM IN INIT.
SETRET:	MOVEI	B,IOCON		;SYNC MODE BIT
	IORM	B,INIT.(LOW)	;SET SYNC MODE FOR INIT
	POP	P,D		;RESTORE
	POP	P,C		;AC'S D,C,G
	POP	P,G
	POPJ	P,		;RETURN

;THIS ROUTINE CONVERTS A NEG F4 DEV NUM TO A POS DEV NUM.
;EXPECTS (0)=DEV NUM, RETURNS DEV NUM IN 0.


MAKPOS:	CAMGE	0,[-5]		;LEGAL NUM?
	ERROR	ILRED.		;NO, PROBABLY "REREAD".
	CAMN	0,[-5]		;CDR?
	MOVEI	0,NEG5.		;YES.
	CAMN	0,[-3]		;LPT?
	MOVEI	0,NEG3.		;YES.
	CAMN	0,[-2]		;PTP?
	MOVEI	0,NEG2.		;YES.
	JUMPGE	0,CPOPJ		;DONE?
	MOVEI	0,NEG1.		;NO,MUST BE TTY.
	POPJ	P,		;RETURN.

SUBTTL	ROUTINES TO RE-USE OLD BUFFER SPACE
;LINK.:	CONTAINS ADDRESS OF CHAIN OF BUFFERS (LEFT HALF)
;BUFFERS CONTAIN XWD BACKWARDS LINK,, FORWARDS LINK
;SET UP BY RELEAS SUBROUTINE
;SECOND WORD IS RETURN FROM DEVSIZ UUO (NUMBER OF BUFFERS ,, SIZE OF BUFFER)

GETSPC:	SKIPN	LINK.(LOW)	;ANY SPACE TO RECOVER?
	POPJ	P,		;NO, JUST RETURN
	PUSH	P,B		;SAVE SOME ACCS
	PUSH	P,C
	LDB	C,[POINT 4,M,12];GET CHANNEL NUMBER
IFN REENT,<ADDI	C,(LOW)>
	MOVE	C,BUFSZ.(C)	;GET REQUIRED BUFFER SIZE AND NUMBER
	HLRZ	B,LINK.(LOW)	;START OF CHAIN
	CAMN	C,1(B)		;WILL THIS SPACE DO
	JRST	FNDSPC		;YES
	HRRZ	B,(B)		;TRY NEXT
	JUMPN	B,.-3		;UNLESS FINISHED
SPCRET:	POP	P,C		;RESTORE ACCS
	POP	P,B
	POPJ	P,

FNDSPC:	PUSH	P,JOBFF		;SAVE JOBFF
	HRRZM	B,JOBFF		;SET TO RECLAIM SPACE
	MOVE	B,(B)		;GET POINTER WORD
	XCT	0		;INPUT OR OUTPUT UUO
	POP	P,JOBFF		;RESTORE 
	TRNN	B,-1		;LAST LINK IN CHAIN?
	JRST	[HLRM	B,LINK.(LOW)	;YES, BACKUP LINK.
		JRST	.+2]		;SKIP NEXT INST
	HLLM	B,(B)		;REMOVE THIS SPACE FROM CHAIN
	MOVSS	B
	TRNN	B,-1		;FIRST LINK IN CHAIN?
	JRST	[HLLM	B,LINK.(LOW)	;YES, ADVANCE LINK.
		TLNN	B,-1		;ONLY WORD IN LINK.
		SETZM	LINK.(LOW)	;YES
		JRST	.+2]		;SKIP NEXT INST.
	HLRM	B,(B)		;BY REPLACING POINTERS
	AOS	-2(P)		;SET FOR SKIP RETURN
	JRST	SPCRET		;AND RETURN

SUBTTL	BINARY ROUTINES
;BINARY DATA TRANSMISSION

BINDT.:	JUMPGE	I,BININ		;JUMP ON INPUT
	TLZE	I,LROF.		;DO OUTPUT NOW?
	PUSHJ	P,BINO.		;YES
ISJ:	MOVE	C,@DADDR.(LOW)	;DATA
	IDPB	C,1(M)		;DEPOSIT DATA
	ADD	J,[XWD 1,0]	;INCREMENT WORD COUNT
	SOSG	2(M)		;TEST COUNT
	TLO	I,LROF.		;SET END FLAG
	JRST	IORTR.		;GET DATA OR FIN

BINO.:	MOVE	A,(M)		;ADDR. OF 1ST WORD
	HLLM	J,2(A)		;STORE WORD COUNT
	PUSHJ	P,OUTPT		;DO OUTPUT
	SOS	2(M)		;ACCOUNT FOR CONTROL WORD
	IBP	1(M)		;ADVANCE PAST 1ST WORD
	HRRZS	J		;CLEAR WORD COUNT
	AOJA	J,CPOPJ		;BUMP PHYSICAL RECORD COUNT

FBINO:	MOVE	A,(M)		;ADDR. OF 1ST WORD
	MOVEM	J,2(A)		;STORE CONTROL WORD
	PUSHJ	P,OUTPT		;DO OUTPUT
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	UPDATE		;YES,UPDATE THE ASSOCIATED VARIABLE
	JRST	FI.		;RETURN
;BINARY OUTPUT

OUTPT:	PUSHJ	P,OUTT.		;DO OUTPUT
	SKIPGE	RANAC.(LOW)	;ALREADY CHECKED IF RANDOM ACCESS
	POPJ	P,		;YES
	PUSHJ	P,STAT.		;STATUS CHECK
	TRNE	F,IODERR!IOPERR!IOWERR!IOTEND!IOBKTL
	PUSHJ	P,IOERR.	;ERRORS
	POPJ	P,

;BINARY TAPE INITIALIZATION BEFORE DATA

BINWR.:	SKIPGE	(M)		;CLOSE DONE LAST?
	JUMPL	I,.+2		;OUTPUT?
	JRST	.+2		;NO, NO
	PUSHJ	P,OUTT.		;DO DUMMY OUTPUT
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	PUSHJ	P,RANBIN	;YES SET UP BLOCK# ETC
	MOVEI	J,1		;INITIALIZE RECORD COUNT
	PUSHJ	P,BUFCA.	;GET BUFFER HEADER ADDRESS
	LDB	A,[POINT 4,M,12]	;GET CHAN #
IFN REENT,<ADDI A,(LOW)		;LOW SEGMENT OFFSET>
	SKIPL	PAKFL.(A)	;PACKED INPUT/OUTPUT LAST?
	JRST	SETPTR		;NO,GO DO BINARY READ/WRITE
	SETZM	PAKFL.(A)	;YES,RESET FLAG
	JUMPGE	I,BINPU		;SEE IF INPUT OR OUTPUT
	PUSHJ	P,OUTT.		;OUTPUT DONE LAST,FORCE OUTPUT
	JRST	SETPTR		;DON'T DO INPUT
BINPU:	PUSHJ	P,INPT.		;DO INPUT
SETPTR:	LDB	0,[POINT 6,1(M),11]; GET POINTER SIZE
	CAIN	0,44		;INIT AS BINARY?
	JRST	PTRINC		;YES
	MOVEI	0,4400		;NO,SET UP POINTER
	HRLM	0,1(M)		;POINTER
	MOVE	0,2(M)		;ADJUST WORD COUNT
	JUMPE	0,PTRINC	;JUMP IF NO ITEM COUNT
	IDIVI	0,5
	MOVEM	0,2(M)		;RESTORE WORD COUNT
	LDB	C,1(M)		;RECORD INDICATOR
	TRNE	C,-1		;LAST RECORD?
	TLO	I,LRIF.		;YES,SET FLAG
PTRINC:	IBP	1(M)		;SET POINTER TO 1ST DATA WORD
	SKIPL	RANAC.(LOW)	;MUST CORRECT ITEM COUNT IF RANDOM ACCESS
	JUMPGE	I,IORTR.	;GO IF INPUT
	SOS	2(M)		;REDUCE ITEM COUNT
	JRST	IORTR.		;GET DATA

;CALCULATE BLOCK # WHERE BINARY RECORD STARTS. THIS IS FOR BINARY INPUT

RANBIN:	MOVE	A,DEVNUM(LOW)	;UNIT NUMBER
	IMULI	A,5		;5 ENTRIES/UNIT
IFN REENT,<ADDI	A,(LOW)>
	MOVE	A,FILES.-2(A)	;GET RECORD SIZE IN WORDS
	IDIVI	A,177		;177 DATA WDS / BUFFER
	JUMPE	B,.+2		;REMAINDER?
	AOJ	A,		;YUP! INCREMENT BUFFERS/RECORD
	MOVE	B,ASVAR.(LOW)	;GET RECORD #
	SOJ	B,		;POINT TO BEGINNING OF ONE WANTED
	IMUL	A,B		;GET BLOCK WHERE RECORD STARTS
	ADDI	A,1		;POINT TO 1ST BLOCK OF RECORD
	MOVEM	A,BLOCK.(LOW)	;STORE IT
	LDB	C,[POINT 4,M,12]
IFN REENT,<ADDI	C,(LOW)>
	HRRZ	B,RANDV.(C)	;GET INCORE BLOCK
	CAME	B,BLOCK.(LOW)	;IS IT THE ONE WE WANT?
	PUSHJ	P,RINP.		;NO
	JUMPGE	I,.+2		;OUTPUT?
	HRROS	RANDV.(C)	;YES, SIGNAL OUTPUT FOR THIS BLOCK
	PJRST	FIXBF		;RESET WORD COUNT AND BYTE POINTER

;UPDATE THE ASSOCIATED VARIABLE IN THE PROGRAM AND CLEAR RANDOMACCESS FLG

UPDATE:	AOS	ASVAR.(LOW)	;POINT TO NEXT RECORD IN FILE
	MOVE	B,FILNUM(LOW)	;GET UNIT NUMBER
	IMULI	B,5		;5 ENTRIES/UNIT
IFN REENT,<ADDI B,(LOW)>
	MOVE	C,FILES.-1(B)	;GET ADDRESS OF ASSOC VARIABLE
	MOVE	B,ASVAR.(LOW)	;GET INTERNAL ASSOC VARIABLE VALUE
	MOVEM	B,(C)		;STORE IN REAL ASSOC VARIABLE
	SETZM	RANAC.(LOW)	;*** CLEAR RANDOM ACCESS FLAG***
	JRST	FIB.		;RETURN TO USER


;BINARY DATA INPUT

BININ:	SOSG	2(M)		;DROP WORD COUNT
	PUSHJ	P,BINI.		;DO INPUT
LDIN:	ILDB	C,1(M)		;GET WORD
	MOVEM	C,@DADDR.(LOW)	;STORE DATA
	JRST	IORTR.		;RETURN

BINI.:	TLNE	I,LRIF.		;LAST RECORD IN?
	ERROR	LISTB.		;YES,ERROR
	PUSHJ	P,INPT.		;NO,DO INPUT
	ILDB	C,1(M)		;RECORD INDICATOR
	TRNE	C,-1		;LAST RECORD?
	TLO	I,LRIF.		;YES,SET FLAG
	SKIPG	2(M)		;ARE THERE ANY RECORDS LEFT?
	JRST	BINI1		;NO, RETURN
	SOS	2(M)		;DROP WORD COUNT
	POPJ	P,		;GET FIRST WORD

BINI1:	POP	P,A
	JRST	IORTR.		;RETURN

;BINARY END ROUTINE

BINEN.:	JUMPL	I,FBINO		;JUMP ON OUTPUT
MAD:	MOVE	C,(M)		;ADDR. OF BUFFER
	MOVE	C,2(C)		;GET CONTROL WORD
	TRNE	C,-1		;LAST PHYSICAL RECORD?
	JRST	CLFI		;YES
	PUSHJ	P,INPT.		;NO,GET NEXT RECORD
	JRST	MAD
CLFI:	SETOM	2(M)		;SET TO NEXT BUFFER
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	JRST	UPDATE		;UPDATE ASSOCIATED VARIABLE & CLEAR RANAC.
	JRST	FIB.		;RETURN CLEAR END. & ERR. IF SET

;BINARY INPUT

INPT.:	PUSHJ	P,INP.		;DO INPUT
	SKIPGE	RANAC.(LOW)	;RANDOM ACCESS?
	POPJ	P,		;YES, STATUS CHECKED ALREADY
	PUSHJ	P,STAT.		;DO STATUS CHECK
	TLNE	I,IECF.		;CHECK FOR END OF FILE?
	JRST	TIOT		;NO END OF FILE CHECK
	TRNE	F,IODEND
	JRST	EOFTS.		;END OF FILE
TIOT:	TRNE	F,IOTEND!IODERR!IOPERR!IOBKTL
	ERROR	IOERR.		;ERRORS
	POPJ	P,

; CALLED BY: PUSHJ P,FNDSLT
; FINDS AN AVAILABLE SLOT IN DYNDV.
; BAD RETURN: TBLER.---DYNDV. IS REALLY FULL.
; GOOD RETURN: (C)=THE NUMBER OF THIS CHANNEL,(D)=PTR TO SLOT IN DYNDV.

FNDSLT:	MOVEI	D,DYNDV.+1(LOW)	;PTR TO FIRST USABLE SLOT
SLLOOP:	SKIPN	(D)		;IS SLOT EMPTY?
	JRST	GOTSLT		;YES
	CAIGE	D,DYNND.(LOW)	;DONE?
	AOJA	D,SLLOOP	;NO, LOOP BACK.
	ERROR	TBLER.		;YES, FAIL!

GOTSLT:	MOVEI	C,DYNDV.(LOW)	;LOWEST
	SUBM	D,C		;CHANNEL NUMBER
	CAMLE	C,DEVNO.(LOW)	;HIGHER THAN PREVIOUS NUMBER?
	MOVEM	C,DEVNO.(LOW)	;YES, UPDATE
	POPJ	P,		;RETURN

XVAR:	XWD	VAR.,VAR.	;LENGTH OF PUSHDOWN LIST
ACBLT:	XWD	B,SAVEAC+B	;BLT POINTER FOR AC SAVE
PTRU:	POINT	4,A,12		;AC FIELD OF UUO
FORZRO:	SIXBIT	/ FOR00/
	END

