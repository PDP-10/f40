TITLE DEFINE FILE  FORTRAN IV DIRECT ACCESS ROUTINES
SUBTTL	V30.203	09-JUN-71  	V.ALUSIC/DMN

MLON
ENTRY		DEFINE
EXTERN		FILES.,RANAC.,RECNO.,EXIT.,DYDVL.,TYPER.

A=1
B=2
C=3
D=4
E=5
F=6

	SIXBIT	/DEFINE/
DEFINE:	0
	MOVE	A,@(16)		;DEV NO
	CAILE	A,DYDVL.	;LEGAL NUMBER?
	JRST	ILLNUM		;NO
	IMULI	A,5		;SET UP TABLE ENTRY
	HRRZ	D,3(16)		;PICK UP FILENAME ADDR.
	HRRZI	E,1(D)		;EXT
	MOVE	F,[POINT 7,@D]
	MOVE	0,[POINT 6,FILES.-5(A)]
	HRROI	B,-^D10		;10 CHARS
GETCHR:	ILDB	C,F		;GET CHR
	JUMPE	C,BACK		;NULL => FINISHED
	CAIN	C,56		;DEC PT?
	JRST	[HRROI	B,-3	;YES
		MOVE	0,[POINT 6,FILES.-4(A)]
		JRST	GETCHR]	;RETURN FOR EXT
	SUBI	C,40		;NO, CONVERT TO 6-BIT
	IDPB	C,0		;PUT IT IN FILES.
	AOJL	B,GETCHR	;NOT DONE? THEN GET NEXT CHR
BACK:	HLLZS	FILES.-4(A)	;CLEAR PROTECTION CODE
	MOVE	D,@1(16)	;PICK UP RECORD SIZE
	MOVEM	D,FILES.-2(A)	;STORE IN 4TH WD
	HRRZ	D,2(16)		;PICK UP VARIABLE ADDR
	HRRZM	D,FILES.-1(A)	;STORE IN 5TH WD
	SETZM	FILES.-3(A)	;ZERO BY DEFAULT
	HLRZ	D,4(16)		;GET OP CODE
	TRZ	D,777		;AND ONLY OP CODE
	CAIE	D,(ARG)		;IF ARG ALL OK
	JRA	16,4(16)	;NO, SO RETURN
	MOVE	D,@4(16)	;GET PROJ NO
	HRLM	D,FILES.-3(A)	;PUT IN 3RD WD  LH
	HLRZ	D,5(16)		;NEXT OP CODE
	TRZ	D,777
	CAIE	D,(ARG)		;STILL GETTING ARGS
	JRA	16,5(16)	;NO
	MOVE	D,@5(16)	;GET PROG NO
	HRRM	D,FILES.-3(A)	;3RD WD RH
	HLRZ	D,6(16)
	TRZ	D,777
	CAIE	D,(ARG)
	JRA	16,6(16)	;RETURN
	MOVE	D,@6(16)	;GET PROTECTION CODE
	HRRM	D,FILES.-4(A)	;STORE IT WITH EXTENSION
	JRA	16,7(16)	;RETURN
ILLNUM:	IDIVI	A,^D10		;MAKE TWO DIGITS
	IORI	A,"0"		;THEN ASCII
	IORI	B,"0"
	MOVE	C,[POINT 7,ILLMES+5,27]
	IDPB	A,C		;PUT NUMBER IN MESSAGE
	IDPB	B,C
	MOVSI	0,ILLMES	;FATAL MESSAGE
	PUSHJ	17,TYPER.	;NEVER TO RETURN

ILLMES:	ASCIZ /?DIRECT ACCESS DEVICE NUMBER XX IS ILLEGAL/




	END


;CALCULATE BUFFER HEADER INFORMATION
;WORDS TO BE SKIPPED IN BUFFER BEFORE DESIRED RECORD= WORDS.
;CHARACTERS TO BE SKIPPED IN BUFFER BEFORE RECORD   = CHARS.
;THE BLOCK TO BE ACCESSED IN WHICH THE RECORD LIES  = BLOCK.
;THIS IS FOR ASCII INPUT

RANASC:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	MOVE	D,DEVNUM	;F4 DEVICE (DATA SET) NUMBER
	IMULI	D,5		;5 WORDS PER DEVICE
	MOVE	A,FILES.-2(D)	;PICK UP RECORD SIZE IN CHARS
	ADDI	A,2		;CRLF/LINE
	SETZ	B
	IDIVI	A,5		;WDS/RECORD
	JUMPE	B,.+2		;REMAINDER?
	AOS	A		;YES, ADD ONE FOR REMAINDER
	MOVEM	A,WDPREC	;STORE IT AWAY
	MOVEI	B,200			;DSK BUFFER SIZE
	IDIV	B,A		;RECORDS/BUFFER IN B
	MOVE	A,ASVAR.	;RECORD # IN FILE TO BE ACCESSED NEXT
	SETZ	C
	EXCH	A,B
	IDIV	B,A		;REC #/(REC/BUFFER)=BLOCK. IN ACB
	JUMPE	C,.+2		;0=> LAST RECORD THIS BLOCK
	AOSA	B		;NEXT BLOCK
	MOVE	C,A	;PUT RECORD # IN BLOCK TO BE ACCESSED, IN AC'C' IF LAST.
;BLOCK FOR USETI IN B ,  RECORD # IN 'C'
;SET UP INFO FOR BUFFER HEADER FOR INPUT

	MOVEM	B,BLOCK.	;BLOCK #
	MOVEM	C,RECORD	;RECORD # WITHIN BLOCK
	MOVE	A,FILES.-2(D)	;CHARS/RECORD
	SOS	C
	IMUL	A,C	;CHARS 'TILL DESIRED RECORD STARTS
	MOVEM	A,CHARS.	;STORE
	IMUL	C,WDPREC	;WORDS TILL RECORD STARTS
	MOVEM	C,WORDS.	;STORE
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	SKIPL	FAKEIN		;ARE WE DOING FAKE INPUT FOR OUTPUT?
	POPJ	P,		;NO,RETURN
	SETOM	GOBACK		;SET PREMATURE RETURN FLAG FOR INPUT
	PUSHJ	P,INP.		;GET A BUFFERFULL
	SETZM	GOBACK		;CLEAR FLAG

