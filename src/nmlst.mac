TITLE NMLST.  V.30.0.134
SUBTTL	9-APR-71	/DMN

;REENT==1 GIVES RE-ENTRANT FORTRAN OP SYSTEM
IFNDEF REENT,<REENT==0>
IFN REENT,<	HISEG	>

;THE NAMELIST PROGRAM CONSISTS OF TWO MAJOR ROUTINES - NLIN.
;FOR NAMELIST INPUT, AND NLOUT. FOR NAMELIST OUTPUT. THE CALLING
;SEQUENCE FOR THE NAMELIST PROGRAM IS
;	MOVEI	B, POINTER TO NAMELIST TABLE
;	PUSHJ	P, NMLST.
;IF ACCUMULATOR 11 HAS A ONE IN THE SIGN BIT, THE NAMELIST
;OUTPUT ROUTINE IS CALLED. OTHERWISE, THE NAMELIST INPUT 
;ROUTINE IS CALLED. THIS ACCUMULATOR IS USUALLY SET UP BY
;FORSE. BEFORE NAMELIST IS CALLED.
;THE NAMELIST TABLE IS CONSTRUCTED BY THE COMPILER. THE FIRST
;WORD OF THE TABLE IS THE NAMELIST NAME IN RADIX 50 FORMAT.
;FOLLOWING THAT ARE A NUMBER OF TWO-WORD ENTRIES FOR SCALAR
;VARIABLES, AND A NUMBER OF (N+5)-WORD ENTRIES FOR ARRAY VARIABLES
;WHERE N IS THE DIMENSIONALITY OF THE ARRAY). THE ENTRIES HAVE
;THE FOLLOWING FORMAT:

;SCALAR VARIABLE ENTRY:
;1ST WORD -	BIT 0 IS 1 (COMPILER BUG)
;		BITS 1-3 CONTAIN A CODE FOR THE TYPE OF VARIABLE.
;		BITS 4-35 CONTAIN THE RADIX 50 NAME OF THE VARIABLE.

;2ND WORD -	LEFT HALF IS ZERO
;		RIGHT HALF CONTAINS ADDRESS OF THE SCALAR VARIABLE.

;ARRAY VARIABLE ENTRY:
;1ST WORD -	BIT 0 IS 1
;		BITS 1-3 CONTAIN A CODE FOR THE TYPE OF VARIABLE
;		BITS 4-35 CONTAIN THE RADIX 50 NAME OF THE VARIABLE

;2ND WORD -	BASE ADDRESS OF THE ARRAY
;3RD WORD -	DIMENSIONALITY OF THE ARRAY

;THE NEXT (N+2) WORDS CONTAIN THE N MULTIPLIERS P(0) THROUGH P(N-1)
;AND THE OFFSET AND SIZE OF THE ARRAY.

;THE NAMELIST TABLE IS TERMINATED BY A ZERO WORD.
;THE CODE BITS DESCRIBED ABOVE ARE DEFINED AS FOLLOWS:
;	CODE		TYPE OF VARIABLE
;	0		INTEGER
;	1		UNUSED
;	2		REAL
;	3		LOGICAL
;	4		OCTAL - NOT USED
;	5		LITERAL (HOLLERITH) - NOT USED
;	6		DOUBLE PRECISION
;	7		COMPLEX
;ACCUMULATOR ASSIGNMENTS

	A=	0	;CHARACTER AC - RECEIVES CHARACTERS FROM
			;CHINN. AND DELIVERS CHARACTERS TO DEPOT.
	B=	1	;POINTER TO BEGINNING OF NAMELIST TABLE
	C=	2	;USED AS A POSITION POINTER IN NAMELIST
			;TABLE IN NLIN. , USED AS A COLUMN COUNTER
			;IN NLOUT.
	D=	3	;USED AS AN AOBJN COUNTER FOR ARRAY INPUT
			;AND OUTPUT.
	E=	4	;SCRATCH
	F=	5	;SCRATCH
	G=	6	;SCRATCH
	M=	7	;POINTER TO THE CUURRENT BUFFER HEADER
	S=	14	;USED TO GATHER A VARIABLE NAME
	J=	15	;SCRATCH
	N=	12	;JSP AC FOR INTERNAL SUBROUTINE CALLS
	K=	13	;SCRATCH
	Q=	16	;FLAGS IN LEFT HALF, SET UP BY FORSE
	P=	17	;PUSHDOWN POINTER, SET UP BY FORSE.
IFN REENT,<LOW=	16>
IFE REENT,<LOW=	0>

;PARAMETER ASSIGNMENTS FOR ASCII CHARACTERS

	SPACE=	40	;ASCII SPACE
	DOLLAR=	44	;ASCII DOLLAR SIGN <$>
	COMMA=	54	;ASCII COMMA <,>
	SNGQOT=	47	;ASCII SINGLE QUOTE <'>
	LFTPAR=	50	;ASCII LEFT PARENTHESIS <(>
	RGTPAR=	51	;ASCII RIGHT PARENTHESIS <)>
	EQUALS=	75	;ASCII EQUAL SIGN <=>
	AMPRSN=	46	;ASCII AMPERSAND <&>
	TAB=	11	;ASCII TAB
	PERIOD=	56	;ASCII PERIOD <.>
	CR=	15	;ASCII CARRIAGE RETURN CHARACTER
	LF=	12	;ASCII LINE FEED CHARACTER


ENTRY	NMLST.

EXTERN	INTI.,FLIRT.,DIRT.,CHINN.,IIB.,EOL.,OVFLS.
EXTERN	INTO.,FLOUT.,DOUBT.,DEPOT.,NMLER.,ENDLN.,DELIM.
;NAMELIST OUTPUT SECTION
;THE MAJOR FLOW OF EVENTS IN THE NAMELIST OUTPUT SECTION IS
;AS FOLLOWS: THE ROUTINE IS GIVEN A POINTER TO A NAMELIST TABLE
;(IN ACCUMULATOR 1), AND IT PROCEEDS TO OUTPUT THE VALUE OF
;EACH ARRAY IN THE TABLE, OR OF EACH ELEMENT OF EACH ARRAY IN
;THE TABLE. SINCE THERE IS INFORMATION IN THE TABLE INDICATING
;THE TYPE OF EACH VARIABLE, AND WHETHER THAT VARIABLE IS AN
;ARRAY OR A SCALAR, NLOUT. CAN DO THE FOLLOWING:
;	1. GET THE NEXT VARIABLE NAME FROM THE TABLE. PRINT
;	   IT ON THE OUTPUT DEVICE, FOLLOWED BY AN EQUAL SIGN.
;	2. IF THE VARIABLE IS A SCALAR, SIMPLY PLACE THE CORE
;	   ADDRESS WHERE THE VALUE OF THAT VARIABLE MAY BE FOUHD
;	   IN ACCUMULATOR D, AND PROCEED TO 4.
;	3. IF THE VARIABLE IS AN ARRAY, PREPARE AN AOBJN WORD
;	   IN ACCUMULATOR D, WITH THE LEFT HALF HAVING A NEGATIVE
;	   COUNT OF THE NUMBER OF ELEMENTS IN THE ARRAY, AND THE
;	   RIGHT HALF CONTAINING THE CORE ADDRESS OF THE BASE OF
;	   OF THE ARRAY.
;	4. PICK UP THE TYPE OF THE ARGUMENT, AND DISPATCH TO THE
;	   PROPER OUTPUT ROUTINE AS A FUNCTION OF THE SCALAR/ARRAY
;	   AND TYPE NATURE OF THE ARGUMENT.
;A COLUMN COUNTER IS KEPT AT ALL TIMES SO THAT NLOUT. MAY KNOW
;WHICH COLUMN OF THE OUTPUT DEVICE WILL RECEIVE THE NEXT CHARACTER.
;BEFORE CALLING ONE OF THE OUTPUT ROUTINES, IT CHECKS TO MAKE SURE
;THERE IS ENOUGH ROOM ON THE LINE. IF NOT, THE ROUTINE CRLF IS
;CALLED TO OUTPUT A CARRIAGE RETURN, LINE FEED AND RESET THE
;COLUMN COUNTER.


NMLST.:	JUMPGE	11,NLIN.	;CHECK FORSE. ACCUMULATOR
				;IF SIGN BIT=1, ITS OUTPUT
NLOUT.:	SETOM	EOL.(LOW)	;SET EOL. FLAG
	MOVEI	A, SPACE	;OUTPUT A SPACE IN COLUMN 1
	PUSHJ	P, DEPOT.	;SEND THE CHARACTER OFF TO FORSE.
	MOVEI	A, DOLLAR	;OUTPUT A DOLLAR SIGN IN COL. 2
	PUSHJ	P, DEPOT.	;...
	MOVEI	C, 7		;SET UP A TEMPORARY COLUMN COUNT
	MOVE	S, (B)		;GET THE NAMELIST NAME
	PUSHJ	P, NTYPO	;TYPE IT OUT
	PUSHJ	P, CRLF		;TYPE CR,LF, SET UP COLUMN COUNT

NXTOUT:	AOJ	B,		;MOVE POINTER TO NEXT VARIABLE
	SKIPN	(B)		;ARE WE AT THE END OF THE TABLE?
	JRST	OUTFIN		;YES, FINISH THE OUTPUT AND EXIT
	MOVE	S, (B)		;NO, PICK UP THE VARIABLE NAME
	PUSHJ	P, VTYPO	;TYPE THE NAME, AND AN EQUAL SIGN
	LDB	E, [POINT 3,(B),3]
	SKIPGE	(B)		;IS THIS A SCALAR OR AND ARRAY?
	JRST	ARRAY		;BIT 0 IN ON - ITS AN ARRAY
	MOVE	D, 1(B)		;SCALAR - GET ADDRESS FROM TABLE
	HRRZ	E, TABLE(E)	;GET ADDRESS OF PROPER ROUTINE
	PUSHJ	P, (E)		;AND OUTPUT ACCORDING TO TYPE
	AOJA	B, NXTOUT	;FOR NEXT VARIABLE

ARRAY:	MOVEI	D, 4(B)		;ARRAY OUTPUT, SET UP AN AOBJN WORD
	ADD	D, -2(D)	;USE DIMENSIONALITY COUNT TO MOVE
				;POINTER DOWN TO REGISTER CONTAIN-
				;ING SIZE OF ARRAY
	MOVN	D, (D)		;GET NEGATIVE COUNT OF ARRAY SIZE
	MOVSS	D		;WE WANT IT IN LEFT HALF
	HRR	D, 1(B)		;PUT BASE ADDRESS OF ARRAY IN R.H.
	HLRZ	E, TABLE(E)	;GET ADDRESS OF PROPER ROUTINE
	PUSHJ	P, (E)		;AND OUTPUT ACCORDING TO TYPE
	ADDI	B, 4		;MOVE NAMELIST POINTER PAST...
	ADD	B, -2(B)	;ALL THE MULTIPLIERS AND STUFF
	JRST	NXTOUT		;GET THE NEXT VARIABLE


;DISPATCH TABLE FOR OUTPUT ACCORDING TO VARIABLE TYPE
TABLE:	XWD	AINTOUT,INTOUT	;INTEGER OUTPUT
ERROR:	JRST	NMLER.		;CALL NAMELIST ERROR ROUTINE
	XWD	ARLOUT,RLOUT	;REAL OUTPUT
	XWD	ALOGOUT,LOGOUT	;LOGICAL OUTPUT
	XWD	ERROR,ERROR	;OCTAL - NOT USED
	XWD	ERROR,ERROR	;LITERAL -NOT USED
	XWD	ADBLOUT,DBLOUT	;DOUBLE PRECISION OUTPUT
	XWD	ACMPOUT,CMPOUT	;COMPLEX OUTPUT

;INTEGER OUTPUT ROUTINE
INTOUT:	CAIGE	C, 20		;IS THERE ROOM FOR VARIABLE?
	PUSHJ	P, CRLF		;NO, OUTPUT A CR-LF BEFORE STARTING
	SUBI	C, 20		;MOVE CHARACTER COUNT FOR NUMBER
	PUSH	P, ZERO		;PUT A ZERO ON PD LIST FOR INTO.
	MOVE	A, (D)		;GET THE VARIABLE
	PUSHJ	P, INTO.	;VARIABLE FIELD INTEGER OUTPUT
	POP	P, A		;GET RID OF THE ZERO ON PD LIST
	JRST 	PCOMMA		;PRINT A COMMA, THEN EXIT

;REAL OUTPUT ROUTINE
RLOUT:	CAIGE	C, 20		;IS THERE ROOM FOR THE VARIABLE?
	PUSHJ	P, CRLF		;NO, OUTPUT A CR-LF BEFORE STARTING
	SUBI	C, 20		;MOVE COLUMN COUNT FOR NUMBER
	PUSH	P, [XWD 200000,0] ;SET UP FOR "G" TYPE OUTPUT
	MOVE	A,(D)		;GET VARIABLE
	PUSHJ	P, FLOUT.	;VARIABLE FIELD REAL OUTPUT
	POP	P, A		;GET RANDOM THING OFF THE PD LIST
	JRST	PCOMMA		;PRINT A COMMA,THEN EXIT

;LOGICAL OUTPUT ROUTINE
LOGOUT:	CAIGE	C, 2		;IS THERE ENOUGH ROOM FOR T OR F?
	PUSHJ	P, CRLF		;NO, OUTPUT A CR-LF BEFORE STARTING
	SUBI	C, 2		;MOVE COLUMN COUNTER FOR NUMBER
	MOVEI	A, "T"		;ASSUME THAT WE HAVE A "TRUE"
	SKIPL	(D)		;IS IT REALLY A "TRUE"
	MOVEI	A, "F"		;NO, ITS AN "F"
	PUSHJ	P, DEPOT.	;PRINT THE CHARACTER
	JRST	PCOMMA		;PRINT A COMMA, THEN EXIT

;DOUBLE PRECISION OUTPUT ROUTINE
DBLOUT:	CAIGE	C, 32		;IS THERE ROOM FOR THE NUMBER?
	PUSHJ	P, CRLF		;NO, TYPE A CR-LF BEFORE STARTING
	SUBI	C, 32		;UPDATE COLUMN COUNT FOR NUMBER
	MOVE	E, B		;SAVE NAMELIST TABLE POINTER
	PUSH	P, ZERO		;PUT A ZERO ON PD LIST FOR VAR. FIELD
	MOVE	A, (D)		;GET HIGH ORDER D.P. WORD
	AOJ	D,		;MOVE POINTER TO LOW ORDER PART
	MOVE	B, (D)		;GET LOW ORDER PART OF D.P. WORD
	PUSHJ	P, DOUBT.	;VARIABLE FIELD DOUBLE PRECISION OUTPUT
	POP	P, A		;GET RID OF THE ZERO ON PD LIST
	MOVE	B, E		;RESTORE THE NAMELIST TABLE POINTER
	JRST	PCOMMA		;PRINT A COMMA, THEN EXIT


;COMPLEX OUTPUT ROUTINE
CMPOUT:	CAIGE	C, 21		;ENOUGH ROOM FOR REAL PART?
	PUSHJ	P, CRLF		;NO, OUTPUT A CARRIAGE RETURN
	SUBI	C, 21		;ACCOUNT FOR <(> AND NUMBER
	MOVEI	A, LFTPAR	;OUTPUT A LEFT PARENTHESIS
	PUSHJ	P, DEPOT.	;...
	MOVE	A, (D)		;GET THE REAL PART OF THE NUMBER
	AOJ	D,		;MOVE POINTER TO THE COMPLEX PART
	PUSH	P, ZERO		;PUT A 0 ON PD LIST FOR VAR. FIELD
	PUSHJ	P, FLOUT.	;OUTPUT REAL PART OF COMPLEX NUMBER
	PUSHJ	P, PCOMMA	;PRINT A COMMA AFTER REAL PART
	CAIGE	C, 21		;ENOUGH ROOM FOR IMAGINARY PART?
	PUSHJ	P, CRLF		;NO, OUTPUT A CR-LF BEFORE STARTING
	SUBI	C, 21		;ACCOUNT FOR NUMBER AND <)>
	MOVE	A, (D)		;GET IMAGINARY PART OF COMPLEX
	PUSHJ	P, FLOUT.	;OUTPUT IT
	POP	P, A		;GET THE ZERO BACK OFF THEPD LIST
	MOVEI	A, RGTPAR	;OUT PUT A RIGHT PARENTHESIS
	PUSHJ	P, DEPOT.	;PRINT THE CHARACTER
	JRST	PCOMMA		;TYPE A COMMA, THEN EXIT


;ARRAY INTEGER OUTPUT
AINTOUT:PUSHJ	P, COUNT1	;GET A COUNT OF REPEATED INTEGERS
	PUSHJ	P, INTOUT	;OUTPUT AN INTEGER
	AOBJN	D, AINTOUT	;LOOP BACK FOR MORE
	POPJ	P,		;EXIT AT END OF ARRAY

;ARRAY REAL OUTPUT
ARLOUT:	PUSHJ	P, COUNT1	;GET A COUNT OF REPEATED REALS
	PUSHJ	P, RLOUT	;OUTPUT A REAL NUMBER
	AOBJN	D, ARLOUT	;LOOP BACK FOR MORE
	POPJ	P,		;EXIT AT END OF ARRAY

;ARRAY LOGICAL OUTPUT
ALOGOUT:PUSHJ	P, COUNT1	;GET A COUNT OF REPEATED LOGICALS
	PUSHJ	P, LOGOUT	;OUTPUT A LOGICAL NUMBER
	AOBJN	D, ALOGOUT	;LOOP BACK FOR MORE
	POPJ	P,		;EXIT AT END OF ARRAY

;ARRAY DOUBLE PRECISION OUTPUT
ADBLOUT:PUSHJ	P, COUNT2	;GET COUNT OF REPEATED DOUBLES
	PUSHJ	P, DBLOUT	;OUTPUT A DOUBLE PRECISION NUMBER
	AOBJN	D, ADBLOUT	;LOOP BACK FOR MORE
	POPJ	P,		;EXIT

;ARRAY COMPLEX NUMBER OUTPUT
ACMPOUT:PUSHJ	P, COUNT2	;GET COUNT OF REPEATED COMPLEXI
	PUSHJ	P, CMPOUT	;OUTPUT A COMPLEX NUMBER
	AOBJN	D, ACMPOUT	;LOOP BACK FOR MORE
CPOPJ:	POPJ	P,		;EXIT AT END OF ARRAY
;ROUTINE TO COUNT THE NUMBER OF REPEATED SINGLE PRECISION
;QUANTITIES IN AN ARRAY (I.E. INTEGER,REAL,LOGICAL,LITERAL,OCTAL)
;AND OUTPUT THE COUNT (IF > 1) AS AN ITEGER FOLLOWED BY A *
COUNT1:	SETO	E,		;SET COUNT TO -1
LOOP1:	AOJ	E,		;INCREMMENT COUNT
	MOVE	F, 1(D)		;GET NEXT QUANTITY FROM ARRAY
	CAMN	F, (D)		;DOES IT MATCH?
	AOBJN	D, LOOP1	;OR ARE WE THROUGH THE ARRAY?
	JUMPE	E, CPOPJ	;IF COUNT WAS ZERO, IGNORE IT
	CAIGE	C, 22		;ENOUGH ROOM FOR EVERYTHING
	PUSHJ	P, CRLF		;NO, OUTPUT A CR-LF
	AOJ	E,		;REPETITION COUNT WAS ONE OFF
NUMTYP:	PUSHJ	P,NUMOUT	;PRINT REPETITION COUNT
	MOVEI	A,52		;PICK UP *
	JRST	DEPOT.		;OUTPUT IT
NUMOUT:	IDIVI	E, 12		;DECIMAL NUMBER OUTPUTTER
	HRLM	F, (P)		;STORE REMAINDER ON PDLIST
	JUMPE	E,.+2		;ALL DONE?
	PUSHJ	P, NUMOUT	;NO, CALL NUMOUT RECURSIVELY
NUMO2:	HLRZ	A, (P)		;YES, GET  NUMBER OFF STACK
	ADDI	A, 60		;MAKE IT ASCII
	SOJA	C, DEPOT.	;UPDATE COLUMN COUNT,TYPE,EXIT

;ROUTINE TO COUNT THE NUMBER OF REPEATED DOUBLE PRECISION 
;QUANTITIES IN AN ARRAY (DOUBLE PRECISION OR COMPLEX) AND OUTPUT
;THEM AS ABOVE
COUNT2:	MOVEI	E, 0		;INITIALIZE REPETITITION COUNT
	JRST	LOOP2A		;SKIP THE INCREMENTATION
LOOP2:	AOJ	D,		;INCREMENT THE ARRAY POINTER
	AOJ	E,		;INCREMENT THE REPETITION COUNT
LOOP2A:	MOVE	F, 2(D)		;PICK UP NEXT DOUBLE QUANITYT
	MOVE	G, 3(D)		;...
	CAMN	F, (D)		;DO THE FIRST WORDS MATCH?
	CAME	G, 1(D)		;YES, DO THE SECOND WORDS MATCH?
	JRST	.+2		;NO
	AOBJN	D, LOOP2	;TRY SOME MORE UNLESS THRU ARRAY
	JUMPE	E, CPOPJ	;IGNORE IF REPETITION COUNT IS 0
	CAIGE	C, 34		;ROOM ENOUGH FOR EVERYTHING?
	PUSHJ	P, CRLF		;NO, GIVE IT A CR-LF
	AOJA	E, NUMTYP	;TYPE IT OUT AND EXIT


;ROUTINE TO OUTPUT A CR-LF AND RESET THE COLUMN COUNT TO 170
CRLF:	MOVEI	A, CR		;ZAP! OUTPUT A CR
	PUSHJ	P, DEPOT.	;...
	MOVEI	C, 170		;RESET THE COLUMN COUNT
	MOVEI	A, LF		;GET A LINE FEED CHARACTER
	JRST	DEPOT.		;TYPE IT AND EXIT

OUTFIN:	MOVEI	A, DOLLAR	;GET A DOLLAR SIGN TO TERMINATE
	PUSHJ	P,DEPOT.	;OUTPUT IT
	MOVEI	A,LF		;GET A LF FOR TTY OUTPUT
	JRST	DEPOT.		;OUTPUT IT, GO AWAY FOREVER

VTYPO:	CAIGE	C, 7		;ENOUGH ROOM FOR VARIABLE?
	PUSHJ	P, CRLF		;NO, OUTPUT A CR
	PUSHJ	P, NTYPO	;OUTPUT THE NAME
	MOVEI	A, EQUALS	;GET AN EQUAL SIGN
	SOJA	C, DEPOT.	;OUTPUT IT AND EXIT

;ROUTINE TO OUTPUT A RADIX 50 SYMBOL
NTYPO:	TLZ	S, 740000	;CLEAR THE CODE BITS
NTYPO2:	IDIVI	S, 50		;RECURSIVE ROUTINE
	HRLM	S+1, (P)	;SAVE THE CHARACTER ON THE STACK
	JUMPE	S,.+2		;IS THAT ALL OF THE SYMBOL?
	PUSHJ	P, NTYPO2	;NO, CALL NTYPO2 RECURSIVELY
	HLRZ	A, (P)		;YES, GET A NUMBER OFF THE STACK
	CAILE	A, 12		;CONVERT TO ASCII
	ADDI	A, 7
	ADDI	A, 57
	SOJA	C, DEPOT.	;TYPE IT,RETURN OR EXIT

;ROUTINE TO PRINT A COMMA
PCOMMA:	MOVEI	A, COMMA	;GET AN ASCII COMMA CHARACTER
	JRST	DEPOT.		;PRINT IT AND EXIT
;NAMELIST INPUT SECTION
;THE MAJOR FLOW OF EVENTS IN THE INPUT SECTION IS AS FOLLOWS:
;	1.GET THE NAMELIST NAME FROM THE INPUT DEVICE. THE NAME
;	  BEGINS IN COLUMN 3 OF A RECORD, AND IS PRECEDED BY A
;	  DOLLAR SIGN OR AN AMPERSAND.
;	2.COLLECT A VARIABLE NAME IN RADIX 50 FORMAT FROM THE
;	  INPUT DEVICE. FIND THE SAME VARIABLE NAME IN THE 
;	  NAMELIST TABLE, AND DISPATCH TO AN INPUT ROUTINE
;	  DEPENDING ON THE TYPE OF THE VARIABLE. A SEPARATE
;	  DISPATCH IS ALSO MADE FOR ARRAY VARIABLES AS OPPOSED TO
;	  SCALAR VARIABLES.
;	3.ONCE IN THE INPUT ROUTINE, INPUT THE VALUE WITH THE
;	  PROPER FORTRAN INPUT ROUTINE, AND STORE IT IN THE CORE
;	  ADDRESS INDICATED IN THE NAMELIST TABLE. IF AN ARRAY,
;	  CONTINUE THE INPUT OF MORE ELEMENTS OF THIS ARRAY.

;A NUMBER OF SUBSIDIARY ROUTINES EXIST TO HELP THE INPUT SECTION
;OF NAMELIST SCAN THE INPUT STRING AND ABORT UNDER SPECIFIED
;CONDITIONS. THESE ROUTINES ARE ALL CALLED IN THE FOLLOWING MANNER
;	JSP	N, ROUTINE
;SO THAT THE INDIVIDUAL ROUTINES MAY ABORT (WHEN THE FINAL $ OR &
;IS FOUND) WITHOUT LEAVING JUNK BEHIND ON THE PUSHDOWN LIST.
;MOST OF THE ROUTINES ARE USED TO SCAN PAST ANY EXTRANEOUS COMMAS,
;SPACES, CARRIAGE RETURNS, ETC. IN THE INPUT STRING.

;THERE ARE TWO SPECIAL INTERFACES WITH THE FORTRAN OPERATING
;SYSTEM WHICH SHOULD BE NOTED:
;	1. ON THE RETURN FROM ANY OF THE INPUT ROUTINES - FORSE.,
;	   DIRT., ETC. - THE DELIMITING CHARACTER WILL BE FOUND
;	   IN REGISTER DELIM. THIS FEATURE IS NECESSARY
;	   FOR NMLST. TO BE ABLE TO HANDLE THE STRING LIKE
;		A=6*1.0,2.0,3.0
;	   WHERE A IS AN ARRAY CONSISTING OF 8 ELEMENTS. THE 6
;	   IS A REPETITION COUNT, AND IS RECOGNIZED BY THE PRESCENE
;	   OF THE * . 
;	2. WHEN INPUT IS DONE THROUGH THE CHINN. ROUTINE, THE
;	   BUFFER POINTER WILL NOT BE ADVANCED UNLESS THE INPUT
;	   CHARACTER IS A CARRIAGE RETURN. IN THAT CASE, THE
;	   BUFFER POINTER IS ADVANCED TO THE BEGINNING OF THE NEXT
;	   LINE, AND THE FLAG OVFLS. IS SET IN FORSE. IN ORDER
;	   TO DO FURTHER INPUT, NMLST. MUST ZERO THE FLAG. ALSO,
;	   WHEN DOING INPUT WITH THE VARIOUS FORTRAN INPUT
;	   CONVERSION ROUTINES - FLIRT.,DIRT., ETC. -AN ILLEGAL
;	   TERMINATING CHARACTER WILL BE "GOBBLED UP". THUS, IF
;	   PART OF THE INPUT STRING IS ...1.0,2.0..... ONE CALL
;	   TO FLIRT. WILL INPUT THE 1.0, STOPPING ON AND ADVANCING
;	   PAST THE COMMA. THE SECOND CALL TO FLIRT. WILL BEGIN
;	   ITS INPUT WITH THE "2" OF 2.0


NLIN.:	PUSH	P, ZERO		;0 WORD ON PD LIST FOR VAR. INPUT
	SETZM	DELIM.(LOW)	;CLEAR DELIMITER INCASE $
GETNAM:	PUSHJ	P, CHINN.	;GET FIRST CHARACTER OF RECORD
	XCT	IIB.		;ADVANCE THE BUFFER COUNTER
	PUSHJ	P, CHINN.	;GET THE SECOND CHARACTER
	CAIE	A, DOLLAR	;IS IT A DOLLAR SIGN?
	CAIN	A, AMPRSN	;OR IS IT AN AMPERSAND?
	JRST	CHKNAM		;YES, CHECK THE NAMELIST NAME
	AOS 2(M)
NXTREC:	MOVEI	2, 0		;INITIALIZE SPECIAL AC FOR FORSE.
	PUSHJ	P, ENDLN.	;CALL FORSE. FOR THE NEXT RECORD
	JRST	GETNAM		;TRY AGAIN

CHKNAM:	XCT	IIB.		;ADVANCE THE BUFFER POINTER
	PUSHJ	P, GETSYM	;COLLECT A RADIX 50 SYMBOL
	AOS 2(M)
	CAME	S, (B)		;DOES IT MATCH THE ONE IN OUR TABLE?
	JRST	NXTREC		;NO, MOVE ON TO NEXT RECORD

NXTVAR:	JSP	N, CHECKA	;LOOK FOR BEGINNING OF VAR. NAME
	AOS	2(M)		;ADD ONE TO ITEM COUNT
	PUSHJ	P, GETSYM	;GET A RADIX 50 VARIABLE NAME
	AOS 2(M)
PKVAR:	MOVEI	C, 1(B)		;SPECIAL ENTRY, INITIALIZE SEARCH
CHECK:	SKIPN	(C)		;END OF NAMELIST TABLE?
	JRST	NMLER.		;YES, SYNTAX ERROR
	MOVE	D, (C)		;NO, PICK UP VARIABLE NAME FROM TABLE
	TLZ	D, 740000	;WIPE OUT THE CODE BITS
	CAMN	D, S		;DOES IT MATCH THE ONE WE COLLECTED?
	JRST	INPUT		;YES, PREPARE FOR INPUT
	ADDI	C, 2		;NO, MOVE POINTER DOWN TWO
	SKIPL	-2(C)		;DID WE JUST LOOK AT ANY ARRAY?
	JRST	CHECK		;NO,POINTER IS NOW LOOKING AT NXT ONE
	ADD	C, (C)		;YES, ADD DIMENSIONALITY TO PNTR
	ADDI	C, 3		;AND MOVE IT PAST OFFSET,SIZE,ETC.
	JRST	CHECK		;TRY ANOTHER ENTRY FROM THE TABLE

INPUT:	SKIPGE	(C)		;IS THIS AN ARRAY INPUT?
	JRST	IARRA3		;BIT 0 WAS ON, SO ITS AN ARRAY
	JSP	N, FORMTE	;SCALAR, SO WE MOVE PAST THE <=>
	HRRZ	D, 1(C)		;GET THE ADDRESS FOR STORING VAR.
	LDB	E, [POINT 3,(C),3] ; GET THE CODE BITS
	HRRZ	E, STABLE(E)	;GET ADDRESS OF PROPER INPUT ROUTIN
	JRST	(E)		;INPUT ACCORDING TO TYPE
IARRA3:	SOS 2(M)
IARRAY:	XCT	IIB.		;ADVANCE THE BUFFER POINTER
	CAIN	A, LFTPAR	;WAS VAR. DELIMITED BY LEFT PAREN?
	JRST	ARRAY1		;YES, ITS ALMOST LIKE A SCALAR
	CAIN	A, EQUALS	;OR WAS IT DELIMITED BY AN  <=>?
	JRST	ARRAY2		;YES, INPUT AN ENTIRE ARRAY
	PUSHJ	P, CHINN.	;NO,SYMBOL TERMINATED BY SOME OTHER CHAR
	JRST	IARRAY		;SO TRY AGAIN

;FOLLOWING SECTION CALCULATES A SUBRSCRIPT, THEN INPUTS AS IF
;THE VARIABLE WERE AN ORDINARY SCALAR VARIABLE
ARRAY1:	MOVN	E, 2(C)		;PREPARE TO CALCULATE SUBSCRIPT
	MOVSS	E		;GET NEG. DIMENSIONALITY CNT IN LH
	HRRI	E, 3(C)		;ADDRESS OF MULTIPLIERS IN R.H.
	MOVEI	D, 0		;INITIALIZE ACCUMULATED SUBSCRIPT
GETSS:	JSP	N, FORMTS	;IGNORE LEADING SPACES, ETC.
	AOS	2(M)		;ADD ONE TO THE ITEM COUNT
	PUSHJ	P, INTI.	;COLLECT A SUBSCRIPT
	JFCL			;INTI. ILLEGAL CHARACTER RETURN
	IMUL	A, (E)		;MULTIPLY BY PROPER P(N)
	ADD	D, A		;ADD IT INTO THE ACCUMULATED SUM
	MOVE	A, DELIM.(LOW)	;TAKE A LOOK AT THE DELIMITER
	CAIE	A, RGTPAR	;WAS IT A RIGHT PARENTHESIS?
	AOBJN	E, GETSS	;OR HAVE WE GOTTEN ALL SUBSCRIPTS?
	LDB	E, [POINT 2,(C),2] ;YES, NOW GET HIGH ORDER CODE BITS
	CAIN	E, 3		;WAS IT A CODE 6 OR A COE 7?
	ASH	D, 1		;YES, ACCOUNT FOR TWO WORDS/ENTRY
	MOVEI	E, 3(C)		;PREPARE TO GET ARRAY OFFSET
	ADD	E, -1(E)	;POINTER IS NOW AT THE OFFSET LOC.
	SUB	D, (E)		;SUB OFFSET FROM SUBSCRIPT CALC.
	ADD	D, 1(C)		;ADD ARRAY BASE ADDRESS
	JSP	N, FORMTE	;MOVE PAST THE EQUAL SIGN
	LDB	E, [POINT 3,(C),3]; GET CODE BITS
	HLRZ	E, STABLE(E)	;GET ADDRESS OF PROPER ARRAY ROUTINE
	JRST	(E)		;INPUT ACCORDING TO TYPE

;FOLLOWING SECTION PREPARES AN AOBJN WORD TO INPUT AN ENTIRE
;ARRAY, THEN DISPATCHES TO PROPER ARRAY INPUT ROUTINE
ARRAY2:	MOVEI	D, 4(C)		;CALCULATE A POINTER TO THE ARRAY
	ADD	D, -2(D)	;SIZE OF THE VARIABLE
	MOVN	D, (D)		;PICK UP NEGATIVE ARRAY SIZE
	MOVSS	D		;AOBJN WRD WITH COUNT IN LEFT HALF
	HRR	D, 1(C)		;AND BASE ADDRESS IN RIGHT HALF
	LDB	E, [POINT 3,(C),3] ;GET CODE BITS
	HLRZ	E, STABLE(E)	;GET ADDRESS OF PROPER ARRAY ROUTINE
	JRST	(E)		;INPUT ACCORDING TO TYPE
STABLE:	XWD	AINT, INTEGR	;INTEGER INPUT
ZERO:	0			;NOT USED IN DISPATCH
	XWD	AREAL, REAL	;REAL INPUT
	XWD	ALOG, LOGICL	;LOGICAL INPUT
	XWD	ERROR,ERROR	;OCTAL INPUT
	XWD	ERROR,ERROR	;LITERAL INPUT
	XWD	ADBLE, DOUBLE	;DOUBLE PRECISION INPUT
	XWD	ACOM, COMPLX	;COMPLEX INPUT


;SCALAR INTEGER INPUT ROUTINE
INTEGR:	JSP	N, FORMTS	;IGNORE ANY LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, INTI.	;GET AN INTEGER VARIABLE
	JFCL			;INTI. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;STORE IT
	JRST	$CKDLM		;PREPARE FOR NEXT VARIABLE

;SCALAR REAL INPUT ROUTINE
REAL:	JSP	N, FORMTS	;IGNORE ANY LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, FLIRT.	;GET A REAL VARIABLE
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;STORE IT
	JRST	$CKDLM		;PREPARE FOR NEXT VARIABLE

;SCALAR LOGICAL INPUT ROUTINE
LOGICL:	PUSHJ	P, LOGIC1	;CALL COMMON LOGICAL INPUT ROUTINE
	JRST	$CKDLM		;PREPARE FOR NEXT VARIABLE

;COMMON LOGICAL INPUT ROUTINE (USED BY ARRAY AND SCALAR INPUTS)
LOGIC1:	JSP	N, FORMTS	;IGNORE ANY LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	XCT	IIB.		;ADVANCE BUFFER POINTER PAST .,T,F
	SOS 2(M)
	CAIN	A, PERIOD	;DID WE STOP ON A PERIOD?
	JRST	LOGIC2		;YES, LOOK FOR .TRUE., ETC.
	SETZM	(D)		;ASSUME IT'S AN "F"
	CAIN	A, "T"		;WAS IT REALLY?
	SETOM	(D)		;NO, BY GOSH, IT WAS A "T"
	POPJ	P,		;EXIT FROM COMMON LOGICAL ROUTINE
LOGIC2:	PUSHJ	P, CHINN.	;GET A "T" OR AN "F"
	AOS 2(M)
	SETZM	(D)		;ASSUME ITS AN "F"
	CAIN	A, "T"		;WAS IT REALLY?
	SETOM	(D)		;GOOD GRIEF - IT WAS A "T" !!!
LOGFIN:	PUSHJ	P, CHINN.	;NOW LOOK FOR A CLOSING PERIOD
	XCT	IIB.		;ADVANCE BUFFER POINTER PAST PERIOD
	CAIN	A, PERIOD	;BUT WAS IT REALLY A PERIOD?
	POPJ	P,		;YES, EXIT FROM COMMON LOGICAL ROUTIN
	JRST	LOGFIN		;NO, TRY AGAIN
;SCALAR DOUBLE PRECISION INPUT ROUTINE
DOUBLE:	EXCH	F, B		;SAVE POINTER TO NAMELIST TABLE
	JSP	N, FORMTS	;IGNORE ANY LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, DIRT.	;INPUT A DOUBLE PRECISION NUMBER
	JFCL			;DIRT. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;STORE THE HIGH ORDER PORTION
	MOVEM	B, 1(D)		;STORE THE LOW ORDER PORTION
	EXCH	B, F		;RESTORE NAMELIST TABLE PNTR
$CKDLM:	MOVE	K,DELIM.(LOW)	;CHECK FOR $ OR &
	CAIE	K,DOLLAR	;WAS IT QUITTING TIME ?
	CAIN	K,AMPRSN	;...
	JRST INFIN1		;YES, CLOSE OUT INPUT
	JRST	NXTVAR		;NO, CHECK FOR NEXT VARIABLE

;SCALAR COMPLEX INPUT ROUTINE
COMPLX:	JSP	N, FORMTS	;IGNORE ANY LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	XCT	IIB.		;THIS SHOULD GET PAST THE <(>
	PUSHJ	P, FLIRT.	;INPUT REAL PART OF COMPLEX NMBR
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;STORE IT
	JSP	N, FORMTS	;IGNORE ANY JUNK BETWEN REAL AND IMAG
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, FLIRT.	;GET THE IMAGINARY PART OF COMPLEX
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
	MOVEM	A, 1(D)		;STORE IT
	JRST	$CKDLM		;PREPARE FOR NEXT VARIABLE
;ARRAY INTEGER INPUT ROUTINE
AINT:	JSP	N, FORMTS	;IGNORE ANY LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 OT ITEM COUNT
	JSP	N, CHECKN	;LOOK AT NEXT ENTRY JUST IN CASE
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, INTI.	;COLLECT AN INTEGER VARIABLE
	JFCL			;INTI. ILLEGAL CHARACTER RETURN
	JSP	N, DELIMT	;CHECK THE NATURE OF THE DELIMITER
	JRST	AINT2		;IT WAS AN ASTERISK,GO REPEAT
	MOVEM	A, (D)		;NORMAL RETURN - SAVE THE INTEGER
	JUMPE	K, INFIN1	;QUIT IF LAST ARG ENDED WITH A $
	AOBJN	D, AINT		;LOOP BACK FOR MORE ELEMENTS
	JRST	NXTVAR		;ALL DONE WITH THIS ARRAY
AINT2:	MOVE	C, A		;SAVE THE REPETITION COUNT WE HVE
	JSP	N, FORMTS	;IGNORE STUFF BETWEEN * AND NUMBER
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, INTI.	;GET THE TRUE INTEGER VARIABLE
	JFCL			;INTI. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;SAVE IT
	AOBJP	D, $CKDLM	;INCREMENT STORAGE PNTR,CHK OVERFLOW
	SOJG	C, .-2		;LOOP BACK FOR REPETITION OF VAR.
	JRST	AINT		;GET MORE ELEMENTS OF THIS ARRAY

;ARRAY REAL INPUT ROUTINE
AREAL:	JSP	N, FORMTS	;IGNORE ANY LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	JSP	N, CHECKN	;LOOK AT NEXT ENTRY JUST IN CASE
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, FLIRT.	;GET A FLOATING POINT NUMBER
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
	JSP	N, DELIMT	;CHECK THE NATURE OF THE DELIMITER
	JRST	AREAL2		;IT WAS AN ASTERISK, GO REPEAT
	MOVEM	A, (D)		;NORMAL RETRN, STORE THE NUMBER
	JUMPE	K, INFIN1	;QUIT IF LAST ARG ENDED WITH A $
	AOBJN	D, AREAL	;LOOP BACK FOR MORE ELEMENTS OF ARRAY
	JRST	NXTVAR		;ALL DONE WITH THIS ARRAY
AREAL2:
	PUSHJ	P, IFIXA	;CONVERT REPETITION COUNT TO INTEGER
	JSP	N, FORMTS	;IGNORE JUNK BETWEEN * AND NUMBER
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	PUSHJ	P, FLIRT.	;GET THE TRUE REAL VARIABLE
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;STORE IT
	AOBJP	D, $CKDLM	;INCREMENT STORAGE PNTR,CHK OVERFLOW
	SOJG	C, .-2		;LOOP BACK FOR MORE REPEATED COUNTS
	JRST	AREAL		;RETURN FOR MORE ELEMENTS OF ARRAY

;36 BIT FIX FUNCTION TAKEN FROM IFIX

IFIXA:	PUSH	P,B		;SAVE B
	MULI	A, 400		;SEPARATE FRACTION AND EXPONENT
	TSC	A, A		;GET POSITIVE EXPONENT
	EXCH	A, B		;PUT PARTIAL RESULTS IN A
	ASH	A, -243(B)	;USE EXPONENT AS INDEX REGISTER
	POP	P,B		;RESTORE B
	MOVE	C, A		;SAVE THE REPETITION COUNT
	POPJ	P,		;RETURN
;ARRAY LOGICAL ROUTINE
ALOG:	JSP	N, FORMTS	;IGNORE LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	CAIE	A, "T"		;IS THE CHARACTER A "T"?
	CAIN	A, "F"		;OR AN "F"?
	JRST	PEEK		;CHECK IT, IT MIGHT BE NEXT VAR
	JSP	N, CHECKN	;CHECK IT FOR VARIABLE NAME POSSIBILITY
	AOS	2(M)		;ADD 1 TO THE ITEM COUNT
	CAIL	A, "0"		;DID WE STOP ON A NUMERIC CHAR?
	CAILE	A, "9"		;...
	JRST	ALOG2		;NO, NORMAL INPUT
	PUSHJ	P, INTI.	;YES, INPUT THE REPETITION COUNT
	JFCL			;INTI. ILLEGAL CHARACTER RETURN
	MOVE	C, A		;SAVE IT FOR A COUNTER
	PUSHJ	P, LOGIC1	;CALL COMMON ROUTIN E TO INPUT
	MOVEM	A, (D)		;STORE IT (REDUNDANT THE FIRST TIME)
	AOBJP	D, $CKDLM	;INC STORAGE COUNTER,CHK OVERFLOW
	SOJG	C, .-2		;LOOP FOR MORE REPETITIONS OF ELEMENT
	JRST	ALOG		;RETURN FOR MORE ELEMENTS OF ARRAY

ALOG2:	PUSHJ	P, LOGIC1	;CALL COMMON ROUTINE TO GET "T" OR "F"
	AOBJN	D, ALOG		;LOOP FOR MORE ELEMENTS OF ARRA
	JRST	$CKDLM		;PREPARE FOR NEXT VARIABLE

;SECTION OF CODE TO PEEK AT NEXT CHARACTER AFTER THE ALOG
;ROUTINE HAS SEEN A "T" OR AN "F". THE CURRENT CHARACTER IS
;SAVED, AND THE NEXT CHARACTER IS EXAMINED TO SEE IF THE ROUTINE
;IS LOOKING AT AN ARGUMENT FOR THE LOGICAL ARRAY, OR AT THE NEXT
;VARIABLE NAME IN THE NAMELIST INPUT STRING. IN EITHER CASE, IT
;MUST DO ITS OWN PROCESSING, SINCE THE BUFFER POINTER HAS
;BEEN MOVED PAST THE FIRST "T" OR "F".
PEEK:	MOVE	E, A		;SAVE THE "T" OR "F"
	XCT	IIB.		;ADVANCE THE BUFFER POINTER TO NEXT CHAR
	SOS 2(M)
	JSP	N, FORMTS	;IGNORE SPACES AND OTHER JUNK
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	CAIN	A, COMMA	;DID WE STOP ON A COMMA?
	JRST	PEEKTF		;YES, PROCESS THE "T" OR "F"
	MOVEI	S, 0		;NO, PREPARE SPECIAL ENTRY TO GETSYM
	MOVEI	C, 6		;...
	MOVE	A, E		;RESTORE FIRST LETTER OF NEXT VAR.
	PUSHJ	P, PEEKEN	;SPECIAL ENTRY, GET VARIABLE NAME
	JRST	PKVAR		;SPECIAL ENTRY TO NXTVAR

PEEKTF:	SETZM	(D)		;ASSUME IT WAS AN "F"
	CAIN	E, "T"		;WAS IT REALLY?
	SETOM	(D)		;NO, IT WERE A "T", INDEED IT WERE
	AOBJN	D, ALOG		;LOOK FOR NEXT ENTRY
	JRST	$CKDLM		;UNLESS ARRAY IS FULL

;ARRAY DOUBLE PRECISION INPUT ROUTINE
ADBLE:	JSP	N, FORMTS	;IGNORE LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	JSP	N, CHECKN	;ARGUMENT OR NEXT VARIABLE ?
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	MOVE	E, B		;SAVE NAMELIST POINTER
	PUSHJ	P, DIRT.	;GET DOUBLE PRECISION ARGUMENT
	JFCL			;DIRT. ILLEGAL CHARACTER RETURN
	JSP	N, DELIMT	;TAKE A LOOK AT THE DELIMITER
	JRST	ADBLE2		;IT WAS AN ASTERISK
	MOVEM	A, (D)		;STORE THE HIGH ORDER WORD
	AOJ	D,		;INCREMENT THE AOBJN POINTER
	MOVEM	B, (D)		;STORE THE LOW ORDER WORD
	MOVE	B, E		;RESTORE THE NAMELIST POINTER
	JUMPE	K, INFIN1	;QUIT IF LAST ARG ENDED WITH A $
	AOBJN	D, ADBLE	;GET NEXT ENTRY IN THE ARRAY
	JRST	NXTVAR		;UNLESS ARRAY IS FULL, THEN GET VAR
ADBLE2:
	PUSHJ	P,IFIXA
	PUSHJ	P, DIRT.	;GET THE REAL ARGUMENT
	JFCL			;DIRT. ILLEGAL CHARACTER RETURN
ADBLE3:	MOVEM	A, (D)		;STORE THE HIGH ORDER WORD
	AOJ	D,		;INCREMENT THE AOBJN POINTER
	MOVEM	B, (D)		;STORE THE LOW ORDER WORD
	AOBJP	D, ADBLE4	;INCREMENT AND CHECK ARRAY OVERFLOW
	SOJG	C, ADBLE3	;LOOP BACK FOR MORE REPEATED ELEEMENTS
	JRST	ADBLE		;GET MORE ELEMENTS OF ARRAY
ADBLE4:	MOVE	B, E		;RESTORE NAMELIST POINTER
	JRST	$CKDLM		;RETURN FOR NEXT VARIABLE


;ARRAY COMPLEX INPUT ROUTINE
ACOM:	JSP	N, FORMTS	;IGNORE LEADING SPACES, ETC.
	AOS	2(M)		;ADD 1 TO THE ITEM COUNT
	JSP	N, CHECKN	;CHECK FOR NEXT VARIABLE NAME
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	CAIN	A, LFTPAR	;DID WE STOP ON A LEFT PARENTHESIS?
	JRST	ACOM2		;YES, NORMAL INPUT
	PUSHJ	P, INTI.	;NO, GET REPETITION COUNT
	JFCL			;INTI. ILLEGAL CHARACTER RETURN
	MOVE	C, A		;SAVE IT
	JSP	N, FORMTS	;IGNORE ANY JUNK BEFORE COMPLEX NUMBER
	AOS	2(M)		;ADD 1 TO ITEM COUNT
	XCT	IIB.		;THIS SHOULD WIPE OUT LEFT PAREN
	SOS 2(M)
	MOVE	E, A		;SAVE REAL PART
	JSP	N, FORMTS	;IGNORE JUNK BETWEEN REAL AND IMAG
	AOS	2(M)		;ADD 1 TO THE ITEM COUNT
	PUSHJ	P, FLIRT.	;GET THE IMAGINARY PART
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
ACLOOP:	MOVEM	E, (D)		;STORE THE REAL PART
	AOJ	D,		;INCREMENT THE STORAGE POINTER
	MOVEM	A, (D)		;STORE IMAGINARY PART
	AOBJP	D, $CKDLM	;INCR STORAGE PNTR,CHK OVERFLOW
	SOJG	C, ACLOOP	;LOOP FOR REPEATED ELEMENTS OF ARRAY
	JRST	ACOM		;RETURN FOR MORE ELEMENTS OF ARRAY

ACOM2:	SOS 2(M)
	XCT	IIB.		;GET PAST LEFT PARENTHESIS
	PUSHJ	P, FLIRT.	;GET REAL PART OF ARRAY
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;STORE IT
	AOJ	D,		;INCREMENT STORAGE POINTER
	JSP	N, FORMTS	;IGNORE JUNK BETWEEN REAL AND IMAG
	AOS	2(M)		;ADD ONE TO ITEM COUNT

	PUSHJ	P, FLIRT.	;GET IMAGINARY PART OF NUMBER
	JFCL			;FLIRT. ILLEGAL CHARACTER RETURN
	MOVEM	A, (D)		;STORE IT
	JSP	N,FORMTS	;IGNORE JUNK AFTER IM. PART
	AOS 2(M)
	CAIE	A,RGTPAR
	JRST .+3
	SOS 2(M)
	XCT	IIB.
	AOBJN	D, ACOM		;LOOP FOR MORE ELEMENTS IN ARRAY
	JRST	$CKDLM		;DONE WITH THIS ARRAY
;ROUTINE TO INPUT A RADIX 50 SYMBOL
GETSYM:	MOVEI	S, 0		;INITIALIZE SYMBOL WORD
	MOVEI	C, 6		;INITIALIZE COUNT FOR SIX CHARS
NXTLET:	PUSHJ	P, CHINN.	;GET A CHARACTER
PEEKEN:	CAIL	A, "A"		;IS IT ALPHA? (SPECIAL PEEK ENTRY)
	CAILE	A, "Z"		;...
	JRST	.+2		;NO, TRY NUMERIC
	JRST	STOLET		;YES, STORE IT
	CAIL	A, "0"		;IS IT NUMERIC?
	CAILE	A, "9"		;...
	JRST OV
STOLET:	XCT	IIB.		;ADVANCE THE BUFFER POINTER
	SOJL	C, NXTLET	;IS THERE ROOM TO STORE CHARACTER?
	IMULI	S, 50		;YES, MULTIPLY CURRENT SYMBOL
	CAILE	A, "9"		;IS IT A NUMBER
	SUBI	A, 7		;CONVERT LETTER TO RADIX 50
	SUBI	A, 57		;CNVRT NUMBER TO RADIX 50
	ADD	S, A		;ADD IN CURRENT SYMBOL
	JRST	NXTLET		;GET NEXT CHARACTER
OV:	CAIE A,CR
	POPJ	P,
	SOS 2(M)
	SETZM OVFLS.(LOW)
	JRST .-3

;ROUTINE TO IGNORE SPACES, TABS, CR,LF, ETC., EXIT ON A <$>
;OR A <&>. THE CALLING SEQUENCE IS JSP N,FORMTS
IGNORE:	XCT	IIB.		;MOVE POINTER PAST UNWORTHY CHAR.
FORMTS:	PUSHJ	P, CHINN.	;GET THE CURRENT CHARACTER
	CAIE	A, DOLLAR	;IS IT QUITTING TIME?
	CAIN	A, AMPRSN	;...
	JRST	INFIN		;YES
	CAIN	A, COMMA	;IGNORE COMMAS
	JRST	IGNORE		;...
	CAIE	A, TAB		;IGNORE TABS AND SPACES
	CAIN	A, SPACE	;...
	JRST	IGNORE		;...
	CAIE	A, CR		;IS IT A CARRIAGE RETURN?
	JRST	(N)		;NO, EXIT
	SETZM	OVFLS.(LOW)	;YES, RESET FORSE. OVERFLOW FLAG
	JRST	FORMTS		;DON'T INCREMENT POINTER,GT MORE

;ROUTINE TO CHECK THE NATURE OF A DELIMITER ON INPUT. EXITS TO
;CALLING ADDRESS+1 IF IT WAS AN ASTERISK, EXITS TO CALLING ADDRESS
;+2 OTHERWISE. IGNORES CR AND LF IF IT FINDS THEM
DELIMT:	MOVE	K, DELIM.(LOW)	;GET THE DELIMITING CHARACTER
	CAIE	K, DOLLAR	;WAS IT QUITTING TIME?
	CAIN	K, AMPRSN	;...
	MOVEI	K, 0		;SET FLAG FOR INPUT ROUTINE
	CAIN	K, "*"		;WAS IT AN ASTERISK?
	JRST	(N)		;YES
	SETZM	OVFLS.(LOW)	;CLEAR FORSE. FLAG IF IT WAS SET
	JRST	1(N)		;GOOD EXIT TO CALLING ADDRESS+2
;INFIN IS CALLED WHEN A NAMELIST INPUT HAS BEEN COMPLETED. IT 
;REMOVES THE ZERO WORD THAT WAS PLACED ON THE PUSHDOWN LIST
;AT NLIN., THEN EXITS
INFIN:	AOS	2(M)		;...
INFIN1:	POP	P, A		;GET RID OF ZERO WORD
	POPJ	P,		;EXIT

;ROUTINE TO MOVE PAST THE EQUAL SIGN IN A VARIABLE ASSIGNMENT
FORMTE:	PUSHJ	P, CHINN.	;GET THE CURRENT CHARACTER
	SETZM	OVFLS.(LOW)	;CLEAR FORSE. OVERFLOW FLAG
	CAIE	A, CR		;DONT ADVANCE POINTER IF A CR
	XCT	IIB.		;MOVE TO NEXT CHARACTER
	CAIN	A, EQUALS	;WAS THIS ONE AN EQUAL SIGN?
	JRST	(N)		;YES, EXIT
	JRST	FORMTE		;NO, TRY AGAIN
;ROUTINE TO CHECK THE NEXT ELEMENT OF ARRAY INPUT TO SEE IF IT
;IS NUMERIC OR THE NEXT VARIABLE NAME. RETURNS TO CALLING ADDRESS+1
;IF NUMERIC, AND TO NXTVAR OTHERWISE. DOES NOT DISTURB THE
;CHARACTER POINTER. CALLED FROM NXTVAR ITSELF, ALSO.
CHECKN:	PUSHJ	P, CHINN.	;GET THE CURRENT CHARACTER
	CAIE	A, DOLLAR	;CHECK FOR DOLLAR SIGN
	CAIN	A, AMPRSN	;OR AN AMPERSAND
	JRST	INFIN		;YES, TERMINATE INPUT
	CAIL	A, "A"		;IS IT ALPHABETIC?
	CAILE	A, "Z"		;...
	JRST .+3
	AOS 2(M)
	JRST	NXTVAR		;GO GET NEXT VARIABLE NAME
	CAIE	A, CR		;DID WE STOP ON A CR?
	JRST	(N)		;NO, EXIT
	SETZM	OVFLS.(LOW)	;YES, CLEAR FORSE. OVERFLOW FLAG
	JRST	CHECKN		;START READING THE NEXT LINE

;ROUTINE TO FIND THE BEGINNING OF THE NEXT ALPHABETIC VARIABLE
CHECKA:	PUSHJ	P, CHINN.	;GET A CHARACTER
	SETZM	OVFLS.(LOW)	;CLEAR THE FORSE. OVERFLOW FLAG
	CAIE	A, DOLLAR	;DID WE PICK UP A DOLLAR SIGN?
	CAIN	A, AMPRSN	;OR AN AMPERSAND?
	JRST	INFIN		;YES, TERMINATE NAMELIST INPUT
	CAIL	A, "A"		;IS IT AN ALPHABETIC CHARACTER?
	CAILE	A, "Z"		;...
	JRST	.+2		;NO, SPECIAL HANDLING
	JRST	(N)		;YES, EXIT POINTING TO CHARACTER
	CAIE	A, CR		;WAS IT A CARRIAGE RETURN?
	XCT	IIB.		;NO, ADVANCE THE BUFFER POINTER
	JRST	CHECKA		;TRY ANOTHER CHARACTER
	END

